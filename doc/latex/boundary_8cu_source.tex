\hypertarget{boundary_8cu_source}{}\doxysection{boundary.\+cu}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 /**}
\DoxyCodeLine{00002  * @author      Christoph Schaefer cm.schaefer@gmail.com}
\DoxyCodeLine{00003  *}
\DoxyCodeLine{00004  * @section     LICENSE}
\DoxyCodeLine{00005  * Copyright (c) 2019 Christoph Schaefer}
\DoxyCodeLine{00006  *}
\DoxyCodeLine{00007  * This file is part of miluphcuda.}
\DoxyCodeLine{00008  *}
\DoxyCodeLine{00009  * miluphcuda is free software: you can redistribute it and/or modify}
\DoxyCodeLine{00010  * it under the terms of the GNU General Public License as published by}
\DoxyCodeLine{00011  * the Free Software Foundation, either version 3 of the License, or}
\DoxyCodeLine{00012  * (at your option) any later version.}
\DoxyCodeLine{00013  *}
\DoxyCodeLine{00014  * miluphcuda is distributed in the hope that it will be useful,}
\DoxyCodeLine{00015  * but WITHOUT ANY WARRANTY; without even the implied warranty of}
\DoxyCodeLine{00016  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
\DoxyCodeLine{00017  * GNU General Public License for more details.}
\DoxyCodeLine{00018  *}
\DoxyCodeLine{00019  * You should have received a copy of the GNU General Public License}
\DoxyCodeLine{00020  * along with miluphcuda.  If not, see <http://www.gnu.org/licenses/>.}
\DoxyCodeLine{00021  *}
\DoxyCodeLine{00022  */}
\DoxyCodeLine{00023 \#include "{}timeintegration.h"{}}
\DoxyCodeLine{00024 \#include "{}boundary.h"{}}
\DoxyCodeLine{00025 \#include "{}miluph.h"{}}
\DoxyCodeLine{00026 \#include "{}pressure.h"{}}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028 }
\DoxyCodeLine{00029 extern \_\_device\_\_ double substep\_currentTimeD;}
\DoxyCodeLine{00030 extern \_\_device\_\_ double currentTimeD;}
\DoxyCodeLine{00031 extern \_\_device\_\_ double dt;}
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033 \#if DENSITY\_FLOOR}
\DoxyCodeLine{00034 extern \_\_device\_\_ double density\_floor\_d;}
\DoxyCodeLine{00035 \#endif}
\DoxyCodeLine{00036 }
\DoxyCodeLine{00037 }
\DoxyCodeLine{00038 \#if GHOST\_BOUNDARIES}
\DoxyCodeLine{00039 /* these are the locations and the properties of the boundary walls */}
\DoxyCodeLine{00040 const \_\_device\_\_ int numWalls = 1;}
\DoxyCodeLine{00041 \_\_device\_\_ double d[numWalls] = \{-\/0.007\};}
\DoxyCodeLine{00042 \_\_device\_\_ double nx[numWalls] = \{0\};}
\DoxyCodeLine{00043 \_\_device\_\_ double ny[numWalls] = \{0\};}
\DoxyCodeLine{00044 \#if DIM == 3}
\DoxyCodeLine{00045 \_\_device\_\_ double nz[numWalls] = \{1\};}
\DoxyCodeLine{00046 \#endif}
\DoxyCodeLine{00047     //boundary type: 0 = no slip, 1 = free slip}
\DoxyCodeLine{00048 \#define NO\_SLIP\_BOUNDARY\_TYPE 0}
\DoxyCodeLine{00049 \#define FREE\_SLIP\_BOUNDARY\_TYPE 1}
\DoxyCodeLine{00050 \_\_device\_\_ int boundaryType[numWalls] = \{NO\_SLIP\_BOUNDARY\_TYPE\};}
\DoxyCodeLine{00051 \#endif}
\DoxyCodeLine{00052 }
\DoxyCodeLine{00053 /* set quantities for Fixed Virtual Particles with matId == BOUNDARY\_PARTICLE\_ID */}
\DoxyCodeLine{00054 \_\_device\_\_ void setQuantitiesFixedVirtualParticles(int i, int j, double *vxj, double *vyj, double *vzj, double *densityj, double *pressurej, double *Sj)}
\DoxyCodeLine{00055 \{}
\DoxyCodeLine{00056     /* j is the virtual particle, i is the real particle */}
\DoxyCodeLine{00057     int e;}
\DoxyCodeLine{00058     /* distance to plane */}
\DoxyCodeLine{00059     double dI, dJ;}
\DoxyCodeLine{00060     double beta;}
\DoxyCodeLine{00061     double oneminusbeta = 0;}
\DoxyCodeLine{00062 \#define BETA\_MAX 1.5}
\DoxyCodeLine{00063 }
\DoxyCodeLine{00064 \#if DIM > 2}
\DoxyCodeLine{00065     /* test values only for plane at z=0 */}
\DoxyCodeLine{00066     dI = p.z[i];}
\DoxyCodeLine{00067     dJ = p.z[j];}
\DoxyCodeLine{00068 }
\DoxyCodeLine{00069     beta = min(BETA\_MAX, 1.0 + dJ/dI);}
\DoxyCodeLine{00070     oneminusbeta = 1-\/beta;}
\DoxyCodeLine{00071 \#endif}
\DoxyCodeLine{00072 }
\DoxyCodeLine{00073     *vxj = oneminusbeta*p.vx[i];}
\DoxyCodeLine{00074 \#if DIM > 1}
\DoxyCodeLine{00075     *vyj = oneminusbeta*p.vy[i];}
\DoxyCodeLine{00076 \#if DIM > 2}
\DoxyCodeLine{00077     *vzj = oneminusbeta*p.vz[i];}
\DoxyCodeLine{00078 \#endif}
\DoxyCodeLine{00079 \#endif}
\DoxyCodeLine{00080 \#if SOLID}
\DoxyCodeLine{00081     for (e = 0; e < DIM*DIM; e++) \{}
\DoxyCodeLine{00082         Sj[e] = p.S[i*DIM*DIM+e];}
\DoxyCodeLine{00083     \}}
\DoxyCodeLine{00084 \#endif}
\DoxyCodeLine{00085 }
\DoxyCodeLine{00086     *pressurej = p.p[i];}
\DoxyCodeLine{00087     *densityj = p.rho[i];}
\DoxyCodeLine{00088 }
\DoxyCodeLine{00089 \}}
\DoxyCodeLine{00090 }
\DoxyCodeLine{00091 }
\DoxyCodeLine{00092 // declare some boundary conditions here: this is called at the beginning of each RHS step}
\DoxyCodeLine{00093 \_\_global\_\_ void BoundaryConditionsBeforeRHS(int *interactions) }
\DoxyCodeLine{00094 \{}
\DoxyCodeLine{00095 \#if 1}
\DoxyCodeLine{00096     register int i, inc;}
\DoxyCodeLine{00097     int matId, d, e;}
\DoxyCodeLine{00098     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00099     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{00100             matId = p\_rhs.materialId[i];}
\DoxyCodeLine{00101             if (matId == EOS\_TYPE\_IGNORE) \{}
\DoxyCodeLine{00102                 p.ax[i] = 0;}
\DoxyCodeLine{00103                 p.ay[i] = 0;}
\DoxyCodeLine{00104                 p.dxdt[i] = 0;}
\DoxyCodeLine{00105                 p.dydt[i] = 0;}
\DoxyCodeLine{00106                 p.vx[i] = 0;}
\DoxyCodeLine{00107                 p.vy[i] = 0;}
\DoxyCodeLine{00108 \#if DIM == 3}
\DoxyCodeLine{00109                 p.az[i] = 0;}
\DoxyCodeLine{00110                 p.dzdt[i] = 0;}
\DoxyCodeLine{00111                 p.vz[i] = 0;}
\DoxyCodeLine{00112 \#endif}
\DoxyCodeLine{00113 \#if SOLID}
\DoxyCodeLine{00114                 for (d = 0; d < DIM*DIM; d++) \{}
\DoxyCodeLine{00115                     p.dSdt[i*DIM*DIM + d] = 0;}
\DoxyCodeLine{00116                 \}}
\DoxyCodeLine{00117 \#endif}
\DoxyCodeLine{00118 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00119                 p.drhodt[i] = 0;}
\DoxyCodeLine{00120 \#endif}
\DoxyCodeLine{00121             \}}
\DoxyCodeLine{00122 }
\DoxyCodeLine{00123             if (matId == BOUNDARY\_PARTICLE\_ID) \{}
\DoxyCodeLine{00124                 p.ax[i] = 0;}
\DoxyCodeLine{00125                 p.ay[i] = 0;}
\DoxyCodeLine{00126                 p.dxdt[i] = 0;}
\DoxyCodeLine{00127                 p.dydt[i] = 0;}
\DoxyCodeLine{00128                 p.vx[i] = 0;}
\DoxyCodeLine{00129                 p.vy[i] = 0;}
\DoxyCodeLine{00130 \#if DIM == 3}
\DoxyCodeLine{00131                 p.az[i] = 0;}
\DoxyCodeLine{00132                 p.dzdt[i] = 0;}
\DoxyCodeLine{00133                 p.vz[i] = 0;}
\DoxyCodeLine{00134 \#endif}
\DoxyCodeLine{00135 \#if SOLID}
\DoxyCodeLine{00136                 for (d = 0; d < DIM*DIM; d++) \{}
\DoxyCodeLine{00137                     p.dSdt[i*DIM*DIM + d] = 0;}
\DoxyCodeLine{00138                 \}}
\DoxyCodeLine{00139 \#endif}
\DoxyCodeLine{00140 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00141                 p.drhodt[i] = 0;}
\DoxyCodeLine{00142 \#endif}
\DoxyCodeLine{00143 \#if DENSITY\_FLOOR}
\DoxyCodeLine{00144             \} else if (p.rho[i] < 1e-\/2*density\_floor\_d) \{}
\DoxyCodeLine{00145                 p.rho[i] = 1e-\/2*density\_floor\_d;}
\DoxyCodeLine{00146 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00147                 p.drhodt[i] = 0.0;}
\DoxyCodeLine{00148 \#endif}
\DoxyCodeLine{00149 \#endif}
\DoxyCodeLine{00150             \}}
\DoxyCodeLine{00151     \}}
\DoxyCodeLine{00152 \#endif}
\DoxyCodeLine{00153 \}}
\DoxyCodeLine{00154 }
\DoxyCodeLine{00155 }
\DoxyCodeLine{00156 // boundary conditions called after the integration step of rk2adaptive only}
\DoxyCodeLine{00157 \_\_global\_\_ void BoundaryConditionsAfterIntegratorStep(int *interactions) }
\DoxyCodeLine{00158 \{}
\DoxyCodeLine{00159     register int i, inc;}
\DoxyCodeLine{00160     int matId, d, e;}
\DoxyCodeLine{00161     double distance;}
\DoxyCodeLine{00162     double ddistance;}
\DoxyCodeLine{00163     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00164     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{00165         matId = p\_rhs.materialId[i];}
\DoxyCodeLine{00166     \}}
\DoxyCodeLine{00167 \}}
\DoxyCodeLine{00168 }
\DoxyCodeLine{00169 // declare some boundary conditions here: this is called at the end of each RHS step}
\DoxyCodeLine{00170 \_\_global\_\_ void BoundaryConditionsAfterRHS(int *interactions) }
\DoxyCodeLine{00171 \{}
\DoxyCodeLine{00172 \#if 1}
\DoxyCodeLine{00173     register int i, inc;}
\DoxyCodeLine{00174     int matId, d, e;}
\DoxyCodeLine{00175     double distance;}
\DoxyCodeLine{00176     double ddistance;}
\DoxyCodeLine{00177     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00178     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{00179             matId = p\_rhs.materialId[i];}
\DoxyCodeLine{00180 }
\DoxyCodeLine{00181             if (matId == EOS\_TYPE\_IGNORE) \{}
\DoxyCodeLine{00182                 p.ax[i] = 0;}
\DoxyCodeLine{00183                 p.ay[i] = 0;}
\DoxyCodeLine{00184                 p.dxdt[i] = 0;}
\DoxyCodeLine{00185                 p.dydt[i] = 0;}
\DoxyCodeLine{00186                 p.vx[i] = 0;}
\DoxyCodeLine{00187                 p.vy[i] = 0;}
\DoxyCodeLine{00188 \#if DIM == 3}
\DoxyCodeLine{00189                 p.az[i] = 0;}
\DoxyCodeLine{00190                 p.dzdt[i] = 0;}
\DoxyCodeLine{00191                 p.vz[i] = 0;}
\DoxyCodeLine{00192 \#endif}
\DoxyCodeLine{00193 \#if SOLID}
\DoxyCodeLine{00194                 for (d = 0; d < DIM*DIM; d++) \{}
\DoxyCodeLine{00195                     p.dSdt[i*DIM*DIM + d] = 0;}
\DoxyCodeLine{00196                 \}}
\DoxyCodeLine{00197 \#endif}
\DoxyCodeLine{00198 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00199                 p.drhodt[i] = 0;}
\DoxyCodeLine{00200 \#endif}
\DoxyCodeLine{00201             \}}
\DoxyCodeLine{00202 }
\DoxyCodeLine{00203 // adding central star with one solar mass}
\DoxyCodeLine{00204 // at (0,0)            }
\DoxyCodeLine{00205 }
\DoxyCodeLine{00206 \#if 0}
\DoxyCodeLine{00207             distance = 0.0;}
\DoxyCodeLine{00208             ddistance = p.x[i]*p.x[i] + p.y[i]*p.y[i];}
\DoxyCodeLine{00209             distance = sqrt(ddistance);}
\DoxyCodeLine{00210             distance *= ddistance;}
\DoxyCodeLine{00211             p.ax[i] -\/= 1.327474512e+20 * p.x[i] / distance;}
\DoxyCodeLine{00212             p.ay[i] -\/= 1.327474512e+20 * p.y[i] / distance;}
\DoxyCodeLine{00213 \#endif}
\DoxyCodeLine{00214             }
\DoxyCodeLine{00215 //            p.az[i] -\/= 9.81;}
\DoxyCodeLine{00216 }
\DoxyCodeLine{00217             /* let's stick to the ground */}
\DoxyCodeLine{00218 }
\DoxyCodeLine{00219 \#if 0}
\DoxyCodeLine{00220             if (p.z[i] <= 1e-\/3) \{}
\DoxyCodeLine{00221                 p.ax[i] = 0;}
\DoxyCodeLine{00222                 p.ay[i] = 0;}
\DoxyCodeLine{00223                 p.dxdt[i] = 0;}
\DoxyCodeLine{00224                 p.dydt[i] = 0;}
\DoxyCodeLine{00225                 p.vx[i] = 0;}
\DoxyCodeLine{00226                 p.vy[i] = 0;}
\DoxyCodeLine{00227 \#if DIM == 3}
\DoxyCodeLine{00228                 p.az[i] = 0;}
\DoxyCodeLine{00229                 p.dzdt[i] = 0;}
\DoxyCodeLine{00230                 p.vz[i] = 0;}
\DoxyCodeLine{00231 \#endif}
\DoxyCodeLine{00232             \}}
\DoxyCodeLine{00233 \#endif}
\DoxyCodeLine{00234 }
\DoxyCodeLine{00235             if (matId == BOUNDARY\_PARTICLE\_ID) \{}
\DoxyCodeLine{00236             p.ax[i] = 0;}
\DoxyCodeLine{00237             p.ay[i] = 0;}
\DoxyCodeLine{00238             p.dxdt[i] = 0;}
\DoxyCodeLine{00239             p.dydt[i] = 0;}
\DoxyCodeLine{00240             p.vx[i] = 0;}
\DoxyCodeLine{00241             p.vy[i] = 0;}
\DoxyCodeLine{00242 \#if DIM == 3}
\DoxyCodeLine{00243             p.az[i] = 0;}
\DoxyCodeLine{00244             p.dzdt[i] = 0;}
\DoxyCodeLine{00245             p.vz[i] = 0;}
\DoxyCodeLine{00246 \#endif}
\DoxyCodeLine{00247 \#if SOLID}
\DoxyCodeLine{00248             for (d = 0; d < DIM*DIM; d++) \{}
\DoxyCodeLine{00249                 p.dSdt[i*DIM*DIM + d] = 0;}
\DoxyCodeLine{00250             \}}
\DoxyCodeLine{00251 \#endif}
\DoxyCodeLine{00252 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00253                 p.drhodt[i] = 0;}
\DoxyCodeLine{00254 \#endif}
\DoxyCodeLine{00255 \#if DENSITY\_FLOOR}
\DoxyCodeLine{00256             \} else if (p.rho[i] < 1e-\/2*density\_floor\_d) \{}
\DoxyCodeLine{00257                 p.rho[i] = 1e-\/2*density\_floor\_d;}
\DoxyCodeLine{00258 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00259                 p.drhodt[i] = 0.0;}
\DoxyCodeLine{00260 \#endif}
\DoxyCodeLine{00261 \#endif}
\DoxyCodeLine{00262             \}}
\DoxyCodeLine{00263     \}}
\DoxyCodeLine{00264 \#endif}
\DoxyCodeLine{00265 \}}
\DoxyCodeLine{00266 }
\DoxyCodeLine{00267 }
\DoxyCodeLine{00268 }
\DoxyCodeLine{00269 }
\DoxyCodeLine{00270 }
\DoxyCodeLine{00271 }
\DoxyCodeLine{00272 \#if GHOST\_BOUNDARIES}
\DoxyCodeLine{00273 \_\_global\_\_ void removeGhostParticles()}
\DoxyCodeLine{00274 \{}
\DoxyCodeLine{00275     //call with only one thread and one block}
\DoxyCodeLine{00276     numParticles = numRealParticles;}
\DoxyCodeLine{00277 \}}
\DoxyCodeLine{00278 }
\DoxyCodeLine{00279 /* set the density, pressure and other quantities for the ghost particles */}
\DoxyCodeLine{00280 \_\_global\_\_ void setQuantitiesGhostParticles() }
\DoxyCodeLine{00281 \{}
\DoxyCodeLine{00282     register int i, inc, k, idx, currentNumParticles;}
\DoxyCodeLine{00283     register int pidx;}
\DoxyCodeLine{00284 \#if SOLID}
\DoxyCodeLine{00285     int a, b;}
\DoxyCodeLine{00286 \#endif}
\DoxyCodeLine{00287     double normalVel;}
\DoxyCodeLine{00288     double x, y;}
\DoxyCodeLine{00289 \#if DIM == 3}
\DoxyCodeLine{00290     double z;}
\DoxyCodeLine{00291 \#endif}
\DoxyCodeLine{00292 }
\DoxyCodeLine{00293 }
\DoxyCodeLine{00294 /* for NO\_SLIP\_BOUNDARY\_TYPE, we stored i}
\DoxyCodeLine{00295    for FREE\_SLIP\_BOUNDARY\_TYPE, we stored -\/i see function insertGhostParticles() below */}
\DoxyCodeLine{00296     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00297     /* loop over all ghost particles */}
\DoxyCodeLine{00298     for (i = numRealParticles + threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i +=inc) \{}
\DoxyCodeLine{00299         /* the index of the corresponding real particle shifted by 1 (since we need the sign) */}
\DoxyCodeLine{00300         idx = p.real\_partner[i];}
\DoxyCodeLine{00301         if (idx < 0) \{}
\DoxyCodeLine{00302             pidx = -\/idx;}
\DoxyCodeLine{00303         \} else \{ }
\DoxyCodeLine{00304             pidx = idx;}
\DoxyCodeLine{00305         \}}
\DoxyCodeLine{00306         pidx -\/= 1;}
\DoxyCodeLine{00307 }
\DoxyCodeLine{00308         //mirror particle}
\DoxyCodeLine{00309         p.cs[i] = p.cs[pidx];}
\DoxyCodeLine{00310         p.p[i] = p.p[pidx];}
\DoxyCodeLine{00311         p.e[i] = p.e[pidx];}
\DoxyCodeLine{00312         p.rho[i] = p.rho[pidx];}
\DoxyCodeLine{00313 \#if SOLID}
\DoxyCodeLine{00314         /* set deviatoric stress tensor depending on boundary type */}
\DoxyCodeLine{00315         if (idx > 0) \{ /* NO\_SLIP\_BOUNDARY */ }
\DoxyCodeLine{00316             for (a = 0; a < DIM; a++) \{}
\DoxyCodeLine{00317                 for (b = 0; b < DIM; b++) \{}
\DoxyCodeLine{00318                     p.S[i*DIM*DIM+a*DIM+b] = p.S[pidx*DIM*DIM+a*DIM+b];}
\DoxyCodeLine{00319                 \}}
\DoxyCodeLine{00320             \}}
\DoxyCodeLine{00321         \} else if (idx < 0) \{ /* FREE\_SLIP\_BOUNDARY */}
\DoxyCodeLine{00322             for (a = 0; a < DIM; a++) \{}
\DoxyCodeLine{00323                 for (b = 0; b < DIM; b++) \{}
\DoxyCodeLine{00324                     p.S[i*DIM*DIM+a*DIM+b] = -\/p.S[pidx*DIM*DIM+a*DIM+b];}
\DoxyCodeLine{00325                 \}}
\DoxyCodeLine{00326                 if (matEOS[p\_rhs.materialId[i]] == EOS\_TYPE\_REGOLITH) \{}
\DoxyCodeLine{00327                     p.S[i*DIM*DIM+a*DIM+a] *= -\/1;}
\DoxyCodeLine{00328                 \}}
\DoxyCodeLine{00329             \}}
\DoxyCodeLine{00330         \} else \{}
\DoxyCodeLine{00331             printf("{}Error, cannot happen. Go away!\(\backslash\)n"{});}
\DoxyCodeLine{00332             assert(false);}
\DoxyCodeLine{00333         \}}
\DoxyCodeLine{00334 \#endif}
\DoxyCodeLine{00335 }
\DoxyCodeLine{00336 }
\DoxyCodeLine{00337     \}}
\DoxyCodeLine{00338 \}}
\DoxyCodeLine{00339 }
\DoxyCodeLine{00340 /* sets the location, mass, sml for the ghost particles */}
\DoxyCodeLine{00341 \_\_global\_\_ void insertGhostParticles()}
\DoxyCodeLine{00342 \{}
\DoxyCodeLine{00343     //call with only one block}
\DoxyCodeLine{00344     int i, inc, k;}
\DoxyCodeLine{00345     volatile int idx;}
\DoxyCodeLine{00346 \#if SOLID}
\DoxyCodeLine{00347     int a, b;}
\DoxyCodeLine{00348 \#endif}
\DoxyCodeLine{00349     double sml;}
\DoxyCodeLine{00350     double distance;}
\DoxyCodeLine{00351     double normalVel;}
\DoxyCodeLine{00352     double x, y;}
\DoxyCodeLine{00353 }
\DoxyCodeLine{00354 \#if DIM == 3}
\DoxyCodeLine{00355     double z;}
\DoxyCodeLine{00356 \#endif}
\DoxyCodeLine{00357     //boundary type: 0 = no slip, 1 = free slip}
\DoxyCodeLine{00358     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00359     for (k = 0; k < numWalls; k++) \{}
\DoxyCodeLine{00360         \_\_syncthreads();}
\DoxyCodeLine{00361         int currentNumParticles = numParticles;}
\DoxyCodeLine{00362         for (i = threadIdx.x + blockIdx.x * blockDim.x; i < currentNumParticles; i += inc) \{}
\DoxyCodeLine{00363             double sml;}
\DoxyCodeLine{00364             sml = p.h[i];}
\DoxyCodeLine{00365 }
\DoxyCodeLine{00366             x = p.x[i];}
\DoxyCodeLine{00367             y = p.y[i];}
\DoxyCodeLine{00368 \#if DIM == 3 }
\DoxyCodeLine{00369             z = p.z[i];}
\DoxyCodeLine{00370 \#endif}
\DoxyCodeLine{00371 }
\DoxyCodeLine{00372 }
\DoxyCodeLine{00373             //get distance to wall}
\DoxyCodeLine{00374             distance = x*nx[k] + y*ny[k]-\/d[k];}
\DoxyCodeLine{00375 \#if DIM == 3}
\DoxyCodeLine{00376             distance += z*nz[k];}
\DoxyCodeLine{00377 \#endif}
\DoxyCodeLine{00378 }
\DoxyCodeLine{00379 }
\DoxyCodeLine{00380             //if distance small enough}
\DoxyCodeLine{00381             if (fabs(distance) <= sml/2.0) \{}
\DoxyCodeLine{00382 }
\DoxyCodeLine{00383                 //atomic read and increment of numParticles}
\DoxyCodeLine{00384                 idx = atomicAdd(\&numParticles, 1);}
\DoxyCodeLine{00385                 assert(idx < maxNumParticles);}
\DoxyCodeLine{00386 }
\DoxyCodeLine{00387 \#if 1 // moved to extra function!}
\DoxyCodeLine{00388                 //mirror particle}
\DoxyCodeLine{00389 \#if (VARIABLE\_SML || INTEGRATE\_SML || DEAL\_WITH\_TOO\_MANY\_INTERACTIONS)}
\DoxyCodeLine{00390                 p.h[idx] = sml;}
\DoxyCodeLine{00391 \#endif}
\DoxyCodeLine{00392                 p.noi[idx] = p.noi[i];}
\DoxyCodeLine{00393                 p.cs[idx] = p.cs[i];}
\DoxyCodeLine{00394                 p.depth[idx] = p.depth[i];}
\DoxyCodeLine{00395                 p.p[idx] = p.p[i];}
\DoxyCodeLine{00396               //  p.e[idx] = p.e[i];}
\DoxyCodeLine{00397                 p\_rhs.materialId[idx] = p\_rhs.materialId[i];}
\DoxyCodeLine{00398 }
\DoxyCodeLine{00399                 p.m[idx] = p.m[i];}
\DoxyCodeLine{00400                 p.rho[idx] = p.rho[i];}
\DoxyCodeLine{00401 \#endif}
\DoxyCodeLine{00402 }
\DoxyCodeLine{00403                 /* set location of ghost particle */}
\DoxyCodeLine{00404                 p.x[idx] = x -\/ 2*distance*nx[k];}
\DoxyCodeLine{00405                 p.y[idx] = y -\/ 2*distance*ny[k];}
\DoxyCodeLine{00406 \#if DIM == 3}
\DoxyCodeLine{00407                 p.z[idx] = z -\/ 2*distance*nz[k];}
\DoxyCodeLine{00408 \#endif}
\DoxyCodeLine{00409                 /* remember the real particle where the ghost particle}
\DoxyCodeLine{00410                    originates from */}
\DoxyCodeLine{00411                 /* for NO\_SLIP\_BOUNDARY\_TYPE, we store i}
\DoxyCodeLine{00412                    for FREE\_SLIP\_BOUNDARY\_TYPE, we store -\/i */}
\DoxyCodeLine{00413 \#if 1}
\DoxyCodeLine{00414                 if (boundaryType[k] == NO\_SLIP\_BOUNDARY\_TYPE) \{}
\DoxyCodeLine{00415                     p.real\_partner[idx] = i+1;}
\DoxyCodeLine{00416                 \} else if (boundaryType[k] == FREE\_SLIP\_BOUNDARY\_TYPE) \{}
\DoxyCodeLine{00417                     p.real\_partner[idx] = -\/i-\/1;}
\DoxyCodeLine{00418                 \} else \{}
\DoxyCodeLine{00419                     printf("{}Error: no such boundary type for particle.\(\backslash\)n"{});}
\DoxyCodeLine{00420                     assert(false);}
\DoxyCodeLine{00421                 \}}
\DoxyCodeLine{00422 \#endif}
\DoxyCodeLine{00423                 /* set mass and material type and sml */}
\DoxyCodeLine{00424                 p.h[idx] = sml;}
\DoxyCodeLine{00425                 p\_rhs.materialId[idx] = p\_rhs.materialId[i];}
\DoxyCodeLine{00426 }
\DoxyCodeLine{00427                 /* all other quantities are set in function setQuantitiesGhostParticles() */}
\DoxyCodeLine{00428                 if (boundaryType[k] == NO\_SLIP\_BOUNDARY\_TYPE) \{}
\DoxyCodeLine{00429                     //free slip boundary}
\DoxyCodeLine{00430                     p.vx[idx] = -\/p.vx[i];}
\DoxyCodeLine{00431 \#if DIM > 1}
\DoxyCodeLine{00432                     p.vy[idx] = -\/p.vy[i];}
\DoxyCodeLine{00433 \#if DIM == 3}
\DoxyCodeLine{00434                     p.vz[idx] = -\/p.vz[i];}
\DoxyCodeLine{00435 \#endif}
\DoxyCodeLine{00436 \#endif}
\DoxyCodeLine{00437 \#if 0}
\DoxyCodeLine{00438 \#if SOLID}
\DoxyCodeLine{00439                     for (a = 0; a < DIM; a++) \{}
\DoxyCodeLine{00440                         for (b = 0; b < DIM; b++) \{}
\DoxyCodeLine{00441                             p.S[idx*DIM*DIM+a*DIM+b] = p.S[i*DIM*DIM+a*DIM+b];}
\DoxyCodeLine{00442                         \}}
\DoxyCodeLine{00443                     \}}
\DoxyCodeLine{00444 \#endif}
\DoxyCodeLine{00445 \#endif}
\DoxyCodeLine{00446 }
\DoxyCodeLine{00447                 \} else if (boundaryType[k] == FREE\_SLIP\_BOUNDARY\_TYPE) \{}
\DoxyCodeLine{00448                     //free slip boundary}
\DoxyCodeLine{00449 }
\DoxyCodeLine{00450                     normalVel = nx[k]*p.vx[i];}
\DoxyCodeLine{00451 \#if DIM > 1}
\DoxyCodeLine{00452                     normalVel += ny[k]*p.vy[i];}
\DoxyCodeLine{00453 \#endif}
\DoxyCodeLine{00454 \#if DIM == 3}
\DoxyCodeLine{00455                     normalVel += nz[k]*p.vz[i];}
\DoxyCodeLine{00456 \#endif}
\DoxyCodeLine{00457 }
\DoxyCodeLine{00458                     p.vx[idx] = p.vx[i] -\/ 2*normalVel*nx[k];}
\DoxyCodeLine{00459 \#if DIM > 1}
\DoxyCodeLine{00460                     p.vy[idx] = p.vy[i] -\/ 2*normalVel*ny[k];}
\DoxyCodeLine{00461 \#if DIM == 3}
\DoxyCodeLine{00462                     p.vz[idx] = p.vz[i] -\/ 2*normalVel*nz[k];}
\DoxyCodeLine{00463 \#endif}
\DoxyCodeLine{00464 \#endif}
\DoxyCodeLine{00465 \#if 0}
\DoxyCodeLine{00466 \#if SOLID}
\DoxyCodeLine{00467                     for (a = 0; a < DIM; a++) \{}
\DoxyCodeLine{00468                         for (b = 0; b < DIM; b++) \{}
\DoxyCodeLine{00469                             p.S[idx*DIM*DIM+a*DIM+b] = -\/p.S[i*DIM*DIM+a*DIM+b];}
\DoxyCodeLine{00470                         \}}
\DoxyCodeLine{00471                         p.S[idx*DIM*DIM+a*DIM+a] *= -\/1;}
\DoxyCodeLine{00472                     \}}
\DoxyCodeLine{00473 \#endif}
\DoxyCodeLine{00474 \#endif}
\DoxyCodeLine{00475                 \}}
\DoxyCodeLine{00476 }
\DoxyCodeLine{00477             \} //end distance if}
\DoxyCodeLine{00478         \} //end particle loop}
\DoxyCodeLine{00479         \_\_syncthreads();}
\DoxyCodeLine{00480     \} //end wall loop}
\DoxyCodeLine{00481     if (threadIdx.x + blockIdx.x*blockDim.x == 0) \{}
\DoxyCodeLine{00482         printf("{}number of particles after inserting: \%d\(\backslash\)t\(\backslash\)t"{}, numParticles);}
\DoxyCodeLine{00483         printf("{}added \%d particles\(\backslash\)n"{}, numParticles -\/ numRealParticles);}
\DoxyCodeLine{00484     \}}
\DoxyCodeLine{00485 \}}
\DoxyCodeLine{00486 \#endif}
\DoxyCodeLine{00487 }
\DoxyCodeLine{00488 }
\DoxyCodeLine{00489 /* this function places the brushes according to their rotation speed */}
\DoxyCodeLine{00490 \_\_global\_\_ void BoundaryConditionsBrushesBefore(int *interactions) }
\DoxyCodeLine{00491 \{}
\DoxyCodeLine{00492 \#if 0}
\DoxyCodeLine{00493 \#warning: brushes on}
\DoxyCodeLine{00494     register int i, inc;}
\DoxyCodeLine{00495     int matId, d, e;}
\DoxyCodeLine{00496     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00497 }
\DoxyCodeLine{00498     // revolutions per minute}
\DoxyCodeLine{00499     const double rpm = 100;}
\DoxyCodeLine{00500     const double omega = rpm * 2 * M\_PI / 60;}
\DoxyCodeLine{00501 }
\DoxyCodeLine{00502     // the offset, this is printed out by brush3D.py}
\DoxyCodeLine{00503     const double yoff = 0.0523512;}
\DoxyCodeLine{00504 }
\DoxyCodeLine{00505     double phi0 = 0;}
\DoxyCodeLine{00506     double phi = 0;}
\DoxyCodeLine{00507     double phit = 0; // no, it's really a p}
\DoxyCodeLine{00508     double r = 0;}
\DoxyCodeLine{00509     double y = 0;}
\DoxyCodeLine{00510     double vz = -\/1e-\/2; // speed of the brushes in z direction }
\DoxyCodeLine{00511     double zoff = 0;}
\DoxyCodeLine{00512     double zoffangle = 0.170125; // the z-\/offset, this is printed out by brush3D.py}
\DoxyCodeLine{00513     double zmax = -\/0.02; ; // = 1/6 brushdiameter from brush3D.py}
\DoxyCodeLine{00514     double myz = 0.0;}
\DoxyCodeLine{00515 }
\DoxyCodeLine{00516     zoff = substep\_currentTimeD * vz;}
\DoxyCodeLine{00517     if (zoff < zmax) }
\DoxyCodeLine{00518         zoff = zmax;}
\DoxyCodeLine{00519 }
\DoxyCodeLine{00520     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{00521             matId = p\_rhs.materialId[i];}
\DoxyCodeLine{00522             if (matId > 1) \{}
\DoxyCodeLine{00523             // new rotating angle}
\DoxyCodeLine{00524                 phi = omega*substep\_currentTimeD;}
\DoxyCodeLine{00525                 // original angle}
\DoxyCodeLine{00526                 // new angle}
\DoxyCodeLine{00527 // brush left (y<0) is matId = 1 and rotates counterclockwise}
\DoxyCodeLine{00528 // brush right (y>0) is matId = 2 and rotates clockwise}
\DoxyCodeLine{00529 // rotation is around x axis}
\DoxyCodeLine{00530                 myz = p.z0[i] -\/ zoffangle;}
\DoxyCodeLine{00531                 if (matId == 2) \{}
\DoxyCodeLine{00532                     y = p.y0[i] + yoff;}
\DoxyCodeLine{00533                     phi0 = atan2(myz,y);}
\DoxyCodeLine{00534                     phit = phi + phi0;}
\DoxyCodeLine{00535                     r = myz * myz + y*y; }
\DoxyCodeLine{00536                     r = sqrt(r);}
\DoxyCodeLine{00537                     p.y[i] = r * cos(phit) -\/ yoff;}
\DoxyCodeLine{00538                     // coordinates }
\DoxyCodeLine{00539                     p.z[i] = r * sin(phit) + zoff + zoffangle;}
\DoxyCodeLine{00540                     p.x[i] = p.x0[i];}
\DoxyCodeLine{00541 }
\DoxyCodeLine{00542                     // velocity}
\DoxyCodeLine{00543                     p.vx[i] = 0.0;}
\DoxyCodeLine{00544                     p.vy[i] = -\/omega * r * sin(phit);}
\DoxyCodeLine{00545                     p.vz[i] = omega * r * cos(phit);}
\DoxyCodeLine{00546 }
\DoxyCodeLine{00547                 \} else if (matId == 3) \{}
\DoxyCodeLine{00548                     y = p.y0[i] -\/ yoff;}
\DoxyCodeLine{00549                     phi0 = atan2(myz,y);}
\DoxyCodeLine{00550                     phit = phi0 -\/ phi;}
\DoxyCodeLine{00551                     r = myz * myz + y*y; }
\DoxyCodeLine{00552                     r = sqrt(r);}
\DoxyCodeLine{00553                     p.y[i] = r * cos(phit) + yoff;}
\DoxyCodeLine{00554                     // coordinates }
\DoxyCodeLine{00555                     p.z[i] = r * sin(phit) + zoff + zoffangle;}
\DoxyCodeLine{00556                     p.x[i] = p.x0[i];}
\DoxyCodeLine{00557 }
\DoxyCodeLine{00558                     // velocity}
\DoxyCodeLine{00559                     p.vx[i] = 0.0;}
\DoxyCodeLine{00560                     p.vy[i] = omega * r * sin(phit);}
\DoxyCodeLine{00561                     p.vz[i] = -\/omega * r * cos(phit);}
\DoxyCodeLine{00562                 \} }
\DoxyCodeLine{00563             \}}
\DoxyCodeLine{00564     \}}
\DoxyCodeLine{00565 \#endif}
\DoxyCodeLine{00566 \}}
\DoxyCodeLine{00567 }
\DoxyCodeLine{00568 }
\DoxyCodeLine{00569 \_\_global\_\_ void BoundaryConditionsBrushesAfter(int *interactions) }
\DoxyCodeLine{00570 \{}
\DoxyCodeLine{00571 \#if 0}
\DoxyCodeLine{00572 \#warning: brushes on}
\DoxyCodeLine{00573     register int i, inc;}
\DoxyCodeLine{00574     int matId, d, e;}
\DoxyCodeLine{00575     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00576     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{00577             matId = p\_rhs.materialId[i];}
\DoxyCodeLine{00578             if (matId > 0) \{}
\DoxyCodeLine{00579                 p.ax[i] = 0;}
\DoxyCodeLine{00580                 p.ay[i] = 0;}
\DoxyCodeLine{00581                 p.dxdt[i] = 0;}
\DoxyCodeLine{00582                 p.dydt[i] = 0;}
\DoxyCodeLine{00583                 p.vx[i] = 0;}
\DoxyCodeLine{00584                 p.vy[i] = 0;}
\DoxyCodeLine{00585                 for (d = 0; d < DIM*DIM; d++) \{}
\DoxyCodeLine{00586                     p.dSdt[i*DIM*DIM + d] = 0;}
\DoxyCodeLine{00587                 \}}
\DoxyCodeLine{00588                 p.drhodt[i] = 0;}
\DoxyCodeLine{00589             \} else \{}
\DoxyCodeLine{00590             \}}
\DoxyCodeLine{00591     \}}
\DoxyCodeLine{00592 \#endif}
\DoxyCodeLine{00593 \}}
\DoxyCodeLine{00594 }
\DoxyCodeLine{00595 }
\DoxyCodeLine{00596 }
\DoxyCodeLine{00597 \_\_global\_\_ void BoundaryForce(int *interactions) }
\DoxyCodeLine{00598 \{}
\DoxyCodeLine{00599 \#if 0}
\DoxyCodeLine{00600 \#warning: brushes on}
\DoxyCodeLine{00601     register int i, inc;}
\DoxyCodeLine{00602     int matId, d, e, matIdj;}
\DoxyCodeLine{00603     int k, j, numInteractions;}
\DoxyCodeLine{00604     double distance;}
\DoxyCodeLine{00605     double ljf = 0;}
\DoxyCodeLine{00606     // D is somehow related to the largest velocity}
\DoxyCodeLine{00607     double D = 10.0;}
\DoxyCodeLine{00608     const double tiny = 1e-\/6;}
\DoxyCodeLine{00609     const double r0 = 0.022574999999999998;}
\DoxyCodeLine{00610     double dx, dy, dz;}
\DoxyCodeLine{00611     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00612     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{00613             matId = p\_rhs.materialId[i];}
\DoxyCodeLine{00614             // only for regolith with matId == 0}
\DoxyCodeLine{00615             if (matId > 0)}
\DoxyCodeLine{00616                 continue;}
\DoxyCodeLine{00617             numInteractions = p.noi[i];}
\DoxyCodeLine{00618             for (k = 0; k < numInteractions; k++) \{}
\DoxyCodeLine{00619             // the interaction partner}
\DoxyCodeLine{00620                 j = interactions[i * MAX\_NUM\_INTERACTIONS + k];}
\DoxyCodeLine{00621 }
\DoxyCodeLine{00622                 // check if interaction partner is boundary\_particle and if not, continue}
\DoxyCodeLine{00623                 matIdj = p\_rhs.materialId[j];}
\DoxyCodeLine{00624                 if (matIdj == BOUNDARY\_PARTICLE\_ID) \{}
\DoxyCodeLine{00625                 // calculate lennard jones force}
\DoxyCodeLine{00626                     dx = p.x[i] -\/ p.x[j];}
\DoxyCodeLine{00627                     dy = p.y[i] -\/ p.y[j];}
\DoxyCodeLine{00628                     dz = 0.0;}
\DoxyCodeLine{00629 \#if DIM > 2}
\DoxyCodeLine{00630                     dz = p.z[i] -\/ p.z[j];}
\DoxyCodeLine{00631 \#endif}
\DoxyCodeLine{00632                     distance = dx*dx + dy*dy + dz*dz;}
\DoxyCodeLine{00633                     distance += tiny;}
\DoxyCodeLine{00634                     distance = sqrt(distance);}
\DoxyCodeLine{00635                     if (r0/distance < 1) \{}
\DoxyCodeLine{00636                         ljf =  D * (pow(r0/distance, 12) -\/ pow(r0/distance, 6)) * pow(distance, -\/2);}
\DoxyCodeLine{00637                         p.ax[i] -\/= ljf*dx;}
\DoxyCodeLine{00638                         p.ay[i] -\/= ljf*dy;}
\DoxyCodeLine{00639 \#if DIM > 2}
\DoxyCodeLine{00640                         p.az[i] -\/= ljf*dz;}
\DoxyCodeLine{00641 \#endif}
\DoxyCodeLine{00642                     \} }
\DoxyCodeLine{00643                 \} }
\DoxyCodeLine{00644 }
\DoxyCodeLine{00645 \#if 0            }
\DoxyCodeLine{00646                 // check if interaction partner is brush and if not, continue}
\DoxyCodeLine{00647                 matIdj = p\_rhs.materialId[j];}
\DoxyCodeLine{00648                 if (matIdj == 1 || matIdj == 2) \{}
\DoxyCodeLine{00649                 // calculate lennard jones force}
\DoxyCodeLine{00650                     dx = p.x[i] -\/ p.x[j];}
\DoxyCodeLine{00651                     dy = p.y[i] -\/ p.y[j];}
\DoxyCodeLine{00652                     dz = p.z[i] -\/ p.z[j];}
\DoxyCodeLine{00653                     distance = dx*dx + dy*dy + dz*dz;}
\DoxyCodeLine{00654                     distance += tiny;}
\DoxyCodeLine{00655                     distance = sqrt(distance);}
\DoxyCodeLine{00656                     if (r0/distance < 1) \{}
\DoxyCodeLine{00657                         ljf = p.m[i] *  D * (pow(r0/distance, 12) -\/ pow(r0/distance, 4)) * pow(distance, -\/2);}
\DoxyCodeLine{00658                         p.ax[i] += ljf*dx;}
\DoxyCodeLine{00659                         p.ay[i] += ljf*dy;}
\DoxyCodeLine{00660                         p.az[i] += ljf*dz;}
\DoxyCodeLine{00661                     \} }
\DoxyCodeLine{00662                 \} }
\DoxyCodeLine{00663 \#endif}
\DoxyCodeLine{00664             \}}
\DoxyCodeLine{00665     \}}
\DoxyCodeLine{00666 \#endif}
\DoxyCodeLine{00667 \}}

\end{DoxyCode}
