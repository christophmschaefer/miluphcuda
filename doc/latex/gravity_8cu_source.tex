\hypertarget{gravity_8cu_source}{}\doxysection{gravity.\+cu}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 /**}
\DoxyCodeLine{00002  * @author      Christoph Schaefer cm.schaefer@gmail.com and Thomas I. Maindl}
\DoxyCodeLine{00003  *}
\DoxyCodeLine{00004  * @section     LICENSE}
\DoxyCodeLine{00005  * Copyright (c) 2019 Christoph Schaefer}
\DoxyCodeLine{00006  *}
\DoxyCodeLine{00007  * This file is part of miluphcuda.}
\DoxyCodeLine{00008  *}
\DoxyCodeLine{00009  * miluphcuda is free software: you can redistribute it and/or modify}
\DoxyCodeLine{00010  * it under the terms of the GNU General Public License as published by}
\DoxyCodeLine{00011  * the Free Software Foundation, either version 3 of the License, or}
\DoxyCodeLine{00012  * (at your option) any later version.}
\DoxyCodeLine{00013  *}
\DoxyCodeLine{00014  * miluphcuda is distributed in the hope that it will be useful,}
\DoxyCodeLine{00015  * but WITHOUT ANY WARRANTY; without even the implied warranty of}
\DoxyCodeLine{00016  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
\DoxyCodeLine{00017  * GNU General Public License for more details.}
\DoxyCodeLine{00018  *}
\DoxyCodeLine{00019  * You should have received a copy of the GNU General Public License}
\DoxyCodeLine{00020  * along with miluphcuda.  If not, see <http://www.gnu.org/licenses/>.}
\DoxyCodeLine{00021  *}
\DoxyCodeLine{00022  */}
\DoxyCodeLine{00023 }
\DoxyCodeLine{00024 \#include "{}gravity.h"{}}
\DoxyCodeLine{00025 \#include "{}tree.h"{}}
\DoxyCodeLine{00026 \#include "{}timeintegration.h"{}}
\DoxyCodeLine{00027 \#include "{}parameter.h"{}}
\DoxyCodeLine{00028 \#include "{}miluph.h"{}}
\DoxyCodeLine{00029 \#include "{}pressure.h"{}}
\DoxyCodeLine{00030 }
\DoxyCodeLine{00031 extern \_\_device\_\_ volatile double radius;}
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033 }
\DoxyCodeLine{00034 // add acceleration due to gravity to particle acceleration}
\DoxyCodeLine{00035 \_\_global\_\_ void addoldselfgravity() }
\DoxyCodeLine{00036 \{}
\DoxyCodeLine{00037         int i;}
\DoxyCodeLine{00038 }
\DoxyCodeLine{00039         for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += blockDim.x * gridDim.x) \{}
\DoxyCodeLine{00040         p.ax[i] += p.g\_ax[i];}
\DoxyCodeLine{00041 \#if DIM > 1}
\DoxyCodeLine{00042         p.ay[i] += p.g\_ay[i];}
\DoxyCodeLine{00043 \#if DIM > 2}
\DoxyCodeLine{00044         p.az[i] += p.g\_az[i];}
\DoxyCodeLine{00045 \#endif}
\DoxyCodeLine{00046 \#endif}
\DoxyCodeLine{00047     \}}
\DoxyCodeLine{00048 \}}
\DoxyCodeLine{00049 }
\DoxyCodeLine{00050 }
\DoxyCodeLine{00051 // adds the acceleration due to the point masses }
\DoxyCodeLine{00052 \_\_global\_\_ void gravitation\_from\_point\_masses()}
\DoxyCodeLine{00053 \{}
\DoxyCodeLine{00054     int i, inc;}
\DoxyCodeLine{00055     int j;}
\DoxyCodeLine{00056     int d;}
\DoxyCodeLine{00057     double r;}
\DoxyCodeLine{00058     double rrr;}
\DoxyCodeLine{00059     double dr[DIM];}
\DoxyCodeLine{00060     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00061     // loop for point masses}
\DoxyCodeLine{00062     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numPointmasses; i += inc) \{}
\DoxyCodeLine{00063         for (j = 0; j < numPointmasses; j++) \{}
\DoxyCodeLine{00064             if (i == j) continue;}
\DoxyCodeLine{00065             r = 0.0;}
\DoxyCodeLine{00066             dr[0] = pointmass.x[j] -\/ pointmass.x[i];}
\DoxyCodeLine{00067 \#if DIM > 1}
\DoxyCodeLine{00068             dr[1] = pointmass.y[j] -\/ pointmass.y[i];}
\DoxyCodeLine{00069 \#if DIM > 2}
\DoxyCodeLine{00070             dr[2] = pointmass.z[j] -\/ pointmass.z[i];}
\DoxyCodeLine{00071 \#endif}
\DoxyCodeLine{00072 \#endif}
\DoxyCodeLine{00073             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00074                 r += dr[d]*dr[d];}
\DoxyCodeLine{00075             \}}
\DoxyCodeLine{00076             r = sqrt(r);}
\DoxyCodeLine{00077             rrr = r*r*r;}
\DoxyCodeLine{00078             pointmass.ax[i] += C\_GRAVITY\_SI * pointmass.m[j] * dr[0]/(rrr);}
\DoxyCodeLine{00079 \#if DIM > 1}
\DoxyCodeLine{00080             pointmass.ay[i] += C\_GRAVITY\_SI * pointmass.m[j] * dr[1]/(rrr);}
\DoxyCodeLine{00081 \#if DIM > 2}
\DoxyCodeLine{00082             pointmass.az[i] += C\_GRAVITY\_SI * pointmass.m[j] * dr[2]/(rrr);}
\DoxyCodeLine{00083 \#endif}
\DoxyCodeLine{00084 \#endif}
\DoxyCodeLine{00085         \}}
\DoxyCodeLine{00086     \}}
\DoxyCodeLine{00087 }
\DoxyCodeLine{00088 }
\DoxyCodeLine{00089     // loop over all particles}
\DoxyCodeLine{00090     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numRealParticles; i += inc) \{}
\DoxyCodeLine{00091         if (p\_rhs.materialId[i] == EOS\_TYPE\_IGNORE || matEOS[p\_rhs.materialId[i]] == EOS\_TYPE\_IGNORE) \{}
\DoxyCodeLine{00092             continue;}
\DoxyCodeLine{00093         \}}
\DoxyCodeLine{00094 }
\DoxyCodeLine{00095         for (j = 0; j < numPointmasses; j++) \{}
\DoxyCodeLine{00096             r = 0.0;}
\DoxyCodeLine{00097             dr[0] = pointmass.x[j] -\/ p.x[i];}
\DoxyCodeLine{00098 \#if DIM > 1}
\DoxyCodeLine{00099             dr[1] = pointmass.y[j] -\/ p.y[i];}
\DoxyCodeLine{00100 \#if DIM > 2}
\DoxyCodeLine{00101             dr[2] = pointmass.z[j] -\/ p.z[i];}
\DoxyCodeLine{00102 \#endif}
\DoxyCodeLine{00103 \#endif}
\DoxyCodeLine{00104             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00105                 r += dr[d]*dr[d];}
\DoxyCodeLine{00106             \}}
\DoxyCodeLine{00107             r = sqrt(r);}
\DoxyCodeLine{00108             rrr = r*r*r;}
\DoxyCodeLine{00109             if (r < pointmass.rmax[j] \&\& r > pointmass.rmin[j]) \{}
\DoxyCodeLine{00110                 p.ax[i] += C\_GRAVITY\_SI * pointmass.m[j] * dr[0]/(rrr);}
\DoxyCodeLine{00111 \#if DIM > 1}
\DoxyCodeLine{00112                 p.ay[i] += C\_GRAVITY\_SI * pointmass.m[j] * dr[1]/(rrr);}
\DoxyCodeLine{00113 \#if DIM > 2}
\DoxyCodeLine{00114                 p.az[i] += C\_GRAVITY\_SI * pointmass.m[j] * dr[2]/(rrr);}
\DoxyCodeLine{00115 \#endif}
\DoxyCodeLine{00116 \#endif}
\DoxyCodeLine{00117             \} else \{}
\DoxyCodeLine{00118                 p\_rhs.materialId[i] = EOS\_TYPE\_IGNORE;}
\DoxyCodeLine{00119             \}}
\DoxyCodeLine{00120         \}}
\DoxyCodeLine{00121     \}}
\DoxyCodeLine{00122 \}}
\DoxyCodeLine{00123 }
\DoxyCodeLine{00124 // compute self gravity using N**2 algorithm}
\DoxyCodeLine{00125 \_\_global\_\_ void direct\_selfgravity() }
\DoxyCodeLine{00126 \{}
\DoxyCodeLine{00127     int i, inc;}
\DoxyCodeLine{00128     int j;}
\DoxyCodeLine{00129     int d;}
\DoxyCodeLine{00130     double a\_grav[DIM];}
\DoxyCodeLine{00131     double dist;}
\DoxyCodeLine{00132     double f;}
\DoxyCodeLine{00133     double dx[DIM];}
\DoxyCodeLine{00134     double sml;}
\DoxyCodeLine{00135 }
\DoxyCodeLine{00136     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00137     // loop over all particles}
\DoxyCodeLine{00138     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numRealParticles; i += inc) \{}
\DoxyCodeLine{00139         for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00140             a\_grav[d] = 0.0;}
\DoxyCodeLine{00141         \}}
\DoxyCodeLine{00142         sml = p.h[i];}
\DoxyCodeLine{00143         if (p\_rhs.materialId[i] == EOS\_TYPE\_IGNORE || matEOS[p\_rhs.materialId[i]] == EOS\_TYPE\_IGNORE) \{}
\DoxyCodeLine{00144             continue;}
\DoxyCodeLine{00145         \}}
\DoxyCodeLine{00146 }
\DoxyCodeLine{00147         // loop over all other particles}
\DoxyCodeLine{00148         for (j = 0; j < numRealParticles; j++) \{}
\DoxyCodeLine{00149             if (i == j)}
\DoxyCodeLine{00150                 continue;}
\DoxyCodeLine{00151 }
\DoxyCodeLine{00152             dist = 0.0;}
\DoxyCodeLine{00153             dx[0] = p.x[i] -\/ p.x[j];}
\DoxyCodeLine{00154 \#if DIM > 1}
\DoxyCodeLine{00155             dx[1] = p.y[i] -\/ p.y[j];}
\DoxyCodeLine{00156 \#if DIM > 2}
\DoxyCodeLine{00157             dx[2] = p.z[i] -\/ p.z[j];}
\DoxyCodeLine{00158 \#endif}
\DoxyCodeLine{00159 \#endif}
\DoxyCodeLine{00160             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00161                 dist += dx[d]*dx[d];}
\DoxyCodeLine{00162             \}}
\DoxyCodeLine{00163             dist = sqrt(dist);}
\DoxyCodeLine{00164                     f = C\_GRAVITY\_SI * p.m[j]; // / (distance*distance*distance);}
\DoxyCodeLine{00165                     f /= dist > sml ? (dist*dist*dist) : (sml*sml*sml);}
\DoxyCodeLine{00166             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00167                 a\_grav[d] -\/= f*dx[d];}
\DoxyCodeLine{00168             \}}
\DoxyCodeLine{00169         \}}
\DoxyCodeLine{00170 }
\DoxyCodeLine{00171                 p.ax[i] += a\_grav[0];}
\DoxyCodeLine{00172                 p.g\_ax[i] = a\_grav[0];}
\DoxyCodeLine{00173 \#if DIM > 1}
\DoxyCodeLine{00174                 p.ay[i] += a\_grav[1];}
\DoxyCodeLine{00175                 p.g\_ay[i] = a\_grav[1];}
\DoxyCodeLine{00176 \#if DIM == 3}
\DoxyCodeLine{00177                 p.az[i] += a\_grav[2];}
\DoxyCodeLine{00178                 p.g\_az[i] = a\_grav[2];}
\DoxyCodeLine{00179 \#endif}
\DoxyCodeLine{00180 \#endif}
\DoxyCodeLine{00181 }
\DoxyCodeLine{00182     \}}
\DoxyCodeLine{00183 \}}
\DoxyCodeLine{00184 }
\DoxyCodeLine{00185 // compute self gravity using the tree}
\DoxyCodeLine{00186 \_\_global\_\_ void selfgravity() }
\DoxyCodeLine{00187 \{}
\DoxyCodeLine{00188         int i, child, nodeIndex, childNumber, depth;}
\DoxyCodeLine{00189         double px, ax, dx, f, distance;}
\DoxyCodeLine{00190 \#if DIM > 1}
\DoxyCodeLine{00191     double py, ay, dy;}
\DoxyCodeLine{00192 \#endif}
\DoxyCodeLine{00193         int currentNodeIndex[MAXDEPTH];}
\DoxyCodeLine{00194         int currentChildNumber[MAXDEPTH];}
\DoxyCodeLine{00195 \#if DIM == 3}
\DoxyCodeLine{00196         double pz, az, dz;}
\DoxyCodeLine{00197 \#endif}
\DoxyCodeLine{00198         double sml;}
\DoxyCodeLine{00199     double thetasq = theta*theta;}
\DoxyCodeLine{00200 }
\DoxyCodeLine{00201         \_\_shared\_\_ volatile double cellsize[MAXDEPTH];}
\DoxyCodeLine{00202         if (0 == threadIdx.x) \{}
\DoxyCodeLine{00203                 cellsize[0] = 4.0 * radius * radius;}
\DoxyCodeLine{00204                 for (i = 1; i < MAXDEPTH; i++) \{}
\DoxyCodeLine{00205                         cellsize[i] = cellsize[i -\/ 1] * 0.25;}
\DoxyCodeLine{00206                 \}}
\DoxyCodeLine{00207         \}}
\DoxyCodeLine{00208 }
\DoxyCodeLine{00209         \_\_syncthreads();}
\DoxyCodeLine{00210 }
\DoxyCodeLine{00211         for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += blockDim.x * gridDim.x) \{}
\DoxyCodeLine{00212                 px = p.x[i];}
\DoxyCodeLine{00213 \#if DIM > 1}
\DoxyCodeLine{00214                 py = p.y[i];}
\DoxyCodeLine{00215 \#if DIM == 3}
\DoxyCodeLine{00216                 pz = p.z[i];}
\DoxyCodeLine{00217 \#endif}
\DoxyCodeLine{00218 \#endif}
\DoxyCodeLine{00219         p.g\_ax[i] = 0.0;}
\DoxyCodeLine{00220 \#if DIM > 1}
\DoxyCodeLine{00221         p.g\_ay[i] = 0.0;}
\DoxyCodeLine{00222 \#endif}
\DoxyCodeLine{00223         sml = p.h[i];}
\DoxyCodeLine{00224                 ax = 0.0;}
\DoxyCodeLine{00225 \#if DIM > 1}
\DoxyCodeLine{00226                 ay = 0.0;}
\DoxyCodeLine{00227 \#if DIM == 3}
\DoxyCodeLine{00228                 az = 0.0;}
\DoxyCodeLine{00229         p.g\_az[i] = 0.0;}
\DoxyCodeLine{00230 \#endif}
\DoxyCodeLine{00231 \#endif}
\DoxyCodeLine{00232 }
\DoxyCodeLine{00233                 // start at root}
\DoxyCodeLine{00234                 depth = 1;}
\DoxyCodeLine{00235                 currentNodeIndex[depth] = numNodes -\/ 1;}
\DoxyCodeLine{00236                 currentChildNumber[depth] = 0;}
\DoxyCodeLine{00237 }
\DoxyCodeLine{00238                 do \{}
\DoxyCodeLine{00239                         childNumber = currentChildNumber[depth];}
\DoxyCodeLine{00240                         nodeIndex = currentNodeIndex[depth];}
\DoxyCodeLine{00241 }
\DoxyCodeLine{00242                         while(childNumber < numChildren) \{}
\DoxyCodeLine{00243                                 do \{}
\DoxyCodeLine{00244                                         child = childList[childListIndex(nodeIndex, childNumber)];}
\DoxyCodeLine{00245                                         childNumber++;}
\DoxyCodeLine{00246                                 \} while(child == EMPTY \&\& childNumber < numChildren);}
\DoxyCodeLine{00247                                 if (child != EMPTY \&\& child != i) \{ // dont do selfgravity with yourself!}
\DoxyCodeLine{00248                                         dx = p.x[child] -\/ px;}
\DoxyCodeLine{00249                                         distance = dx*dx;}
\DoxyCodeLine{00250 \#if DIM > 1}
\DoxyCodeLine{00251                                         dy = p.y[child] -\/ py;}
\DoxyCodeLine{00252                                         distance += dy*dy;}
\DoxyCodeLine{00253 \#endif}
\DoxyCodeLine{00254 \#if DIM == 3}
\DoxyCodeLine{00255                                         dz = p.z[child] -\/ pz;}
\DoxyCodeLine{00256                                         distance += dz*dz;}
\DoxyCodeLine{00257 \#endif}
\DoxyCodeLine{00258                                         // if child is leaf or far away}
\DoxyCodeLine{00259                                         //if (child < numParticles || distance * theta > cellsize[depth]) \{}
\DoxyCodeLine{00260                                         if (child < numParticles || distance * thetasq > cellsize[depth]) \{}
\DoxyCodeLine{00261                                                 distance = sqrt(distance);}
\DoxyCodeLine{00262                         //distance += 1e10;}
\DoxyCodeLine{00263                                                 f = C\_GRAVITY\_SI * p.m[child]; // / (distance*distance*distance);}
\DoxyCodeLine{00264                                                 f /= distance > sml ? (distance*distance*distance) : (sml*sml*sml);}
\DoxyCodeLine{00265            //             f = 0.0;}
\DoxyCodeLine{00266                                                 ax += f*dx;}
\DoxyCodeLine{00267 \#if DIM > 1}
\DoxyCodeLine{00268                                                 ay += f*dy;}
\DoxyCodeLine{00269 \#if DIM == 3}
\DoxyCodeLine{00270                                                 az += f*dz;}
\DoxyCodeLine{00271 \#endif}
\DoxyCodeLine{00272 \#endif}
\DoxyCodeLine{00273                                         \} else \{}
\DoxyCodeLine{00274                                                 // put child on stack}
\DoxyCodeLine{00275                                                 currentChildNumber[depth] = childNumber;}
\DoxyCodeLine{00276                                                 currentNodeIndex[depth] = nodeIndex;}
\DoxyCodeLine{00277                                                 depth++;}
\DoxyCodeLine{00278                         if (depth == MAXDEPTH) \{}
\DoxyCodeLine{00279                             printf("{}\(\backslash\)n\(\backslash\)nMAXDEPTH reached in selfgravity... this is not good.\(\backslash\)n\(\backslash\)n"{});}
\DoxyCodeLine{00280                             assert(depth < MAXDEPTH);}
\DoxyCodeLine{00281                         \}}
\DoxyCodeLine{00282                                                 childNumber = 0;}
\DoxyCodeLine{00283                                                 nodeIndex = child;}
\DoxyCodeLine{00284                                         \}}
\DoxyCodeLine{00285                                 \}}
\DoxyCodeLine{00286                         \}}
\DoxyCodeLine{00287                         depth-\/-\/;}
\DoxyCodeLine{00288                 \} while(depth > 0);}
\DoxyCodeLine{00289 }
\DoxyCodeLine{00290 }
\DoxyCodeLine{00291 }
\DoxyCodeLine{00292                 p.ax[i] += ax;}
\DoxyCodeLine{00293                 p.g\_ax[i] = ax;}
\DoxyCodeLine{00294 \#if DIM > 1}
\DoxyCodeLine{00295                 p.ay[i] += ay;}
\DoxyCodeLine{00296                 p.g\_ay[i] = ay;}
\DoxyCodeLine{00297 \#if DIM == 3}
\DoxyCodeLine{00298                 p.az[i] += az;}
\DoxyCodeLine{00299                 p.g\_az[i] = az;}
\DoxyCodeLine{00300 \#endif}
\DoxyCodeLine{00301 \#endif}
\DoxyCodeLine{00302         \}}
\DoxyCodeLine{00303 \}}
\DoxyCodeLine{00304 }
\DoxyCodeLine{00305 }
\DoxyCodeLine{00306 }
\DoxyCodeLine{00307 }
\DoxyCodeLine{00308 }
\DoxyCodeLine{00309 }

\end{DoxyCode}
