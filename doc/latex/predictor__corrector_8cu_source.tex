\hypertarget{predictor__corrector_8cu_source}{}\doxysection{predictor\+\_\+corrector.\+cu}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 /**}
\DoxyCodeLine{00002  * @author      Christoph Schaefer cm.schaefer@gmail.com}
\DoxyCodeLine{00003  *}
\DoxyCodeLine{00004  * @section     LICENSE}
\DoxyCodeLine{00005  * Copyright (c) 2019 Christoph Schaefer}
\DoxyCodeLine{00006  *}
\DoxyCodeLine{00007  * This file is part of miluphcuda.}
\DoxyCodeLine{00008  *}
\DoxyCodeLine{00009  * miluphcuda is free software: you can redistribute it and/or modify}
\DoxyCodeLine{00010  * it under the terms of the GNU General Public License as published by}
\DoxyCodeLine{00011  * the Free Software Foundation, either version 3 of the License, or}
\DoxyCodeLine{00012  * (at your option) any later version.}
\DoxyCodeLine{00013  *}
\DoxyCodeLine{00014  * miluphcuda is distributed in the hope that it will be useful,}
\DoxyCodeLine{00015  * but WITHOUT ANY WARRANTY; without even the implied warranty of}
\DoxyCodeLine{00016  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
\DoxyCodeLine{00017  * GNU General Public License for more details.}
\DoxyCodeLine{00018  *}
\DoxyCodeLine{00019  * You should have received a copy of the GNU General Public License}
\DoxyCodeLine{00020  * along with miluphcuda.  If not, see <http://www.gnu.org/licenses/>.}
\DoxyCodeLine{00021  *}
\DoxyCodeLine{00022  */}
\DoxyCodeLine{00023 }
\DoxyCodeLine{00024 }
\DoxyCodeLine{00025 }
\DoxyCodeLine{00026 \#include "{}predictor\_corrector\_euler.h"{}}
\DoxyCodeLine{00027 \#include "{}timeintegration.h"{}}
\DoxyCodeLine{00028 \#include "{}parameter.h"{}}
\DoxyCodeLine{00029 \#include "{}memory\_handling.h"{}}
\DoxyCodeLine{00030 \#include "{}miluph.h"{}}
\DoxyCodeLine{00031 \#include "{}pressure.h"{}}
\DoxyCodeLine{00032 \#include "{}rhs.h"{}}
\DoxyCodeLine{00033 \#include <float.h>}
\DoxyCodeLine{00034 }
\DoxyCodeLine{00035 /* predictor corrector scheme with an initial step of dt/2 and the corrector step with dt */}
\DoxyCodeLine{00036 }
\DoxyCodeLine{00037 }
\DoxyCodeLine{00038 extern \_\_device\_\_ double endTimeD, currentTimeD;}
\DoxyCodeLine{00039 extern \_\_device\_\_ double substep\_currentTimeD;}
\DoxyCodeLine{00040 extern \_\_device\_\_ double dt;}
\DoxyCodeLine{00041 extern \_\_device\_\_ int blockCount;}
\DoxyCodeLine{00042 extern \_\_device\_\_ double emin\_d;}
\DoxyCodeLine{00043 extern \_\_device\_\_ double Smin\_d;}
\DoxyCodeLine{00044 extern \_\_device\_\_ double rhomin\_d;}
\DoxyCodeLine{00045 extern \_\_device\_\_ double damagemin\_d;}
\DoxyCodeLine{00046 extern \_\_device\_\_ double alphamin\_d;}
\DoxyCodeLine{00047 extern \_\_device\_\_ double betamin\_d;}
\DoxyCodeLine{00048 extern \_\_device\_\_ double alpha\_epspormin\_d;}
\DoxyCodeLine{00049 extern \_\_device\_\_ double epsilon\_vmin\_d;}
\DoxyCodeLine{00050 extern \_\_device\_\_ int pressureChangeSmallEnough;}
\DoxyCodeLine{00051 extern \_\_device\_\_ double maxpressureDiff;}
\DoxyCodeLine{00052 }
\DoxyCodeLine{00053 }
\DoxyCodeLine{00054 extern double L\_ini;}
\DoxyCodeLine{00055 }
\DoxyCodeLine{00056 }
\DoxyCodeLine{00057 \_\_global\_\_ void CorrectorStep()}
\DoxyCodeLine{00058 \{}
\DoxyCodeLine{00059     register int i;}
\DoxyCodeLine{00060 \#if SOLID}
\DoxyCodeLine{00061     register int j;}
\DoxyCodeLine{00062     register int k;}
\DoxyCodeLine{00063 \#endif}
\DoxyCodeLine{00064 }
\DoxyCodeLine{00065 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00066     // pointmass loop}
\DoxyCodeLine{00067     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numPointmasses; i+= blockDim.x * gridDim.x) \{}
\DoxyCodeLine{00068         pointmass.x[i] = pointmass.x[i] + dt * predictor\_pointmass.vx[i];}
\DoxyCodeLine{00069 \#if DIM > 1}
\DoxyCodeLine{00070         pointmass.y[i] = pointmass.y[i] + dt * predictor\_pointmass.vy[i];}
\DoxyCodeLine{00071         pointmass.vy[i] = pointmass.vy[i] + dt * predictor\_pointmass.ay[i];}
\DoxyCodeLine{00072         pointmass.ay[i] = predictor\_pointmass.ay[i];}
\DoxyCodeLine{00073 \#endif}
\DoxyCodeLine{00074         pointmass.vx[i] = pointmass.vx[i] + dt * predictor\_pointmass.ax[i];}
\DoxyCodeLine{00075         pointmass.ax[i] = predictor\_pointmass.ax[i];}
\DoxyCodeLine{00076 \#if DIM == 3}
\DoxyCodeLine{00077         pointmass.z[i] = pointmass.z[i] + dt * predictor\_pointmass.vz[i];}
\DoxyCodeLine{00078         pointmass.vz[i] = pointmass.vz[i] + dt * predictor\_pointmass.az[i];}
\DoxyCodeLine{00079         pointmass.az[i] = predictor\_pointmass.az[i];}
\DoxyCodeLine{00080 \#endif}
\DoxyCodeLine{00081     \}}
\DoxyCodeLine{00082 \#endif // GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00083 }
\DoxyCodeLine{00084     // particle loop}
\DoxyCodeLine{00085     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i+= blockDim.x * gridDim.x) \{}
\DoxyCodeLine{00086         p.x[i] = p.x[i] + dt * predictor.dxdt[i];}
\DoxyCodeLine{00087 \#if DIM > 1}
\DoxyCodeLine{00088         p.y[i] = p.y[i] + dt * predictor.dydt[i];}
\DoxyCodeLine{00089         p.vy[i] = p.vy[i] + dt * predictor.ay[i];}
\DoxyCodeLine{00090         p.ay[i] = predictor.ay[i];}
\DoxyCodeLine{00091 \#endif}
\DoxyCodeLine{00092         p.vx[i] = p.vx[i] + dt * predictor.ax[i];}
\DoxyCodeLine{00093         p.ax[i] = predictor.ax[i];}
\DoxyCodeLine{00094 \#if DIM == 3}
\DoxyCodeLine{00095         p.z[i] = p.z[i] + dt * predictor.dzdt[i];}
\DoxyCodeLine{00096         p.vz[i] = p.vz[i] + dt * predictor.az[i];}
\DoxyCodeLine{00097         p.az[i] = predictor.az[i];}
\DoxyCodeLine{00098 \#endif}
\DoxyCodeLine{00099 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00100         p.rho[i] = p.rho[i] + dt * predictor.drhodt[i];}
\DoxyCodeLine{00101         p.drhodt[i] = predictor.drhodt[i];}
\DoxyCodeLine{00102 \#else}
\DoxyCodeLine{00103         p.rho[i] = p.rho[i];}
\DoxyCodeLine{00104 \#endif}
\DoxyCodeLine{00105 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00106         p.e[i] = p.e[i] + dt * predictor.dedt[i];}
\DoxyCodeLine{00107         p.dedt[i] = predictor.dedt[i];}
\DoxyCodeLine{00108 \#endif}
\DoxyCodeLine{00109 \#if FRAGMENTATION}
\DoxyCodeLine{00110         p.d[i] = p.d[i] + dt * predictor.dddt[i];}
\DoxyCodeLine{00111         p.dddt[i] = predictor.dddt[i];}
\DoxyCodeLine{00112 \#endif}
\DoxyCodeLine{00113 \#if INTEGRATE\_SML}
\DoxyCodeLine{00114         p.h[i] = p.h[i] + dt * predictor.dhdt[i];}
\DoxyCodeLine{00115         p.dhdt[i] = predictor.dhdt[i];}
\DoxyCodeLine{00116 \#else}
\DoxyCodeLine{00117         p.h[i] = predictor.h[i];}
\DoxyCodeLine{00118 \#endif}
\DoxyCodeLine{00119 \#if JC\_PLASTICITY}
\DoxyCodeLine{00120         p.ep[i] = p.ep[i] + dt * predictor.edotp[i];}
\DoxyCodeLine{00121         p.edotp[i] = predictor.edotp[i];}
\DoxyCodeLine{00122         p.T[i] = p.T[i] + dt * predictor.dTdt[i];}
\DoxyCodeLine{00123         p.dTdt[i] = predictor.dTdt[i];}
\DoxyCodeLine{00124 \#endif}
\DoxyCodeLine{00125 \#if SIRONO\_POROSITY}
\DoxyCodeLine{00126         p.rho\_0prime[i] = p.rho\_0prime[i];}
\DoxyCodeLine{00127         p.rho\_c\_plus[i] = p.rho\_c\_plus[i];}
\DoxyCodeLine{00128         p.rho\_c\_minus[i] = p.rho\_c\_minus[i];}
\DoxyCodeLine{00129         p.compressive\_strength[i] = p.compressive\_strength[i];}
\DoxyCodeLine{00130         p.tensile\_strength[i] = p.tensile\_strength[i];}
\DoxyCodeLine{00131         p.shear\_strength[i] = p.shear\_strength[i];}
\DoxyCodeLine{00132         p.K[i] = p.K[i];}
\DoxyCodeLine{00133         p.flag\_rho\_0prime[i] = p.flag\_rho\_0prime[i];}
\DoxyCodeLine{00134         p.flag\_plastic[i] = p.flag\_plastic[i];}
\DoxyCodeLine{00135 \#endif}
\DoxyCodeLine{00136 \#if EPSALPHA\_POROSITY}
\DoxyCodeLine{00137         p.alpha\_epspor[i] = p.alpha\_epspor[i] + dt * predictor.dalpha\_epspordt[i];}
\DoxyCodeLine{00138         p.epsilon\_v[i] = p.epsilon\_v[i] + dt * predictor.depsilon\_vdt[i];}
\DoxyCodeLine{00139         p.dalpha\_epspordt[i] = predictor.dalpha\_epspordt[i];}
\DoxyCodeLine{00140         p.depsilon\_vdt[i] = predictor.depsilon\_vdt[i];}
\DoxyCodeLine{00141 \#endif}
\DoxyCodeLine{00142 \#if INVISCID\_SPH}
\DoxyCodeLine{00143         p.beta[i] = p.beta[i] + dt * predictor.dbetadt[i];}
\DoxyCodeLine{00144         p.dbetadt[i] = predictor.dbetadt[i];}
\DoxyCodeLine{00145 \#endif}
\DoxyCodeLine{00146 \#if SOLID}
\DoxyCodeLine{00147         for (j = 0; j < DIM; j++) \{}
\DoxyCodeLine{00148             for (k = 0; k < DIM; k++) \{}
\DoxyCodeLine{00149                 p.S[stressIndex(i,j,k)] = p.S[stressIndex(i,j,k)] + dt  * predictor.dSdt[stressIndex(i,j,k)];}
\DoxyCodeLine{00150                 p.dSdt[stressIndex(i,j,k)] = predictor.dSdt[stressIndex(i,j,k)];}
\DoxyCodeLine{00151             \}}
\DoxyCodeLine{00152         \}}
\DoxyCodeLine{00153 \#endif}
\DoxyCodeLine{00154     \}}
\DoxyCodeLine{00155 \}}
\DoxyCodeLine{00156 }
\DoxyCodeLine{00157 \_\_global\_\_ void PredictorStep()}
\DoxyCodeLine{00158 \{}
\DoxyCodeLine{00159     register int i;}
\DoxyCodeLine{00160 \#if SOLID}
\DoxyCodeLine{00161     register int j;}
\DoxyCodeLine{00162     register int k;}
\DoxyCodeLine{00163 \#endif}
\DoxyCodeLine{00164 }
\DoxyCodeLine{00165 }
\DoxyCodeLine{00166 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00167     // pointmass loop}
\DoxyCodeLine{00168     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numPointmasses; i+= blockDim.x * gridDim.x) \{}
\DoxyCodeLine{00169         predictor\_pointmass.x[i] = pointmass.x[i] + dt/2 * pointmass.vx[i];}
\DoxyCodeLine{00170         predictor\_pointmass.vx[i] = pointmass.vx[i] + dt/2 * pointmass.ax[i];}
\DoxyCodeLine{00171 }
\DoxyCodeLine{00172 \#if DIM > 1}
\DoxyCodeLine{00173         predictor\_pointmass.y[i] = pointmass.y[i] + dt/2 * pointmass.vy[i];}
\DoxyCodeLine{00174         predictor\_pointmass.vy[i] = pointmass.vy[i] + dt/2 * pointmass.ay[i];}
\DoxyCodeLine{00175 \#endif}
\DoxyCodeLine{00176 \#if DIM > 2}
\DoxyCodeLine{00177         predictor\_pointmass.z[i] = pointmass.z[i] + dt/2 * pointmass.vz[i];}
\DoxyCodeLine{00178         predictor\_pointmass.vz[i] = pointmass.vz[i] + dt/2 * pointmass.az[i];}
\DoxyCodeLine{00179 \#endif}
\DoxyCodeLine{00180     \}}
\DoxyCodeLine{00181 \#endif // GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00182 }
\DoxyCodeLine{00183 }
\DoxyCodeLine{00184     // particle loop}
\DoxyCodeLine{00185     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i+= blockDim.x * gridDim.x) \{}
\DoxyCodeLine{00186         predictor.x[i] = p.x[i] + dt/2 * p.dxdt[i];}
\DoxyCodeLine{00187         predictor.vx[i] = p.vx[i] + dt/2 * p.ax[i];}
\DoxyCodeLine{00188 }
\DoxyCodeLine{00189 \#if DIM > 1}
\DoxyCodeLine{00190         predictor.y[i] = p.y[i] + dt/2 * p.dydt[i];}
\DoxyCodeLine{00191         predictor.vy[i] = p.vy[i] + dt/2 * p.ay[i];}
\DoxyCodeLine{00192 \#endif}
\DoxyCodeLine{00193 \#if DIM > 2}
\DoxyCodeLine{00194         predictor.z[i] = p.z[i] + dt/2 * p.dzdt[i];}
\DoxyCodeLine{00195         predictor.vz[i] = p.vz[i] + dt/2 * p.az[i];}
\DoxyCodeLine{00196 \#endif}
\DoxyCodeLine{00197 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00198         predictor.rho[i] = p.rho[i] + dt/2 * p.drhodt[i];}
\DoxyCodeLine{00199 \#else}
\DoxyCodeLine{00200         predictor.rho[i] = p.rho[i];}
\DoxyCodeLine{00201 \#endif}
\DoxyCodeLine{00202 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00203         predictor.e[i] = p.e[i] + dt/2 * p.dedt[i];}
\DoxyCodeLine{00204 \#endif}
\DoxyCodeLine{00205 \#if INTEGRATE\_SML}
\DoxyCodeLine{00206         predictor.h[i] = p.h[i] + dt/2 * p.dhdt[i];}
\DoxyCodeLine{00207 \#else}
\DoxyCodeLine{00208         predictor.h[i] = p.h[i];}
\DoxyCodeLine{00209 \#endif}
\DoxyCodeLine{00210 }
\DoxyCodeLine{00211 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00212         // p points to p\_device and p.p is the pressure at the start of the timestep}
\DoxyCodeLine{00213         // while predictor changes during the adaptive time step}
\DoxyCodeLine{00214         predictor.pold[i] = p.p[i];}
\DoxyCodeLine{00215         predictor.alpha\_jutzi[i] = p.alpha\_jutzi[i] + dt/2 * p.dalphadt[i];}
\DoxyCodeLine{00216         predictor.alpha\_jutzi\_old[i] = p.alpha\_jutzi\_old[i];}
\DoxyCodeLine{00217 \#endif}
\DoxyCodeLine{00218 }
\DoxyCodeLine{00219 \#if FRAGMENTATION}
\DoxyCodeLine{00220         predictor.d[i] = p.d[i] + dt/2 * p.dddt[i];}
\DoxyCodeLine{00221         predictor.numActiveFlaws[i] = p.numActiveFlaws[i];}
\DoxyCodeLine{00222 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00223         predictor.damage\_porjutzi[i] = p.damage\_porjutzi[i] + dt/2 * p.ddamage\_porjutzidt[i];}
\DoxyCodeLine{00224 \#endif}
\DoxyCodeLine{00225 \#endif}
\DoxyCodeLine{00226 \#if JC\_PLASTICITY}
\DoxyCodeLine{00227         predictor.ep[i] = p.ep[i] + dt/2 * p.edotp[i];}
\DoxyCodeLine{00228         predictor.T[i] = p.T[i] + dt/2 * p.dTdt[i];}
\DoxyCodeLine{00229 \#endif}
\DoxyCodeLine{00230 \#if SIRONO\_POROSITY}
\DoxyCodeLine{00231         predictor.rho\_0prime[i] = p.rho\_0prime[i];}
\DoxyCodeLine{00232         predictor.rho\_c\_plus[i] = p.rho\_c\_plus[i];}
\DoxyCodeLine{00233         predictor.rho\_c\_minus[i] = p.rho\_c\_minus[i];}
\DoxyCodeLine{00234         predictor.compressive\_strength[i] = p.compressive\_strength[i];}
\DoxyCodeLine{00235         predictor.tensile\_strength[i] = p.tensile\_strength[i];}
\DoxyCodeLine{00236         predictor.shear\_strength[i] = p.shear\_strength[i];}
\DoxyCodeLine{00237         predictor.K[i] = p.K[i];}
\DoxyCodeLine{00238         predictor.flag\_rho\_0prime[i] = p.flag\_rho\_0prime[i];}
\DoxyCodeLine{00239         predictor.flag\_plastic[i] = p.flag\_plastic[i];}
\DoxyCodeLine{00240 \#endif}
\DoxyCodeLine{00241 \#if EPSALPHA\_POROSITY}
\DoxyCodeLine{00242         predictor.alpha\_epspor[i] = p.alpha\_epspor[i] + dt/2 * p.dalpha\_epspordt[i];}
\DoxyCodeLine{00243         predictor.epsilon\_v[i] = p.epsilon\_v[i] + dt/2 * p.depsilon\_vdt[i];}
\DoxyCodeLine{00244 \#endif}
\DoxyCodeLine{00245 \#if INVISCID\_SPH}
\DoxyCodeLine{00246         predictor.beta[i] = p.beta[i] + dt/2 * p.dbetadt[i];}
\DoxyCodeLine{00247 \#endif}
\DoxyCodeLine{00248 \#if SOLID}
\DoxyCodeLine{00249         for (j = 0; j < DIM; j++) \{}
\DoxyCodeLine{00250             for (k = 0; k < DIM; k++) \{}
\DoxyCodeLine{00251                 predictor.S[stressIndex(i,j,k)] = p.S[stressIndex(i,j,k)] + dt/2 * p.dSdt[stressIndex(i,j,k)];}
\DoxyCodeLine{00252             \}}
\DoxyCodeLine{00253         \}}
\DoxyCodeLine{00254 \#endif}
\DoxyCodeLine{00255     \}}
\DoxyCodeLine{00256 }
\DoxyCodeLine{00257 \}}
\DoxyCodeLine{00258 }
\DoxyCodeLine{00259 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00260 \_\_global\_\_ void CorrectorStepPorous()}
\DoxyCodeLine{00261 \{}
\DoxyCodeLine{00262     register int i;}
\DoxyCodeLine{00263 \#if SOLID}
\DoxyCodeLine{00264     register int j;}
\DoxyCodeLine{00265     register int k;}
\DoxyCodeLine{00266 \#endif}
\DoxyCodeLine{00267 }
\DoxyCodeLine{00268 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00269     // pointmass loop}
\DoxyCodeLine{00270     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numPointmasses; i+= blockDim.x * gridDim.x) \{}
\DoxyCodeLine{00271         predictor\_pointmass.x[i] = pointmass.x[i] + dt * predictor\_pointmass.vx[i];}
\DoxyCodeLine{00272 \#if DIM > 1}
\DoxyCodeLine{00273         predictor\_pointmass.y[i] = pointmass.y[i] + dt * predictor\_pointmass.vy[i];}
\DoxyCodeLine{00274         predictor\_pointmass.vy[i] = pointmass.vy[i] + dt * predictor\_pointmass.ay[i];}
\DoxyCodeLine{00275         predictor\_pointmass.ay[i] = predictor\_pointmass.ay[i];}
\DoxyCodeLine{00276 \#endif}
\DoxyCodeLine{00277         predictor\_pointmass.vx[i] = pointmass.vx[i] + dt * predictor\_pointmass.ax[i];}
\DoxyCodeLine{00278         predictor\_pointmass.ax[i] = predictor\_pointmass.ax[i];}
\DoxyCodeLine{00279 \#if DIM == 3}
\DoxyCodeLine{00280         predictor\_pointmass.z[i] = pointmass.z[i] + dt * predictor\_pointmass.vz[i];}
\DoxyCodeLine{00281         predictor\_pointmass.vz[i] = pointmass.vz[i] + dt * predictor\_pointmass.az[i];}
\DoxyCodeLine{00282         predictor\_pointmass.az[i] = predictor\_pointmass.az[i];}
\DoxyCodeLine{00283 \#endif}
\DoxyCodeLine{00284     \}}
\DoxyCodeLine{00285 \#endif // GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00286 }
\DoxyCodeLine{00287 }
\DoxyCodeLine{00288     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i+= blockDim.x * gridDim.x) \{}
\DoxyCodeLine{00289         predictor.x[i] = p.x[i] + dt * predictor.dxdt[i];}
\DoxyCodeLine{00290         predictor.y[i] = p.y[i] + dt * predictor.dydt[i];}
\DoxyCodeLine{00291         predictor.vx[i] = p.vx[i] + dt * predictor.ax[i];}
\DoxyCodeLine{00292         predictor.vy[i] = p.vy[i] + dt * predictor.ay[i];}
\DoxyCodeLine{00293 \#if DIM == 3}
\DoxyCodeLine{00294         predictor.z[i] = p.z[i] + dt * predictor.dzdt[i];}
\DoxyCodeLine{00295         predictor.vz[i] = p.vz[i] + dt * predictor.az[i];}
\DoxyCodeLine{00296 \#endif}
\DoxyCodeLine{00297 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00298         predictor.rho[i] = p.rho[i] + dt * predictor.drhodt[i];}
\DoxyCodeLine{00299 \#else}
\DoxyCodeLine{00300         predictor.rho[i] = p.rho[i];}
\DoxyCodeLine{00301 \#endif}
\DoxyCodeLine{00302 }
\DoxyCodeLine{00303 \#if INTEGRATE\_SML}
\DoxyCodeLine{00304         predictor.h[i] = p.h[i] + dt * predictor.dhdt[i];}
\DoxyCodeLine{00305 \#else}
\DoxyCodeLine{00306         predictor.h[i] = p.h[i];}
\DoxyCodeLine{00307 \#endif}
\DoxyCodeLine{00308 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00309         predictor.e[i] = p.e[i] + dt * predictor.dedt[i];}
\DoxyCodeLine{00310 \#endif}
\DoxyCodeLine{00311 \#if FRAGMENTATION}
\DoxyCodeLine{00312         predictor.d[i] = p.d[i] + dt * predictor.dddt[i];}
\DoxyCodeLine{00313 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00314         if (predictor.p[i] > p.p[i]) \{}
\DoxyCodeLine{00315             predictor.damage\_porjutzi[i] = p.damage\_porjutzi[i] + dt * predictor.ddamage\_porjutzidt[i];}
\DoxyCodeLine{00316         \} else \{}
\DoxyCodeLine{00317             predictor.d[i] = predictor.d[i];}
\DoxyCodeLine{00318             predictor.damage\_porjutzi[i] = p.damage\_porjutzi[i];}
\DoxyCodeLine{00319         \}}
\DoxyCodeLine{00320 \#endif}
\DoxyCodeLine{00321 \#endif}
\DoxyCodeLine{00322 \#if INVISCID\_SPH}
\DoxyCodeLine{00323         predictor.beta[i] = p.beta[i] + dt * predictor.dbetadt[i];}
\DoxyCodeLine{00324 \#endif}
\DoxyCodeLine{00325 \#if SOLID}
\DoxyCodeLine{00326         for (j = 0; j < DIM; j++) \{}
\DoxyCodeLine{00327             for (k = 0; k < DIM; k++) \{}
\DoxyCodeLine{00328                 predictor.S[stressIndex(i,j,k)] = p.S[stressIndex(i,j,k)] + dt  * predictor.dSdt[stressIndex(i,j,k)];}
\DoxyCodeLine{00329             \}}
\DoxyCodeLine{00330         \}}
\DoxyCodeLine{00331 \#endif}
\DoxyCodeLine{00332 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00333         /* check if we have compaction and change alpha accordingly */}
\DoxyCodeLine{00334         if (predictor.p[i] > p.p[i]) \{}
\DoxyCodeLine{00335             predictor.alpha\_jutzi[i] = p.alpha\_jutzi[i] + dt * predictor.dalphadt[i];}
\DoxyCodeLine{00336         \} else \{}
\DoxyCodeLine{00337             predictor.alpha\_jutzi[i] = p.alpha\_jutzi[i];}
\DoxyCodeLine{00338         \}}
\DoxyCodeLine{00339         predictor.alpha\_jutzi\_old[i] = p.alpha\_jutzi\_old[i];}
\DoxyCodeLine{00340 \#endif}
\DoxyCodeLine{00341     \}}
\DoxyCodeLine{00342 \}}
\DoxyCodeLine{00343 }
\DoxyCodeLine{00344 /* check the pressure change to avoid large deviation from the crush-\/curve */}
\DoxyCodeLine{00345 \_\_global\_\_ void pressureChangeCheck(double *maxpressureDiffPerBlock)}
\DoxyCodeLine{00346 \{}
\DoxyCodeLine{00347     \_\_shared\_\_ double sharedMaxpressureDiff[NUM\_THREADS\_PC\_INTEGRATOR];}
\DoxyCodeLine{00348     double localMaxpressureDiff = 0.0;}
\DoxyCodeLine{00349     double tmp = 0.0;}
\DoxyCodeLine{00350     int i, j, k, m;}
\DoxyCodeLine{00351     maxpressureDiff = 0.0;}
\DoxyCodeLine{00352     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i+= blockDim.x * gridDim.x) \{}
\DoxyCodeLine{00353         if (matEOS[p\_rhs.materialId[i]] == EOS\_TYPE\_JUTZI || matEOS[p\_rhs.materialId[i]] == EOS\_TYPE\_JUTZI\_MURNAGHAN) \{}
\DoxyCodeLine{00354             // cms -\/ 20190626}
\DoxyCodeLine{00355             // first rhs is called at beginning of timestep with predictor}
\DoxyCodeLine{00356             // and at the end with p\_device}
\DoxyCodeLine{00357             tmp = (p.p[i] -\/ predictor.pold[i]);}
\DoxyCodeLine{00358             localMaxpressureDiff = max(tmp, localMaxpressureDiff);}
\DoxyCodeLine{00359         \}}
\DoxyCodeLine{00360     \}}
\DoxyCodeLine{00361     i = threadIdx.x;}
\DoxyCodeLine{00362     sharedMaxpressureDiff[i] = localMaxpressureDiff;}
\DoxyCodeLine{00363     for (j = NUM\_THREADS\_PC\_INTEGRATOR / 2; j > 0; j /= 2) \{}
\DoxyCodeLine{00364         \_\_syncthreads();}
\DoxyCodeLine{00365         if (i < j) \{}
\DoxyCodeLine{00366             k = i + j;}
\DoxyCodeLine{00367             sharedMaxpressureDiff[i] = localMaxpressureDiff = max(localMaxpressureDiff, sharedMaxpressureDiff[k]);}
\DoxyCodeLine{00368         \}}
\DoxyCodeLine{00369     \}}
\DoxyCodeLine{00370     // write block result to global memory}
\DoxyCodeLine{00371     if (i == 0) \{}
\DoxyCodeLine{00372         k = blockIdx.x;}
\DoxyCodeLine{00373         maxpressureDiffPerBlock[k] = localMaxpressureDiff;}
\DoxyCodeLine{00374         m = gridDim.x -\/ 1;}
\DoxyCodeLine{00375         if (m == atomicInc((unsigned int *)\&blockCount, m)) \{}
\DoxyCodeLine{00376             // last block, so combine all block results}
\DoxyCodeLine{00377             for (j = 0; j <= m; j++) \{}
\DoxyCodeLine{00378                 localMaxpressureDiff = max(localMaxpressureDiff, maxpressureDiffPerBlock[j]);}
\DoxyCodeLine{00379             \}}
\DoxyCodeLine{00380             maxpressureDiff = localMaxpressureDiff;}
\DoxyCodeLine{00381             // reset block count}
\DoxyCodeLine{00382             blockCount = 0;}
\DoxyCodeLine{00383         \}}
\DoxyCodeLine{00384         if (maxpressureDiff > max\_abs\_pressure\_change) \{}
\DoxyCodeLine{00385             printf("{}maxpressure change \%e\(\backslash\)n"{}, maxpressureDiff);}
\DoxyCodeLine{00386             pressureChangeSmallEnough = FALSE;}
\DoxyCodeLine{00387             dt = 0.25 * dt;}
\DoxyCodeLine{00388             dt = min(dt, endTimeD -\/ currentTimeD);}
\DoxyCodeLine{00389         \} else \{}
\DoxyCodeLine{00390             pressureChangeSmallEnough = TRUE;}
\DoxyCodeLine{00391     //        currentTimeD += dt;}
\DoxyCodeLine{00392         \}}
\DoxyCodeLine{00393     \}}
\DoxyCodeLine{00394 \}}
\DoxyCodeLine{00395 \#endif}
\DoxyCodeLine{00396 }
\DoxyCodeLine{00397 \_\_global\_\_ void setTimestep(double *forcesPerBlock, double *courantPerBlock, double *dtSPerBlock, double *dtePerBlock, double *dtrhoPerBlock, double *dtdamagePerBlock, double *dtalphaPerBlock, double *dtartviscPerBlock, double *dtbetaPerBlock, double *dtalpha\_epsporPerBlock, double *dtepsilon\_vPerBlock)}
\DoxyCodeLine{00398 \{}
\DoxyCodeLine{00399 }
\DoxyCodeLine{00400 \#define SAFETY\_FIRST 0.7}
\DoxyCodeLine{00401 }
\DoxyCodeLine{00402     \_\_shared\_\_ double sharedForces[NUM\_THREADS\_LIMITTIMESTEP];}
\DoxyCodeLine{00403     \_\_shared\_\_ double sharedCourant[NUM\_THREADS\_LIMITTIMESTEP];}
\DoxyCodeLine{00404     \_\_shared\_\_ double sharedArtVisc[NUM\_THREADS\_LIMITTIMESTEP];}
\DoxyCodeLine{00405     \_\_shared\_\_ double sharedS[NUM\_THREADS\_LIMITTIMESTEP];}
\DoxyCodeLine{00406     \_\_shared\_\_ double sharede[NUM\_THREADS\_LIMITTIMESTEP];}
\DoxyCodeLine{00407     \_\_shared\_\_ double sharedrho[NUM\_THREADS\_LIMITTIMESTEP];}
\DoxyCodeLine{00408     \_\_shared\_\_ double shareddamage[NUM\_THREADS\_LIMITTIMESTEP];}
\DoxyCodeLine{00409     \_\_shared\_\_ double sharedalpha[NUM\_THREADS\_LIMITTIMESTEP];}
\DoxyCodeLine{00410     \_\_shared\_\_ double sharedbeta[NUM\_THREADS\_LIMITTIMESTEP];}
\DoxyCodeLine{00411     \_\_shared\_\_ double sharedalpha\_epspor[NUM\_THREADS\_LIMITTIMESTEP];}
\DoxyCodeLine{00412     \_\_shared\_\_ double sharedepsilon\_v[NUM\_THREADS\_LIMITTIMESTEP];}
\DoxyCodeLine{00413 }
\DoxyCodeLine{00414     int i, j, k, m;}
\DoxyCodeLine{00415     int d, dd;}
\DoxyCodeLine{00416     int index;}
\DoxyCodeLine{00417     int hasEnergy;}
\DoxyCodeLine{00418     double forces = DBL\_MAX, courant = DBL\_MAX;}
\DoxyCodeLine{00419     double dtx = DBL\_MAX;}
\DoxyCodeLine{00420     double dtS = DBL\_MAX;}
\DoxyCodeLine{00421     double dtrho = DBL\_MAX;}
\DoxyCodeLine{00422     double dte = DBL\_MAX;}
\DoxyCodeLine{00423     double dtdamage = DBL\_MAX;}
\DoxyCodeLine{00424     double dtalpha = DBL\_MAX;}
\DoxyCodeLine{00425     double dtbeta = DBL\_MAX;}
\DoxyCodeLine{00426     double dtalpha\_epspor = DBL\_MAX;}
\DoxyCodeLine{00427     double dtepsilon\_v = DBL\_MAX;}
\DoxyCodeLine{00428     double temp;}
\DoxyCodeLine{00429     double sml;}
\DoxyCodeLine{00430     int matId;}
\DoxyCodeLine{00431 \#if SOLID}
\DoxyCodeLine{00432     double myS, dS;}
\DoxyCodeLine{00433 \#endif}
\DoxyCodeLine{00434     double ax, ay;}
\DoxyCodeLine{00435 \#if DIM == 3}
\DoxyCodeLine{00436     double az;}
\DoxyCodeLine{00437 \#endif}
\DoxyCodeLine{00438     double dtartvisc = DBL\_MAX;}
\DoxyCodeLine{00439 }
\DoxyCodeLine{00440     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i+= blockDim.x * gridDim.x) \{}
\DoxyCodeLine{00441         matId = p\_rhs.materialId[i];}
\DoxyCodeLine{00442 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00443         hasEnergy = 0;}
\DoxyCodeLine{00444 }
\DoxyCodeLine{00445         switch  (matEOS[matId]) \{}
\DoxyCodeLine{00446             case (EOS\_TYPE\_TILLOTSON):}
\DoxyCodeLine{00447                 hasEnergy = 1;}
\DoxyCodeLine{00448                 break;}
\DoxyCodeLine{00449             case (EOS\_TYPE\_JUTZI):}
\DoxyCodeLine{00450                 hasEnergy = 1;}
\DoxyCodeLine{00451                 break;}
\DoxyCodeLine{00452             case (EOS\_TYPE\_SIRONO):}
\DoxyCodeLine{00453                 hasEnergy = 1;}
\DoxyCodeLine{00454                 break;}
\DoxyCodeLine{00455             case (EOS\_TYPE\_EPSILON):}
\DoxyCodeLine{00456                 hasEnergy = 1;}
\DoxyCodeLine{00457                 break;}
\DoxyCodeLine{00458             case (EOS\_TYPE\_ANEOS):}
\DoxyCodeLine{00459                 hasEnergy = 1;}
\DoxyCodeLine{00460                 break;}
\DoxyCodeLine{00461             default:}
\DoxyCodeLine{00462                 hasEnergy = 0;}
\DoxyCodeLine{00463                 break;}
\DoxyCodeLine{00464         \}}
\DoxyCodeLine{00465 \#endif}
\DoxyCodeLine{00466         ax = p.ax[i];}
\DoxyCodeLine{00467 \#if DIM > 1}
\DoxyCodeLine{00468         ay = p.ay[i];}
\DoxyCodeLine{00469 \#endif}
\DoxyCodeLine{00470 \#if DIM == 3}
\DoxyCodeLine{00471         az = p.az[i];}
\DoxyCodeLine{00472 \#endif}
\DoxyCodeLine{00473         temp = ax*ax;}
\DoxyCodeLine{00474 \#if DIM > 1}
\DoxyCodeLine{00475         temp += + ay*ay;}
\DoxyCodeLine{00476 \#endif}
\DoxyCodeLine{00477 \#if DIM == 3}
\DoxyCodeLine{00478         temp += az*az;}
\DoxyCodeLine{00479 \#endif}
\DoxyCodeLine{00480             ;}
\DoxyCodeLine{00481         sml = p.h[i];}
\DoxyCodeLine{00482         temp = sqrt(sml / sqrt(temp));}
\DoxyCodeLine{00483         forces = min(forces, temp);}
\DoxyCodeLine{00484         temp = sml / p.cs[i];}
\DoxyCodeLine{00485         courant = min(courant, temp);}
\DoxyCodeLine{00486 }
\DoxyCodeLine{00487 \#define CFL 0.7}
\DoxyCodeLine{00488 }
\DoxyCodeLine{00489 \#if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00490         temp = CFL  * sml / (p.cs[i] + 1.2 * (matAlpha[matId]) * p.cs[i] + matBeta[matId] *}
\DoxyCodeLine{00491                 p.muijmax[i]);}
\DoxyCodeLine{00492         dtartvisc = min(dtartvisc, temp);}
\DoxyCodeLine{00493 \#endif}
\DoxyCodeLine{00494 \#if INVISCID\_SPH}
\DoxyCodeLine{00495         if (p.dbetadt[i] != 0) \{}
\DoxyCodeLine{00496             temp = SAFETY\_FIRST * (fabs(p.beta[i])+betamin\_d)/fabs(p.dbetadt[i]);}
\DoxyCodeLine{00497             dtbeta = min(temp, dtbeta);}
\DoxyCodeLine{00498         \}}
\DoxyCodeLine{00499 \#endif}
\DoxyCodeLine{00500 \#if SOLID}
\DoxyCodeLine{00501         myS = 0;}
\DoxyCodeLine{00502         dS = 0;}
\DoxyCodeLine{00503 }
\DoxyCodeLine{00504         for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00505             for (dd = 0; dd < DIM; dd++) \{}
\DoxyCodeLine{00506                 index = i*DIM*DIM+d*DIM+dd;}
\DoxyCodeLine{00507                 myS += p.S[index]*p.S[index];}
\DoxyCodeLine{00508                 dS += p.dSdt[index]*p.dSdt[index];}
\DoxyCodeLine{00509             \}}
\DoxyCodeLine{00510         \}}
\DoxyCodeLine{00511         if (dS != 0) \{}
\DoxyCodeLine{00512             temp = SAFETY\_FIRST * sqrt((myS+Smin\_d)/dS);}
\DoxyCodeLine{00513             dtS = min(temp, dtS);}
\DoxyCodeLine{00514         \}}
\DoxyCodeLine{00515 \#endif}
\DoxyCodeLine{00516 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00517         if (p.drhodt[i] != 0) \{}
\DoxyCodeLine{00518             temp = SAFETY\_FIRST * (fabs(p.rho[i])+rhomin\_d)/fabs(p.drhodt[i]);}
\DoxyCodeLine{00519             dtrho = min(temp, dtrho);}
\DoxyCodeLine{00520         \}}
\DoxyCodeLine{00521 \#endif}
\DoxyCodeLine{00522 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00523         if (p.dedt[i] != 0 \&\& hasEnergy) \{}
\DoxyCodeLine{00524             temp = SAFETY\_FIRST * (fabs(p.e[i])+emin\_d)/fabs(p.dedt[i]);}
\DoxyCodeLine{00525             dte = min(temp, dte);}
\DoxyCodeLine{00526         \}}
\DoxyCodeLine{00527 \#endif}
\DoxyCodeLine{00528 }
\DoxyCodeLine{00529 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00530         if (p.dalphadt[i] != 0) \{}
\DoxyCodeLine{00531             temp = 1.0e-\/2 / fabs(p.dalphadt[i]);}
\DoxyCodeLine{00532             dtalpha = min(temp, dtalpha);}
\DoxyCodeLine{00533         \}}
\DoxyCodeLine{00534 \#endif}
\DoxyCodeLine{00535 }
\DoxyCodeLine{00536 \#if EPSALPHA\_POROSITY}
\DoxyCodeLine{00537         if (p.dalpha\_epspordt[i] != 0) \{}
\DoxyCodeLine{00538             temp = 1.0e-\/1 / fabs(p.dalpha\_epspordt[i]);}
\DoxyCodeLine{00539             dtalpha\_epspor = min(temp, dtalpha\_epspor);}
\DoxyCodeLine{00540         \}}
\DoxyCodeLine{00541 }
\DoxyCodeLine{00542         if (p.depsilon\_vdt[i] != 0) \{}
\DoxyCodeLine{00543             temp = SAFETY\_FIRST * (fabs(p.epsilon\_v[i])+epsilon\_vmin\_d)/fabs(p.depsilon\_vdt[i]);}
\DoxyCodeLine{00544             dtepsilon\_v = min(temp, dtepsilon\_v);}
\DoxyCodeLine{00545         \}}
\DoxyCodeLine{00546 \#endif}
\DoxyCodeLine{00547 }
\DoxyCodeLine{00548 \#if FRAGMENTATION}
\DoxyCodeLine{00549         if (p.dddt[i] != 0) \{}
\DoxyCodeLine{00550             temp = SAFETY\_FIRST * (fabs(p.d[i])+damagemin\_d)/fabs(p.dddt[i]);}
\DoxyCodeLine{00551             dtdamage = min(temp, dtdamage);}
\DoxyCodeLine{00552         \}}
\DoxyCodeLine{00553 \#endif}
\DoxyCodeLine{00554 }
\DoxyCodeLine{00555 }
\DoxyCodeLine{00556     \}}
\DoxyCodeLine{00557     i = threadIdx.x;}
\DoxyCodeLine{00558     sharedForces[i] = forces;}
\DoxyCodeLine{00559     sharedCourant[i] = courant;}
\DoxyCodeLine{00560     sharedS[i] = dtS;}
\DoxyCodeLine{00561     sharede[i] = dte;}
\DoxyCodeLine{00562     sharedrho[i] = dtrho;}
\DoxyCodeLine{00563     shareddamage[i] = dtdamage;}
\DoxyCodeLine{00564     sharedalpha[i] = dtalpha;}
\DoxyCodeLine{00565     sharedbeta[i] = dtbeta;}
\DoxyCodeLine{00566     sharedalpha\_epspor[i] = dtalpha\_epspor;}
\DoxyCodeLine{00567     sharedepsilon\_v[i] = dtepsilon\_v;}
\DoxyCodeLine{00568 }
\DoxyCodeLine{00569 \#if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00570     sharedArtVisc[i] = dtartvisc;}
\DoxyCodeLine{00571 \#endif}
\DoxyCodeLine{00572     for (j = NUM\_THREADS\_LIMITTIMESTEP / 2; j > 0; j /= 2) \{}
\DoxyCodeLine{00573         \_\_syncthreads();}
\DoxyCodeLine{00574         if (i < j) \{}
\DoxyCodeLine{00575             k = i + j;}
\DoxyCodeLine{00576             sharedForces[i] = forces = min(forces, sharedForces[k]);}
\DoxyCodeLine{00577             sharedCourant[i] = courant = min(courant, sharedCourant[k]);}
\DoxyCodeLine{00578             sharedS[i] = dtS = min(dtS, sharedS[k]);}
\DoxyCodeLine{00579             sharede[i] = dte = min(dte, sharede[k]);}
\DoxyCodeLine{00580             sharedrho[i] = dtrho = min(dtrho, sharedrho[k]);}
\DoxyCodeLine{00581             shareddamage[i] = dtdamage = min(dtdamage, shareddamage[k]);}
\DoxyCodeLine{00582             sharedalpha[i] = dtalpha = min(dtalpha, sharedalpha[k]);}
\DoxyCodeLine{00583             sharedalpha\_epspor[i] = dtalpha\_epspor = min(dtalpha\_epspor, sharedalpha\_epspor[k]);}
\DoxyCodeLine{00584             sharedepsilon\_v[i] = dtepsilon\_v = min(dtepsilon\_v, sharedepsilon\_v[k]);}
\DoxyCodeLine{00585 \#if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00586             sharedArtVisc[i] = dtartvisc = min(dtartvisc, sharedArtVisc[k]);}
\DoxyCodeLine{00587 \#endif}
\DoxyCodeLine{00588 \#if INVISCID\_SPH}
\DoxyCodeLine{00589             sharedbeta[i] = dtbeta = min(dtbeta, sharedbeta[i]);}
\DoxyCodeLine{00590 \#endif}
\DoxyCodeLine{00591         \}}
\DoxyCodeLine{00592     \}}
\DoxyCodeLine{00593     // write block result to global memory}
\DoxyCodeLine{00594     if (i == 0) \{}
\DoxyCodeLine{00595         k = blockIdx.x;}
\DoxyCodeLine{00596         forcesPerBlock[k] = forces;}
\DoxyCodeLine{00597         courantPerBlock[k] = courant;}
\DoxyCodeLine{00598         dtSPerBlock[k] = dtS;}
\DoxyCodeLine{00599         dtePerBlock[k] = dte;}
\DoxyCodeLine{00600         dtrhoPerBlock[k] = dtrho;}
\DoxyCodeLine{00601         dtdamagePerBlock[k] = dtdamage;}
\DoxyCodeLine{00602         dtalphaPerBlock[k] = dtalpha;}
\DoxyCodeLine{00603         dtalpha\_epsporPerBlock[k] = dtalpha\_epspor;}
\DoxyCodeLine{00604         dtepsilon\_vPerBlock[k] = dtepsilon\_v;}
\DoxyCodeLine{00605 \#if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00606         dtartviscPerBlock[k] = dtartvisc;}
\DoxyCodeLine{00607 \#endif}
\DoxyCodeLine{00608 \#if INVISCID\_SPH}
\DoxyCodeLine{00609         dtbetaPerBlock[k] = dtbeta;}
\DoxyCodeLine{00610 \#endif}
\DoxyCodeLine{00611         m = gridDim.x -\/ 1;}
\DoxyCodeLine{00612         if (m == atomicInc((unsigned int *)\&blockCount, m)) \{}
\DoxyCodeLine{00613             // last block, so combine all block results}
\DoxyCodeLine{00614             for (j = 0; j <= m; j++) \{}
\DoxyCodeLine{00615                 forces = min(forces, forcesPerBlock[j]);}
\DoxyCodeLine{00616                 courant = min(courant, courantPerBlock[j]);}
\DoxyCodeLine{00617                 dtS = min(dtS, dtSPerBlock[j]);}
\DoxyCodeLine{00618                 dte = min(dte, dtePerBlock[j]);}
\DoxyCodeLine{00619                 dtrho = min(dtrho, dtrhoPerBlock[j]);}
\DoxyCodeLine{00620                 dtdamage = min(dtdamage, dtdamagePerBlock[j]);}
\DoxyCodeLine{00621                 dtalpha = min(dtalpha, dtalphaPerBlock[j]);}
\DoxyCodeLine{00622                 dtalpha\_epspor = min(dtalpha\_epspor, dtalpha\_epsporPerBlock[j]);}
\DoxyCodeLine{00623                 dtepsilon\_v = min(dtepsilon\_v, dtepsilon\_vPerBlock[j]);}
\DoxyCodeLine{00624 \#if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00625                 dtartvisc = min(dtartvisc, dtartviscPerBlock[j]);}
\DoxyCodeLine{00626 \#endif}
\DoxyCodeLine{00627 \#if INVISCID\_SPH}
\DoxyCodeLine{00628                 dtbeta = min(dtbeta, dtbetaPerBlock[j]);}
\DoxyCodeLine{00629 \#endif}
\DoxyCodeLine{00630             \}}
\DoxyCodeLine{00631             // set new timestep}
\DoxyCodeLine{00632             dt = dtx = min(COURANT*courant, forces*0.2);}
\DoxyCodeLine{00633 \#if SOLID}
\DoxyCodeLine{00634             dt = min(dt, dtS);}
\DoxyCodeLine{00635 \#endif}
\DoxyCodeLine{00636 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00637             dt = min(dt, dte);}
\DoxyCodeLine{00638 \#endif}
\DoxyCodeLine{00639 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00640             dt = min(dt, dtrho);}
\DoxyCodeLine{00641 \#endif}
\DoxyCodeLine{00642 \#if FRAGMENTATION}
\DoxyCodeLine{00643             dt = min(dt, dtdamage);}
\DoxyCodeLine{00644 \#endif}
\DoxyCodeLine{00645 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00646             dt = min(dt, dtalpha);}
\DoxyCodeLine{00647 \#endif}
\DoxyCodeLine{00648 \#if EPSALPHA\_POROSITY}
\DoxyCodeLine{00649             dt = min(dt, dtalpha\_epspor);}
\DoxyCodeLine{00650             dt = min(dt, dtepsilon\_v);}
\DoxyCodeLine{00651 \#endif}
\DoxyCodeLine{00652 \#if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00653             dt = min(dt, dtartvisc);}
\DoxyCodeLine{00654 \#endif}
\DoxyCodeLine{00655 \#if INVISCID\_SPH}
\DoxyCodeLine{00656             dt = min(dt, dtbeta);}
\DoxyCodeLine{00657 \#endif}
\DoxyCodeLine{00658             dt = min(dt, endTimeD -\/ currentTimeD);}
\DoxyCodeLine{00659             printf("{}Time Step Information: dt(v and x): \%e dtS: \%e dte: \%e dtrho: \%e dtdamage: \%e dtalpha: \%e dtalpha\_epspor: \%e dtepsilon\_v: \%e\(\backslash\)n"{},}
\DoxyCodeLine{00660                     dtx, dtS, dte, dtrho, dtdamage, dtalpha, dtalpha\_epspor, dtepsilon\_v);}
\DoxyCodeLine{00661             printf("{}time: \%e timestep set to \%e, integrating until \%e \(\backslash\)n"{}, currentTimeD, dt, endTimeD);}
\DoxyCodeLine{00662 \#if !PALPHA\_POROSITY}
\DoxyCodeLine{00663             currentTimeD += dt;}
\DoxyCodeLine{00664 \#endif}
\DoxyCodeLine{00665                         // reset block count}
\DoxyCodeLine{00666                         blockCount = 0;}
\DoxyCodeLine{00667                 \}}
\DoxyCodeLine{00668         \}}
\DoxyCodeLine{00669 \}}
\DoxyCodeLine{00670 }
\DoxyCodeLine{00671 }
\DoxyCodeLine{00672 }
\DoxyCodeLine{00673 }
\DoxyCodeLine{00674 void predictor\_corrector()}
\DoxyCodeLine{00675 \{}
\DoxyCodeLine{00676 }
\DoxyCodeLine{00677     double *courantPerBlock, *forcesPerBlock;}
\DoxyCodeLine{00678     double *dtSPerBlock, *dtePerBlock, *dtrhoPerBlock;}
\DoxyCodeLine{00679     double *dtdamagePerBlock;}
\DoxyCodeLine{00680     double *dtalphaPerBlock;}
\DoxyCodeLine{00681     double *dtartviscPerBlock;}
\DoxyCodeLine{00682     double *maxpressureDiffPerBlock;}
\DoxyCodeLine{00683     double *dtbetaPerBlock;}
\DoxyCodeLine{00684     double *dtalpha\_epsporPerBlock;}
\DoxyCodeLine{00685     double *dtepsilon\_vPerBlock;}
\DoxyCodeLine{00686     int pressureChangeSmallEnough\_host;}
\DoxyCodeLine{00687     double maxpressureDiff\_host;}
\DoxyCodeLine{00688     double maxpressureDiff\_previous;}
\DoxyCodeLine{00689     int maxpressureDiff\_cnt;}
\DoxyCodeLine{00690 }
\DoxyCodeLine{00691 }
\DoxyCodeLine{00692     cudaVerify(cudaMalloc((void**)\&courantPerBlock, sizeof(double)*numberOfMultiprocessors));}
\DoxyCodeLine{00693     cudaVerify(cudaMalloc((void**)\&forcesPerBlock, sizeof(double)*numberOfMultiprocessors));}
\DoxyCodeLine{00694     cudaVerify(cudaMalloc((void**)\&dtSPerBlock, sizeof(double)*numberOfMultiprocessors));}
\DoxyCodeLine{00695     cudaVerify(cudaMalloc((void**)\&dtePerBlock, sizeof(double)*numberOfMultiprocessors));}
\DoxyCodeLine{00696     cudaVerify(cudaMalloc((void**)\&dtrhoPerBlock, sizeof(double)*numberOfMultiprocessors));}
\DoxyCodeLine{00697     cudaVerify(cudaMalloc((void**)\&dtdamagePerBlock, sizeof(double)*numberOfMultiprocessors));}
\DoxyCodeLine{00698     cudaVerify(cudaMalloc((void**)\&dtalphaPerBlock, sizeof(double)*numberOfMultiprocessors));}
\DoxyCodeLine{00699     cudaVerify(cudaMalloc((void**)\&dtbetaPerBlock, sizeof(double)*numberOfMultiprocessors));}
\DoxyCodeLine{00700     cudaVerify(cudaMalloc((void**)\&maxpressureDiffPerBlock, sizeof(double)*numberOfMultiprocessors));}
\DoxyCodeLine{00701     cudaVerify(cudaMalloc((void**)\&dtartviscPerBlock, sizeof(double)*numberOfMultiprocessors));}
\DoxyCodeLine{00702     cudaVerify(cudaMalloc((void**)\&dtalpha\_epsporPerBlock, sizeof(double)*numberOfMultiprocessors));}
\DoxyCodeLine{00703     cudaVerify(cudaMalloc((void**)\&dtepsilon\_vPerBlock, sizeof(double)*numberOfMultiprocessors));}
\DoxyCodeLine{00704 }
\DoxyCodeLine{00705     int lastTimestep = startTimestep + numberOfTimesteps;}
\DoxyCodeLine{00706     int timestep;}
\DoxyCodeLine{00707     double substep\_currentTime;}
\DoxyCodeLine{00708     currentTime = startTime;}
\DoxyCodeLine{00709     double endTime = startTime;}
\DoxyCodeLine{00710 }
\DoxyCodeLine{00711     int allocate\_immutables = 1;}
\DoxyCodeLine{00712     // alloc mem for one rhs}
\DoxyCodeLine{00713     allocate\_particles\_memory(\&predictor\_device, allocate\_immutables);}
\DoxyCodeLine{00714     copy\_particles\_immutables\_device\_to\_device(\&predictor\_device, \&p\_device);}
\DoxyCodeLine{00715     copy\_particles\_variables\_device\_to\_device(\&predictor\_device, \&p\_device);}
\DoxyCodeLine{00716     /* tell the gpu the current time */}
\DoxyCodeLine{00717     cudaVerify(cudaMemcpyToSymbol(currentTimeD, \&currentTime, sizeof(double)));}
\DoxyCodeLine{00718     cudaVerify(cudaMemcpyToSymbol(predictor, \&predictor\_device, sizeof(struct Particle)));}
\DoxyCodeLine{00719 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00720     allocate\_pointmass\_memory(\&predictor\_pointmass\_device, allocate\_immutables);}
\DoxyCodeLine{00721     copy\_pointmass\_immutables\_device\_to\_device(\&predictor\_pointmass\_device, \&pointmass\_device);}
\DoxyCodeLine{00722     /* tell the gpu the current time */}
\DoxyCodeLine{00723     cudaVerify(cudaMemcpyToSymbol(predictor\_pointmass, \&predictor\_pointmass\_device, sizeof(struct Pointmass)));}
\DoxyCodeLine{00724 \#endif}
\DoxyCodeLine{00725 }
\DoxyCodeLine{00726 }
\DoxyCodeLine{00727     for (timestep = startTimestep; timestep < lastTimestep; timestep++) \{}
\DoxyCodeLine{00728         fprintf(stdout, "{}calculating step \%d\(\backslash\)n"{}, timestep);}
\DoxyCodeLine{00729         printf("{}\(\backslash\)nstep \%d / \%d\(\backslash\)n"{}, timestep, lastTimestep);}
\DoxyCodeLine{00730         endTime += timePerStep;}
\DoxyCodeLine{00731         fprintf(stdout, "{} currenttime: \%e \(\backslash\)t endtime: \%e\(\backslash\)n"{}, currentTime, endTime);}
\DoxyCodeLine{00732 }
\DoxyCodeLine{00733         /* tell the gpu the time step */}
\DoxyCodeLine{00734         cudaVerify(cudaMemcpyToSymbol(dt, \&timePerStep, sizeof(double)));}
\DoxyCodeLine{00735         /* tell the gpu the end time */}
\DoxyCodeLine{00736         cudaVerify(cudaMemcpyToSymbol(endTimeD, \&endTime, sizeof(double)));}
\DoxyCodeLine{00737 }
\DoxyCodeLine{00738 }
\DoxyCodeLine{00739         // checking for changes in angular momentum}
\DoxyCodeLine{00740         if (param.angular\_momentum\_check > 0) \{}
\DoxyCodeLine{00741             double L\_current = calculate\_angular\_momentum();}
\DoxyCodeLine{00742             double L\_change\_relative;}
\DoxyCodeLine{00743             if (L\_ini > 0) \{}
\DoxyCodeLine{00744                 L\_change\_relative = fabs((L\_ini -\/ L\_current)/L\_ini);}
\DoxyCodeLine{00745             \}}
\DoxyCodeLine{00746             if (param.verbose) \{}
\DoxyCodeLine{00747                 fprintf(stdout, "{}Checking angular momentum conservation.\(\backslash\)n"{});}
\DoxyCodeLine{00748                 fprintf(stdout, "{}Initial angular momentum: \%.17e\(\backslash\)n"{}, L\_ini);}
\DoxyCodeLine{00749                 fprintf(stdout, "{}Current angular momentum: \%.17e\(\backslash\)n"{}, L\_current);}
\DoxyCodeLine{00750                 fprintf(stdout, "{}Relative change: \%.17e\(\backslash\)n"{}, L\_change\_relative);}
\DoxyCodeLine{00751             \}}
\DoxyCodeLine{00752             if (L\_change\_relative > param.angular\_momentum\_check) \{}
\DoxyCodeLine{00753                 fprintf(stderr, "{}Conservation of angular momentum violated. Exiting.\(\backslash\)n"{});}
\DoxyCodeLine{00754                 exit(111);}
\DoxyCodeLine{00755             \}}
\DoxyCodeLine{00756         \}}
\DoxyCodeLine{00757 }
\DoxyCodeLine{00758 }
\DoxyCodeLine{00759 }
\DoxyCodeLine{00760 }
\DoxyCodeLine{00761 }
\DoxyCodeLine{00762                 while (currentTime < endTime) \{}
\DoxyCodeLine{00763                         cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00764                         // calculate first right hand side with p\_device}
\DoxyCodeLine{00765                 cudaVerify(cudaMemcpyToSymbol(p, \&p\_device, sizeof(struct Particle)));}
\DoxyCodeLine{00766 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00767                 cudaVerify(cudaMemcpyToSymbol(pointmass, \&pointmass\_device, sizeof(struct Pointmass)));}
\DoxyCodeLine{00768 \#endif}
\DoxyCodeLine{00769             cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00770             cudaVerify(cudaMemcpyFromSymbol(\&currentTime, currentTimeD, sizeof(double)));}
\DoxyCodeLine{00771             substep\_currentTime = currentTime;}
\DoxyCodeLine{00772             cudaVerify(cudaMemcpyToSymbol(substep\_currentTimeD, \&substep\_currentTime, sizeof(double)));}
\DoxyCodeLine{00773             rightHandSide();}
\DoxyCodeLine{00774             cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00775             cudaVerifyKernel((setTimestep<<<numberOfMultiprocessors, NUM\_THREADS\_LIMITTIMESTEP>>>(}
\DoxyCodeLine{00776                               forcesPerBlock, courantPerBlock,}
\DoxyCodeLine{00777                               dtSPerBlock, dtePerBlock, dtrhoPerBlock, dtdamagePerBlock,}
\DoxyCodeLine{00778                               dtalphaPerBlock, dtartviscPerBlock, dtbetaPerBlock, dtalpha\_epsporPerBlock, dtepsilon\_vPerBlock)));}
\DoxyCodeLine{00779             cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00780             /* get the time and the time step from the gpu */}
\DoxyCodeLine{00781             cudaVerify(cudaMemcpyFromSymbol(\&dt\_host, dt, sizeof(double)));}
\DoxyCodeLine{00782             substep\_currentTime = currentTime + dt\_host * 0.5;}
\DoxyCodeLine{00783 }
\DoxyCodeLine{00784                         cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00785 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00786             maxpressureDiff\_cnt = 0;}
\DoxyCodeLine{00787             maxpressureDiff\_host = 0;}
\DoxyCodeLine{00788             maxpressureDiff\_previous = 0;}
\DoxyCodeLine{00789             pressureChangeSmallEnough\_host = FALSE;}
\DoxyCodeLine{00790             while (pressureChangeSmallEnough\_host == FALSE) \{}
\DoxyCodeLine{00791 \#endif}
\DoxyCodeLine{00792                     // do the predictor step (writes to predictor)}
\DoxyCodeLine{00793                 cudaVerifyKernel((PredictorStep<<<numberOfMultiprocessors, NUM\_THREADS\_PC\_INTEGRATOR>>>()));}
\DoxyCodeLine{00794                             cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00795                 // get the derivatives at the predictor locations}
\DoxyCodeLine{00796                         cudaVerify(cudaMemcpyToSymbol(p, \&predictor\_device, sizeof(struct Particle)));}
\DoxyCodeLine{00797 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00798                         cudaVerify(cudaMemcpyToSymbol(pointmass, \&predictor\_pointmass\_device, sizeof(struct Pointmass)));}
\DoxyCodeLine{00799 \#endif}
\DoxyCodeLine{00800 }
\DoxyCodeLine{00801                 if (param.selfgravity) \{}
\DoxyCodeLine{00802                         copy\_gravitational\_accels\_device\_to\_device(\&predictor\_device, \&p\_device);}
\DoxyCodeLine{00803                 \}}
\DoxyCodeLine{00804 }
\DoxyCodeLine{00805                 cudaVerify(cudaMemcpyToSymbol(substep\_currentTimeD, \&substep\_currentTime, sizeof(double)));}
\DoxyCodeLine{00806                                 rightHandSide();}
\DoxyCodeLine{00807                 // do the corrector step with the predictor and write it to in predictor}
\DoxyCodeLine{00808                         cudaVerify(cudaMemcpyToSymbol(p, \&p\_device, sizeof(struct Particle)));}
\DoxyCodeLine{00809 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00810                         cudaVerify(cudaMemcpyToSymbol(pointmass, \&pointmass\_device, sizeof(struct Pointmass)));}
\DoxyCodeLine{00811 \#endif}
\DoxyCodeLine{00812 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00813                 cudaVerifyKernel((CorrectorStepPorous<<<numberOfMultiprocessors, NUM\_THREADS\_PC\_INTEGRATOR>>>()));}
\DoxyCodeLine{00814                                 cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00815                                 cudaVerify(cudaMemcpyToSymbol(p, \&predictor\_device, sizeof(struct Particle)));}
\DoxyCodeLine{00816 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00817                         cudaVerify(cudaMemcpyToSymbol(pointmass, \&pointmass\_device, sizeof(struct Pointmass)));}
\DoxyCodeLine{00818 \#endif}
\DoxyCodeLine{00819                                 cudaVerifyKernel((calculatePressure<<<numberOfMultiprocessors * 4, NUM\_THREADS\_PRESSURE>>>()));}
\DoxyCodeLine{00820                         cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00821                                 cudaVerifyKernel((pressureChangeCheck<<<numberOfMultiprocessors, NUM\_THREADS\_PC\_INTEGRATOR>>>(maxpressureDiffPerBlock)));}
\DoxyCodeLine{00822                                 cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00823                                 cudaVerify(cudaMemcpyFromSymbol(\&pressureChangeSmallEnough\_host, pressureChangeSmallEnough, sizeof(int)));}
\DoxyCodeLine{00824                 cudaVerify(cudaMemcpyFromSymbol(\&maxpressureDiff\_host, maxpressureDiff, sizeof(double)));}
\DoxyCodeLine{00825                 if (pressureChangeSmallEnough\_host == FALSE) \{}
\DoxyCodeLine{00826                     /* redo predictor step with smaller timestep, derivatives are in p\_device */}
\DoxyCodeLine{00827                     printf("{}Reducing timestep due to Pressure Check function to: \%.17e\(\backslash\)n"{}, dt\_host);}
\DoxyCodeLine{00828                     if (fabs(maxpressureDiff\_host -\/maxpressureDiff\_previous) < 1e-\/3) \{}
\DoxyCodeLine{00829                         maxpressureDiff\_cnt++;}
\DoxyCodeLine{00830                     \}}
\DoxyCodeLine{00831                     maxpressureDiff\_previous = maxpressureDiff\_host;}
\DoxyCodeLine{00832                     if (maxpressureDiff\_cnt > 1) \{}
\DoxyCodeLine{00833                         printf("{}Cannot reduce timestep anymore, continuing with dt \%.17e and maxpressurediff \%.17e"{}, dt\_host, maxpressureDiff\_host);}
\DoxyCodeLine{00834                         pressureChangeSmallEnough\_host = TRUE;}
\DoxyCodeLine{00835                     \}}
\DoxyCodeLine{00836                 \}}
\DoxyCodeLine{00837                                 if (pressureChangeSmallEnough\_host == FALSE) \{}
\DoxyCodeLine{00838                     cudaVerify(cudaMemcpyFromSymbol(\&dt\_host, dt, sizeof(double)));}
\DoxyCodeLine{00839                                         substep\_currentTime = currentTime + dt\_host * 0.5;}
\DoxyCodeLine{00840                                         cudaVerify(cudaMemcpyToSymbol(p, \&p\_device, sizeof(struct Particle)));}
\DoxyCodeLine{00841 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00842                             cudaVerify(cudaMemcpyToSymbol(pointmass, \&pointmass\_device, sizeof(struct Pointmass)));}
\DoxyCodeLine{00843 \#endif}
\DoxyCodeLine{00844                                         printf("{}Reducing timestep due to Pressure Check function to: \%e\(\backslash\)n"{}, dt\_host);}
\DoxyCodeLine{00845                                 \} else \{}
\DoxyCodeLine{00846                                         cudaVerify(cudaMemcpyFromSymbol(\&dt\_host, dt, sizeof(double)));}
\DoxyCodeLine{00847                                         currentTime += dt\_host;}
\DoxyCodeLine{00848                                         cudaVerify(cudaMemcpyToSymbol(currentTimeD, \&currentTime, sizeof(double)));}
\DoxyCodeLine{00849                                         copy\_particles\_variables\_device\_to\_device(\&p\_device, \&predictor\_device);}
\DoxyCodeLine{00850 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00851                                         copy\_pointmass\_variables\_device\_to\_device(\&pointmass\_device, \&predictor\_pointmass\_device);}
\DoxyCodeLine{00852 \#endif}
\DoxyCodeLine{00853                                         cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00854                                 \}}
\DoxyCodeLine{00855                         \}}
\DoxyCodeLine{00856 \#else}
\DoxyCodeLine{00857             cudaVerifyKernel((CorrectorStep<<<numberOfMultiprocessors, NUM\_THREADS\_PC\_INTEGRATOR>>>()));}
\DoxyCodeLine{00858                         cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00859 \#endif}
\DoxyCodeLine{00860             /* get the time and the time step from the gpu */}
\DoxyCodeLine{00861             cudaVerify(cudaMemcpyFromSymbol(\&currentTime, currentTimeD, sizeof(double)));}
\DoxyCodeLine{00862                 \} // current time < end time loop}
\DoxyCodeLine{00863                 // write results}
\DoxyCodeLine{00864 \#if FRAGMENTATION}
\DoxyCodeLine{00865         cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00866         cudaVerifyKernel((damageLimit<<<numberOfMultiprocessors*4, NUM\_THREADS\_PC\_INTEGRATOR>>>()));}
\DoxyCodeLine{00867         cudaVerify(cudaDeviceSynchronize());}
\DoxyCodeLine{00868 \#endif}
\DoxyCodeLine{00869         copyToHostAndWriteToFile(timestep, lastTimestep);}
\DoxyCodeLine{00870 }
\DoxyCodeLine{00871         \} // timestep loop}
\DoxyCodeLine{00872 }
\DoxyCodeLine{00873         // free memory}
\DoxyCodeLine{00874 }
\DoxyCodeLine{00875     int free\_immutables = 1;}
\DoxyCodeLine{00876     free\_particles\_memory(\&predictor\_device, free\_immutables);}
\DoxyCodeLine{00877 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00878     free\_pointmass\_memory(\&predictor\_pointmass\_device, free\_immutables);}
\DoxyCodeLine{00879 \#endif}
\DoxyCodeLine{00880         cudaVerify(cudaFree(courantPerBlock));}
\DoxyCodeLine{00881         cudaVerify(cudaFree(forcesPerBlock));}
\DoxyCodeLine{00882         cudaVerify(cudaFree(dtSPerBlock));}
\DoxyCodeLine{00883         cudaVerify(cudaFree(dtePerBlock));}
\DoxyCodeLine{00884         cudaVerify(cudaFree(dtrhoPerBlock));}
\DoxyCodeLine{00885         cudaVerify(cudaFree(dtdamagePerBlock));}
\DoxyCodeLine{00886         cudaVerify(cudaFree(dtalphaPerBlock));}
\DoxyCodeLine{00887         cudaVerify(cudaFree(dtbetaPerBlock));}
\DoxyCodeLine{00888         cudaVerify(cudaFree(dtartviscPerBlock));}
\DoxyCodeLine{00889     cudaVerify(cudaFree(maxpressureDiffPerBlock));}
\DoxyCodeLine{00890     cudaVerify(cudaFree(dtalpha\_epsporPerBlock));}
\DoxyCodeLine{00891     cudaVerify(cudaFree(dtepsilon\_vPerBlock));}
\DoxyCodeLine{00892 \}}

\end{DoxyCode}
