\hypertarget{test__cases_2viscously__spreading__ring_2boundary_8cu_source}{}\doxysection{boundary.\+cu}
\label{test__cases_2viscously__spreading__ring_2boundary_8cu_source}\index{test\_cases/viscously\_spreading\_ring/boundary.cu@{test\_cases/viscously\_spreading\_ring/boundary.cu}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 /**}
\DoxyCodeLine{00002  * @author      Christoph Schaefer cm.schaefer@gmail.com}
\DoxyCodeLine{00003  *}
\DoxyCodeLine{00004  * @section     LICENSE}
\DoxyCodeLine{00005  * Copyright (c) 2019 Christoph Schaefer}
\DoxyCodeLine{00006  *}
\DoxyCodeLine{00007  * This file is part of miluphcuda.}
\DoxyCodeLine{00008  *}
\DoxyCodeLine{00009  * miluphcuda is free software: you can redistribute it and/or modify}
\DoxyCodeLine{00010  * it under the terms of the GNU General Public License as published by}
\DoxyCodeLine{00011  * the Free Software Foundation, either version 3 of the License, or}
\DoxyCodeLine{00012  * (at your option) any later version.}
\DoxyCodeLine{00013  *}
\DoxyCodeLine{00014  * miluphcuda is distributed in the hope that it will be useful,}
\DoxyCodeLine{00015  * but WITHOUT ANY WARRANTY; without even the implied warranty of}
\DoxyCodeLine{00016  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
\DoxyCodeLine{00017  * GNU General Public License for more details.}
\DoxyCodeLine{00018  *}
\DoxyCodeLine{00019  * You should have received a copy of the GNU General Public License}
\DoxyCodeLine{00020  * along with miluphcuda.  If not, see <http://www.gnu.org/licenses/>.}
\DoxyCodeLine{00021  *}
\DoxyCodeLine{00022  */}
\DoxyCodeLine{00023 \#include "{}timeintegration.h"{}}
\DoxyCodeLine{00024 \#include "{}boundary.h"{}}
\DoxyCodeLine{00025 \#include "{}miluph.h"{}}
\DoxyCodeLine{00026 \#include "{}pressure.h"{}}
\DoxyCodeLine{00027 }
\DoxyCodeLine{00028 }
\DoxyCodeLine{00029 extern \_\_device\_\_ double substep\_currentTimeD;}
\DoxyCodeLine{00030 extern \_\_device\_\_ double currentTimeD;}
\DoxyCodeLine{00031 extern \_\_device\_\_ double dt;}
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033 \#if DENSITY\_FLOOR}
\DoxyCodeLine{00034 extern \_\_device\_\_ double density\_floor\_d;}
\DoxyCodeLine{00035 \#endif}
\DoxyCodeLine{00036 }
\DoxyCodeLine{00037 }
\DoxyCodeLine{00038 \#if GHOST\_BOUNDARIES}
\DoxyCodeLine{00039 /* these are the locations and the properties of the boundary walls */}
\DoxyCodeLine{00040 const \_\_device\_\_ int numWalls = 1;}
\DoxyCodeLine{00041 \_\_device\_\_ double d[numWalls] = \{-\/0.007\};}
\DoxyCodeLine{00042 \_\_device\_\_ double nx[numWalls] = \{0\};}
\DoxyCodeLine{00043 \_\_device\_\_ double ny[numWalls] = \{0\};}
\DoxyCodeLine{00044 \#if DIM == 3}
\DoxyCodeLine{00045 \_\_device\_\_ double nz[numWalls] = \{1\};}
\DoxyCodeLine{00046 \#endif}
\DoxyCodeLine{00047     //boundary type: 0 = no slip, 1 = free slip}
\DoxyCodeLine{00048 \#define NO\_SLIP\_BOUNDARY\_TYPE 0}
\DoxyCodeLine{00049 \#define FREE\_SLIP\_BOUNDARY\_TYPE 1}
\DoxyCodeLine{00050 \_\_device\_\_ int boundaryType[numWalls] = \{NO\_SLIP\_BOUNDARY\_TYPE\};}
\DoxyCodeLine{00051 \#endif}
\DoxyCodeLine{00052 }
\DoxyCodeLine{00053 /* set quantities for Fixed Virtual Particles with matId == BOUNDARY\_PARTICLE\_ID */}
\DoxyCodeLine{00054 \_\_device\_\_ void setQuantitiesFixedVirtualParticles(int i, int j, double *vxj, double *vyj, double *vzj, double *densityj, double *pressurej, double *Sj)}
\DoxyCodeLine{00055 \{}
\DoxyCodeLine{00056     /* j is the virtual particle, i is the real particle */}
\DoxyCodeLine{00057     int e;}
\DoxyCodeLine{00058     /* distance to plane */}
\DoxyCodeLine{00059     double dI, dJ;}
\DoxyCodeLine{00060     double beta;}
\DoxyCodeLine{00061     double oneminusbeta = 0;}
\DoxyCodeLine{00062 \#define BETA\_MAX 1.5}
\DoxyCodeLine{00063 }
\DoxyCodeLine{00064 \#if DIM > 2}
\DoxyCodeLine{00065     /* test values only for plane at z=0 */}
\DoxyCodeLine{00066     dI = p.z[i];}
\DoxyCodeLine{00067     dJ = p.z[j];}
\DoxyCodeLine{00068 }
\DoxyCodeLine{00069     beta = min(BETA\_MAX, 1.0 + dJ/dI);}
\DoxyCodeLine{00070     oneminusbeta = 1-\/beta;}
\DoxyCodeLine{00071 \#endif}
\DoxyCodeLine{00072 }
\DoxyCodeLine{00073     *vxj = oneminusbeta*p.vx[i];}
\DoxyCodeLine{00074 \#if DIM > 1}
\DoxyCodeLine{00075     *vyj = oneminusbeta*p.vy[i];}
\DoxyCodeLine{00076 \#if DIM > 2}
\DoxyCodeLine{00077     *vzj = oneminusbeta*p.vz[i];}
\DoxyCodeLine{00078 \#endif}
\DoxyCodeLine{00079 \#endif}
\DoxyCodeLine{00080 \#if SOLID}
\DoxyCodeLine{00081     for (e = 0; e < DIM*DIM; e++) \{}
\DoxyCodeLine{00082         Sj[e] = p.S[i*DIM*DIM+e];}
\DoxyCodeLine{00083     \}}
\DoxyCodeLine{00084 \#endif}
\DoxyCodeLine{00085 }
\DoxyCodeLine{00086     *pressurej = p.p[i];}
\DoxyCodeLine{00087     *densityj = p.rho[i];}
\DoxyCodeLine{00088 }
\DoxyCodeLine{00089 \}}
\DoxyCodeLine{00090 }
\DoxyCodeLine{00091 }
\DoxyCodeLine{00092 // declare some boundary conditions here: this is called at the beginning of each RHS step}
\DoxyCodeLine{00093 \_\_global\_\_ void BoundaryConditionsBeforeRHS(int *interactions) }
\DoxyCodeLine{00094 \{}
\DoxyCodeLine{00095 \#if 1}
\DoxyCodeLine{00096     register int i, inc;}
\DoxyCodeLine{00097     int matId, d, e;}
\DoxyCodeLine{00098     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00099     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{00100             matId = p\_rhs.materialId[i];}
\DoxyCodeLine{00101             if (matId == EOS\_TYPE\_IGNORE) \{}
\DoxyCodeLine{00102                 p.ax[i] = 0;}
\DoxyCodeLine{00103                 p.ay[i] = 0;}
\DoxyCodeLine{00104                 p.dxdt[i] = 0;}
\DoxyCodeLine{00105                 p.dydt[i] = 0;}
\DoxyCodeLine{00106                 p.vx[i] = 0;}
\DoxyCodeLine{00107                 p.vy[i] = 0;}
\DoxyCodeLine{00108 \#if DIM == 3}
\DoxyCodeLine{00109                 p.az[i] = 0;}
\DoxyCodeLine{00110                 p.dzdt[i] = 0;}
\DoxyCodeLine{00111                 p.vz[i] = 0;}
\DoxyCodeLine{00112 \#endif}
\DoxyCodeLine{00113 \#if SOLID}
\DoxyCodeLine{00114                 for (d = 0; d < DIM*DIM; d++) \{}
\DoxyCodeLine{00115                     p.dSdt[i*DIM*DIM + d] = 0;}
\DoxyCodeLine{00116                 \}}
\DoxyCodeLine{00117 \#endif}
\DoxyCodeLine{00118 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00119                 p.drhodt[i] = 0;}
\DoxyCodeLine{00120 \#endif}
\DoxyCodeLine{00121             \}}
\DoxyCodeLine{00122 }
\DoxyCodeLine{00123             if (matId == BOUNDARY\_PARTICLE\_ID) \{}
\DoxyCodeLine{00124                 p.ax[i] = 0;}
\DoxyCodeLine{00125                 p.ay[i] = 0;}
\DoxyCodeLine{00126                 p.dxdt[i] = 0;}
\DoxyCodeLine{00127                 p.dydt[i] = 0;}
\DoxyCodeLine{00128                 p.vx[i] = 0;}
\DoxyCodeLine{00129                 p.vy[i] = 0;}
\DoxyCodeLine{00130 \#if DIM == 3}
\DoxyCodeLine{00131                 p.az[i] = 0;}
\DoxyCodeLine{00132                 p.dzdt[i] = 0;}
\DoxyCodeLine{00133                 p.vz[i] = 0;}
\DoxyCodeLine{00134 \#endif}
\DoxyCodeLine{00135 \#if SOLID}
\DoxyCodeLine{00136                 for (d = 0; d < DIM*DIM; d++) \{}
\DoxyCodeLine{00137                     p.dSdt[i*DIM*DIM + d] = 0;}
\DoxyCodeLine{00138                 \}}
\DoxyCodeLine{00139 \#endif}
\DoxyCodeLine{00140 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00141                 p.drhodt[i] = 0;}
\DoxyCodeLine{00142 \#endif}
\DoxyCodeLine{00143 \#if DENSITY\_FLOOR}
\DoxyCodeLine{00144             \} else if (p.rho[i] < 1e-\/2*density\_floor\_d) \{}
\DoxyCodeLine{00145                 p.rho[i] = 1e-\/2*density\_floor\_d;}
\DoxyCodeLine{00146 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00147                 p.drhodt[i] = 0.0;}
\DoxyCodeLine{00148 \#endif}
\DoxyCodeLine{00149 \#endif}
\DoxyCodeLine{00150             \}}
\DoxyCodeLine{00151     \}}
\DoxyCodeLine{00152 \#endif}
\DoxyCodeLine{00153 \}}
\DoxyCodeLine{00154 }
\DoxyCodeLine{00155 }
\DoxyCodeLine{00156 // boundary conditions called after the integration step of rk2adaptive only}
\DoxyCodeLine{00157 \_\_global\_\_ void BoundaryConditionsAfterIntegratorStep(int *interactions) }
\DoxyCodeLine{00158 \{}
\DoxyCodeLine{00159     register int i, inc;}
\DoxyCodeLine{00160     int matId, d, e;}
\DoxyCodeLine{00161     double distance;}
\DoxyCodeLine{00162     double ddistance;}
\DoxyCodeLine{00163     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00164     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{00165         matId = p.materialId[i];}
\DoxyCodeLine{00166     \}}
\DoxyCodeLine{00167 \}}
\DoxyCodeLine{00168 }
\DoxyCodeLine{00169 // declare some boundary conditions here: this is called at the end of each RHS step}
\DoxyCodeLine{00170 \_\_global\_\_ void BoundaryConditionsAfterRHS(int *interactions) }
\DoxyCodeLine{00171 \{}
\DoxyCodeLine{00172 \#if 1}
\DoxyCodeLine{00173     register int i, inc;}
\DoxyCodeLine{00174     int matId, d, e;}
\DoxyCodeLine{00175     double distance;}
\DoxyCodeLine{00176     double ddistance;}
\DoxyCodeLine{00177     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00178     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{00179             matId = p\_rhs.materialId[i];}
\DoxyCodeLine{00180 }
\DoxyCodeLine{00181             if (matId == EOS\_TYPE\_IGNORE) \{}
\DoxyCodeLine{00182                 p.ax[i] = 0;}
\DoxyCodeLine{00183                 p.ay[i] = 0;}
\DoxyCodeLine{00184                 p.dxdt[i] = 0;}
\DoxyCodeLine{00185                 p.dydt[i] = 0;}
\DoxyCodeLine{00186                 p.vx[i] = 0;}
\DoxyCodeLine{00187                 p.vy[i] = 0;}
\DoxyCodeLine{00188 \#if DIM == 3}
\DoxyCodeLine{00189                 p.az[i] = 0;}
\DoxyCodeLine{00190                 p.dzdt[i] = 0;}
\DoxyCodeLine{00191                 p.vz[i] = 0;}
\DoxyCodeLine{00192 \#endif}
\DoxyCodeLine{00193 \#if SOLID}
\DoxyCodeLine{00194                 for (d = 0; d < DIM*DIM; d++) \{}
\DoxyCodeLine{00195                     p.dSdt[i*DIM*DIM + d] = 0;}
\DoxyCodeLine{00196                 \}}
\DoxyCodeLine{00197 \#endif}
\DoxyCodeLine{00198 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00199                 p.drhodt[i] = 0;}
\DoxyCodeLine{00200 \#endif}
\DoxyCodeLine{00201             \}}
\DoxyCodeLine{00202 }
\DoxyCodeLine{00203 // adding central star with one solar mass}
\DoxyCodeLine{00204 // at (0,0)            }
\DoxyCodeLine{00205 }
\DoxyCodeLine{00206             distance = 0.0;}
\DoxyCodeLine{00207             ddistance = p.x[i]*p.x[i] + p.y[i]*p.y[i];}
\DoxyCodeLine{00208             distance = sqrt(ddistance);}
\DoxyCodeLine{00209             distance *= ddistance;}
\DoxyCodeLine{00210             p.ax[i] -\/= 1.327474512e+20 * p.x[i] / distance;}
\DoxyCodeLine{00211             p.ay[i] -\/= 1.327474512e+20 * p.y[i] / distance;}
\DoxyCodeLine{00212             }
\DoxyCodeLine{00213 //            p.az[i] -\/= 9.81;}
\DoxyCodeLine{00214 }
\DoxyCodeLine{00215             /* let's stick to the ground */}
\DoxyCodeLine{00216 }
\DoxyCodeLine{00217 \#if 0}
\DoxyCodeLine{00218             if (p.z[i] <= 1e-\/3) \{}
\DoxyCodeLine{00219                 p.ax[i] = 0;}
\DoxyCodeLine{00220                 p.ay[i] = 0;}
\DoxyCodeLine{00221                 p.dxdt[i] = 0;}
\DoxyCodeLine{00222                 p.dydt[i] = 0;}
\DoxyCodeLine{00223                 p.vx[i] = 0;}
\DoxyCodeLine{00224                 p.vy[i] = 0;}
\DoxyCodeLine{00225 \#if DIM == 3}
\DoxyCodeLine{00226                 p.az[i] = 0;}
\DoxyCodeLine{00227                 p.dzdt[i] = 0;}
\DoxyCodeLine{00228                 p.vz[i] = 0;}
\DoxyCodeLine{00229 \#endif}
\DoxyCodeLine{00230             \}}
\DoxyCodeLine{00231 \#endif}
\DoxyCodeLine{00232 }
\DoxyCodeLine{00233             if (matId == BOUNDARY\_PARTICLE\_ID) \{}
\DoxyCodeLine{00234             p.ax[i] = 0;}
\DoxyCodeLine{00235             p.ay[i] = 0;}
\DoxyCodeLine{00236             p.dxdt[i] = 0;}
\DoxyCodeLine{00237             p.dydt[i] = 0;}
\DoxyCodeLine{00238             p.vx[i] = 0;}
\DoxyCodeLine{00239             p.vy[i] = 0;}
\DoxyCodeLine{00240 \#if DIM == 3}
\DoxyCodeLine{00241             p.az[i] = 0;}
\DoxyCodeLine{00242             p.dzdt[i] = 0;}
\DoxyCodeLine{00243             p.vz[i] = 0;}
\DoxyCodeLine{00244 \#endif}
\DoxyCodeLine{00245 \#if SOLID}
\DoxyCodeLine{00246             for (d = 0; d < DIM*DIM; d++) \{}
\DoxyCodeLine{00247                 p.dSdt[i*DIM*DIM + d] = 0;}
\DoxyCodeLine{00248             \}}
\DoxyCodeLine{00249 \#endif}
\DoxyCodeLine{00250 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00251                 p.drhodt[i] = 0;}
\DoxyCodeLine{00252 \#endif}
\DoxyCodeLine{00253 \#if DENSITY\_FLOOR}
\DoxyCodeLine{00254             \} else if (p.rho[i] < 1e-\/2*density\_floor\_d) \{}
\DoxyCodeLine{00255                 p.rho[i] = 1e-\/2*density\_floor\_d;}
\DoxyCodeLine{00256 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00257                 p.drhodt[i] = 0.0;}
\DoxyCodeLine{00258 \#endif}
\DoxyCodeLine{00259 \#endif}
\DoxyCodeLine{00260             \}}
\DoxyCodeLine{00261     \}}
\DoxyCodeLine{00262 \#endif}
\DoxyCodeLine{00263 \}}
\DoxyCodeLine{00264 }
\DoxyCodeLine{00265 }
\DoxyCodeLine{00266 }
\DoxyCodeLine{00267 }
\DoxyCodeLine{00268 }
\DoxyCodeLine{00269 }
\DoxyCodeLine{00270 \#if GHOST\_BOUNDARIES}
\DoxyCodeLine{00271 \_\_global\_\_ void removeGhostParticles()}
\DoxyCodeLine{00272 \{}
\DoxyCodeLine{00273     //call with only one thread and one block}
\DoxyCodeLine{00274     numParticles = numRealParticles;}
\DoxyCodeLine{00275 \}}
\DoxyCodeLine{00276 }
\DoxyCodeLine{00277 /* set the density, pressure and other quantities for the ghost particles */}
\DoxyCodeLine{00278 \_\_global\_\_ void setQuantitiesGhostParticles() }
\DoxyCodeLine{00279 \{}
\DoxyCodeLine{00280     register int i, inc, k, idx, currentNumParticles;}
\DoxyCodeLine{00281     register int pidx;}
\DoxyCodeLine{00282 \#if SOLID}
\DoxyCodeLine{00283     int a, b;}
\DoxyCodeLine{00284 \#endif}
\DoxyCodeLine{00285     double normalVel;}
\DoxyCodeLine{00286     double x, y;}
\DoxyCodeLine{00287 \#if DIM == 3}
\DoxyCodeLine{00288     double z;}
\DoxyCodeLine{00289 \#endif}
\DoxyCodeLine{00290 }
\DoxyCodeLine{00291 }
\DoxyCodeLine{00292 /* for NO\_SLIP\_BOUNDARY\_TYPE, we stored i}
\DoxyCodeLine{00293    for FREE\_SLIP\_BOUNDARY\_TYPE, we stored -\/i see function insertGhostParticles() below */}
\DoxyCodeLine{00294     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00295     /* loop over all ghost particles */}
\DoxyCodeLine{00296     for (i = numRealParticles + threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i +=inc) \{}
\DoxyCodeLine{00297         /* the index of the corresponding real particle shifted by 1 (since we need the sign) */}
\DoxyCodeLine{00298         idx = p.real\_partner[i];}
\DoxyCodeLine{00299         if (idx < 0) \{}
\DoxyCodeLine{00300             pidx = -\/idx;}
\DoxyCodeLine{00301         \} else \{ }
\DoxyCodeLine{00302             pidx = idx;}
\DoxyCodeLine{00303         \}}
\DoxyCodeLine{00304         pidx -\/= 1;}
\DoxyCodeLine{00305 }
\DoxyCodeLine{00306         //mirror particle}
\DoxyCodeLine{00307         p.cs[i] = p.cs[pidx];}
\DoxyCodeLine{00308         p.p[i] = p.p[pidx];}
\DoxyCodeLine{00309         p.e[i] = p.e[pidx];}
\DoxyCodeLine{00310         p.rho[i] = p.rho[pidx];}
\DoxyCodeLine{00311 \#if SOLID}
\DoxyCodeLine{00312         /* set deviatoric stress tensor depending on boundary type */}
\DoxyCodeLine{00313         if (idx > 0) \{ /* NO\_SLIP\_BOUNDARY */ }
\DoxyCodeLine{00314             for (a = 0; a < DIM; a++) \{}
\DoxyCodeLine{00315                 for (b = 0; b < DIM; b++) \{}
\DoxyCodeLine{00316                     p.S[i*DIM*DIM+a*DIM+b] = p.S[pidx*DIM*DIM+a*DIM+b];}
\DoxyCodeLine{00317                 \}}
\DoxyCodeLine{00318             \}}
\DoxyCodeLine{00319         \} else if (idx < 0) \{ /* FREE\_SLIP\_BOUNDARY */}
\DoxyCodeLine{00320             for (a = 0; a < DIM; a++) \{}
\DoxyCodeLine{00321                 for (b = 0; b < DIM; b++) \{}
\DoxyCodeLine{00322                     p.S[i*DIM*DIM+a*DIM+b] = -\/p.S[pidx*DIM*DIM+a*DIM+b];}
\DoxyCodeLine{00323                 \}}
\DoxyCodeLine{00324                 if (matEOS[p.materialId[i]] == EOS\_TYPE\_REGOLITH) \{}
\DoxyCodeLine{00325                     p.S[i*DIM*DIM+a*DIM+a] *= -\/1;}
\DoxyCodeLine{00326                 \}}
\DoxyCodeLine{00327             \}}
\DoxyCodeLine{00328         \} else \{}
\DoxyCodeLine{00329             printf("{}Error, cannot happen. Go away!\(\backslash\)n"{});}
\DoxyCodeLine{00330             assert(false);}
\DoxyCodeLine{00331         \}}
\DoxyCodeLine{00332 \#endif}
\DoxyCodeLine{00333 }
\DoxyCodeLine{00334 }
\DoxyCodeLine{00335     \}}
\DoxyCodeLine{00336 \}}
\DoxyCodeLine{00337 }
\DoxyCodeLine{00338 /* sets the location, mass, sml for the ghost particles */}
\DoxyCodeLine{00339 \_\_global\_\_ void insertGhostParticles()}
\DoxyCodeLine{00340 \{}
\DoxyCodeLine{00341     //call with only one block}
\DoxyCodeLine{00342     int i, inc, k;}
\DoxyCodeLine{00343     volatile int idx;}
\DoxyCodeLine{00344 \#if SOLID}
\DoxyCodeLine{00345     int a, b;}
\DoxyCodeLine{00346 \#endif}
\DoxyCodeLine{00347     double sml;}
\DoxyCodeLine{00348     double distance;}
\DoxyCodeLine{00349     double normalVel;}
\DoxyCodeLine{00350     double x, y;}
\DoxyCodeLine{00351 }
\DoxyCodeLine{00352 \#if DIM == 3}
\DoxyCodeLine{00353     double z;}
\DoxyCodeLine{00354 \#endif}
\DoxyCodeLine{00355     //boundary type: 0 = no slip, 1 = free slip}
\DoxyCodeLine{00356     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00357     for (k = 0; k < numWalls; k++) \{}
\DoxyCodeLine{00358         \_\_syncthreads();}
\DoxyCodeLine{00359         int currentNumParticles = numParticles;}
\DoxyCodeLine{00360         for (i = threadIdx.x + blockIdx.x * blockDim.x; i < currentNumParticles; i += inc) \{}
\DoxyCodeLine{00361             double sml;}
\DoxyCodeLine{00362             sml = p.h[i];}
\DoxyCodeLine{00363 }
\DoxyCodeLine{00364             x = p.x[i];}
\DoxyCodeLine{00365             y = p.y[i];}
\DoxyCodeLine{00366 \#if DIM == 3 }
\DoxyCodeLine{00367             z = p.z[i];}
\DoxyCodeLine{00368 \#endif}
\DoxyCodeLine{00369 }
\DoxyCodeLine{00370 }
\DoxyCodeLine{00371             //get distance to wall}
\DoxyCodeLine{00372             distance = x*nx[k] + y*ny[k]-\/d[k];}
\DoxyCodeLine{00373 \#if DIM == 3}
\DoxyCodeLine{00374             distance += z*nz[k];}
\DoxyCodeLine{00375 \#endif}
\DoxyCodeLine{00376 }
\DoxyCodeLine{00377 }
\DoxyCodeLine{00378             //if distance small enough}
\DoxyCodeLine{00379             if (fabs(distance) <= sml/2.0) \{}
\DoxyCodeLine{00380 }
\DoxyCodeLine{00381                 //atomic read and increment of numParticles}
\DoxyCodeLine{00382                 idx = atomicAdd(\&numParticles, 1);}
\DoxyCodeLine{00383                 assert(idx < maxNumParticles);}
\DoxyCodeLine{00384 }
\DoxyCodeLine{00385 \#if 1 // moved to extra function!}
\DoxyCodeLine{00386                 //mirror particle}
\DoxyCodeLine{00387 \#if (VARIABLE\_SML || INTEGRATE\_SML || DEAL\_WITH\_TOO\_MANY\_INTERACTIONS)}
\DoxyCodeLine{00388                 p.h[idx] = sml;}
\DoxyCodeLine{00389 \#endif}
\DoxyCodeLine{00390                 p.noi[idx] = p.noi[i];}
\DoxyCodeLine{00391                 p.cs[idx] = p.cs[i];}
\DoxyCodeLine{00392                 p.depth[idx] = p.depth[i];}
\DoxyCodeLine{00393                 p.p[idx] = p.p[i];}
\DoxyCodeLine{00394               //  p.e[idx] = p.e[i];}
\DoxyCodeLine{00395                 p.materialId[idx] = p.materialId[i];}
\DoxyCodeLine{00396 }
\DoxyCodeLine{00397                 p.m[idx] = p.m[i];}
\DoxyCodeLine{00398                 p.rho[idx] = p.rho[i];}
\DoxyCodeLine{00399 \#endif}
\DoxyCodeLine{00400 }
\DoxyCodeLine{00401                 /* set location of ghost particle */}
\DoxyCodeLine{00402                 p.x[idx] = x -\/ 2*distance*nx[k];}
\DoxyCodeLine{00403                 p.y[idx] = y -\/ 2*distance*ny[k];}
\DoxyCodeLine{00404 \#if DIM == 3}
\DoxyCodeLine{00405                 p.z[idx] = z -\/ 2*distance*nz[k];}
\DoxyCodeLine{00406 \#endif}
\DoxyCodeLine{00407                 /* remember the real particle where the ghost particle}
\DoxyCodeLine{00408                    originates from */}
\DoxyCodeLine{00409                 /* for NO\_SLIP\_BOUNDARY\_TYPE, we store i}
\DoxyCodeLine{00410                    for FREE\_SLIP\_BOUNDARY\_TYPE, we store -\/i */}
\DoxyCodeLine{00411 \#if 1}
\DoxyCodeLine{00412                 if (boundaryType[k] == NO\_SLIP\_BOUNDARY\_TYPE) \{}
\DoxyCodeLine{00413                     p.real\_partner[idx] = i+1;}
\DoxyCodeLine{00414                 \} else if (boundaryType[k] == FREE\_SLIP\_BOUNDARY\_TYPE) \{}
\DoxyCodeLine{00415                     p.real\_partner[idx] = -\/i-\/1;}
\DoxyCodeLine{00416                 \} else \{}
\DoxyCodeLine{00417                     printf("{}Error: no such boundary type for particle.\(\backslash\)n"{});}
\DoxyCodeLine{00418                     assert(false);}
\DoxyCodeLine{00419                 \}}
\DoxyCodeLine{00420 \#endif}
\DoxyCodeLine{00421                 /* set mass and material type and sml */}
\DoxyCodeLine{00422                 p.h[idx] = sml;}
\DoxyCodeLine{00423                 p.materialId[idx] = p.materialId[i];}
\DoxyCodeLine{00424 }
\DoxyCodeLine{00425                 /* all other quantities are set in function setQuantitiesGhostParticles() */}
\DoxyCodeLine{00426                 if (boundaryType[k] == NO\_SLIP\_BOUNDARY\_TYPE) \{}
\DoxyCodeLine{00427                     //free slip boundary}
\DoxyCodeLine{00428                     p.vx[idx] = -\/p.vx[i];}
\DoxyCodeLine{00429 \#if DIM > 1}
\DoxyCodeLine{00430                     p.vy[idx] = -\/p.vy[i];}
\DoxyCodeLine{00431 \#if DIM == 3}
\DoxyCodeLine{00432                     p.vz[idx] = -\/p.vz[i];}
\DoxyCodeLine{00433 \#endif}
\DoxyCodeLine{00434 \#endif}
\DoxyCodeLine{00435 \#if 0}
\DoxyCodeLine{00436 \#if SOLID}
\DoxyCodeLine{00437                     for (a = 0; a < DIM; a++) \{}
\DoxyCodeLine{00438                         for (b = 0; b < DIM; b++) \{}
\DoxyCodeLine{00439                             p.S[idx*DIM*DIM+a*DIM+b] = p.S[i*DIM*DIM+a*DIM+b];}
\DoxyCodeLine{00440                         \}}
\DoxyCodeLine{00441                     \}}
\DoxyCodeLine{00442 \#endif}
\DoxyCodeLine{00443 \#endif}
\DoxyCodeLine{00444 }
\DoxyCodeLine{00445                 \} else if (boundaryType[k] == FREE\_SLIP\_BOUNDARY\_TYPE) \{}
\DoxyCodeLine{00446                     //free slip boundary}
\DoxyCodeLine{00447 }
\DoxyCodeLine{00448                     normalVel = nx[k]*p.vx[i];}
\DoxyCodeLine{00449 \#if DIM > 1}
\DoxyCodeLine{00450                     normalVel += ny[k]*p.vy[i];}
\DoxyCodeLine{00451 \#endif}
\DoxyCodeLine{00452 \#if DIM == 3}
\DoxyCodeLine{00453                     normalVel += nz[k]*p.vz[i];}
\DoxyCodeLine{00454 \#endif}
\DoxyCodeLine{00455 }
\DoxyCodeLine{00456                     p.vx[idx] = p.vx[i] -\/ 2*normalVel*nx[k];}
\DoxyCodeLine{00457 \#if DIM > 1}
\DoxyCodeLine{00458                     p.vy[idx] = p.vy[i] -\/ 2*normalVel*ny[k];}
\DoxyCodeLine{00459 \#if DIM == 3}
\DoxyCodeLine{00460                     p.vz[idx] = p.vz[i] -\/ 2*normalVel*nz[k];}
\DoxyCodeLine{00461 \#endif}
\DoxyCodeLine{00462 \#endif}
\DoxyCodeLine{00463 \#if 0}
\DoxyCodeLine{00464 \#if SOLID}
\DoxyCodeLine{00465                     for (a = 0; a < DIM; a++) \{}
\DoxyCodeLine{00466                         for (b = 0; b < DIM; b++) \{}
\DoxyCodeLine{00467                             p.S[idx*DIM*DIM+a*DIM+b] = -\/p.S[i*DIM*DIM+a*DIM+b];}
\DoxyCodeLine{00468                         \}}
\DoxyCodeLine{00469                         p.S[idx*DIM*DIM+a*DIM+a] *= -\/1;}
\DoxyCodeLine{00470                     \}}
\DoxyCodeLine{00471 \#endif}
\DoxyCodeLine{00472 \#endif}
\DoxyCodeLine{00473                 \}}
\DoxyCodeLine{00474 }
\DoxyCodeLine{00475             \} //end distance if}
\DoxyCodeLine{00476         \} //end particle loop}
\DoxyCodeLine{00477         \_\_syncthreads();}
\DoxyCodeLine{00478     \} //end wall loop}
\DoxyCodeLine{00479     if (threadIdx.x + blockIdx.x*blockDim.x == 0) \{}
\DoxyCodeLine{00480         printf("{}number of particles after inserting: \%d\(\backslash\)t\(\backslash\)t"{}, numParticles);}
\DoxyCodeLine{00481         printf("{}added \%d particles\(\backslash\)n"{}, numParticles -\/ numRealParticles);}
\DoxyCodeLine{00482     \}}
\DoxyCodeLine{00483 \}}
\DoxyCodeLine{00484 \#endif}
\DoxyCodeLine{00485 }
\DoxyCodeLine{00486 }
\DoxyCodeLine{00487 /* this function places the brushes according to their rotation speed */}
\DoxyCodeLine{00488 \_\_global\_\_ void BoundaryConditionsBrushesBefore(int *interactions) }
\DoxyCodeLine{00489 \{}
\DoxyCodeLine{00490 \#if 0}
\DoxyCodeLine{00491 \#warning: brushes on}
\DoxyCodeLine{00492     register int i, inc;}
\DoxyCodeLine{00493     int matId, d, e;}
\DoxyCodeLine{00494     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00495 }
\DoxyCodeLine{00496     // revolutions per minute}
\DoxyCodeLine{00497     const double rpm = 100;}
\DoxyCodeLine{00498     const double omega = rpm * 2 * M\_PI / 60;}
\DoxyCodeLine{00499 }
\DoxyCodeLine{00500     // the offset, this is printed out by brush3D.py}
\DoxyCodeLine{00501     const double yoff = 0.0523512;}
\DoxyCodeLine{00502 }
\DoxyCodeLine{00503     double phi0 = 0;}
\DoxyCodeLine{00504     double phi = 0;}
\DoxyCodeLine{00505     double phit = 0; // no, it's really a p}
\DoxyCodeLine{00506     double r = 0;}
\DoxyCodeLine{00507     double y = 0;}
\DoxyCodeLine{00508     double vz = -\/1e-\/2; // speed of the brushes in z direction }
\DoxyCodeLine{00509     double zoff = 0;}
\DoxyCodeLine{00510     double zoffangle = 0.170125; // the z-\/offset, this is printed out by brush3D.py}
\DoxyCodeLine{00511     double zmax = -\/0.02; ; // = 1/6 brushdiameter from brush3D.py}
\DoxyCodeLine{00512     double myz = 0.0;}
\DoxyCodeLine{00513 }
\DoxyCodeLine{00514     zoff = substep\_currentTimeD * vz;}
\DoxyCodeLine{00515     if (zoff < zmax) }
\DoxyCodeLine{00516         zoff = zmax;}
\DoxyCodeLine{00517 }
\DoxyCodeLine{00518     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{00519             matId = p.materialId[i];}
\DoxyCodeLine{00520             if (matId > 1) \{}
\DoxyCodeLine{00521             // new rotating angle}
\DoxyCodeLine{00522                 phi = omega*substep\_currentTimeD;}
\DoxyCodeLine{00523                 // original angle}
\DoxyCodeLine{00524                 // new angle}
\DoxyCodeLine{00525 // brush left (y<0) is matId = 1 and rotates counterclockwise}
\DoxyCodeLine{00526 // brush right (y>0) is matId = 2 and rotates clockwise}
\DoxyCodeLine{00527 // rotation is around x axis}
\DoxyCodeLine{00528                 myz = p.z0[i] -\/ zoffangle;}
\DoxyCodeLine{00529                 if (matId == 2) \{}
\DoxyCodeLine{00530                     y = p.y0[i] + yoff;}
\DoxyCodeLine{00531                     phi0 = atan2(myz,y);}
\DoxyCodeLine{00532                     phit = phi + phi0;}
\DoxyCodeLine{00533                     r = myz * myz + y*y; }
\DoxyCodeLine{00534                     r = sqrt(r);}
\DoxyCodeLine{00535                     p.y[i] = r * cos(phit) -\/ yoff;}
\DoxyCodeLine{00536                     // coordinates }
\DoxyCodeLine{00537                     p.z[i] = r * sin(phit) + zoff + zoffangle;}
\DoxyCodeLine{00538                     p.x[i] = p.x0[i];}
\DoxyCodeLine{00539 }
\DoxyCodeLine{00540                     // velocity}
\DoxyCodeLine{00541                     p.vx[i] = 0.0;}
\DoxyCodeLine{00542                     p.vy[i] = -\/omega * r * sin(phit);}
\DoxyCodeLine{00543                     p.vz[i] = omega * r * cos(phit);}
\DoxyCodeLine{00544 }
\DoxyCodeLine{00545                 \} else if (matId == 3) \{}
\DoxyCodeLine{00546                     y = p.y0[i] -\/ yoff;}
\DoxyCodeLine{00547                     phi0 = atan2(myz,y);}
\DoxyCodeLine{00548                     phit = phi0 -\/ phi;}
\DoxyCodeLine{00549                     r = myz * myz + y*y; }
\DoxyCodeLine{00550                     r = sqrt(r);}
\DoxyCodeLine{00551                     p.y[i] = r * cos(phit) + yoff;}
\DoxyCodeLine{00552                     // coordinates }
\DoxyCodeLine{00553                     p.z[i] = r * sin(phit) + zoff + zoffangle;}
\DoxyCodeLine{00554                     p.x[i] = p.x0[i];}
\DoxyCodeLine{00555 }
\DoxyCodeLine{00556                     // velocity}
\DoxyCodeLine{00557                     p.vx[i] = 0.0;}
\DoxyCodeLine{00558                     p.vy[i] = omega * r * sin(phit);}
\DoxyCodeLine{00559                     p.vz[i] = -\/omega * r * cos(phit);}
\DoxyCodeLine{00560                 \} }
\DoxyCodeLine{00561             \}}
\DoxyCodeLine{00562     \}}
\DoxyCodeLine{00563 \#endif}
\DoxyCodeLine{00564 \}}
\DoxyCodeLine{00565 }
\DoxyCodeLine{00566 }
\DoxyCodeLine{00567 \_\_global\_\_ void BoundaryConditionsBrushesAfter(int *interactions) }
\DoxyCodeLine{00568 \{}
\DoxyCodeLine{00569 \#if 0}
\DoxyCodeLine{00570 \#warning: brushes on}
\DoxyCodeLine{00571     register int i, inc;}
\DoxyCodeLine{00572     int matId, d, e;}
\DoxyCodeLine{00573     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00574     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{00575             matId = p.materialId[i];}
\DoxyCodeLine{00576             if (matId > 0) \{}
\DoxyCodeLine{00577                 p.ax[i] = 0;}
\DoxyCodeLine{00578                 p.ay[i] = 0;}
\DoxyCodeLine{00579                 p.dxdt[i] = 0;}
\DoxyCodeLine{00580                 p.dydt[i] = 0;}
\DoxyCodeLine{00581                 p.vx[i] = 0;}
\DoxyCodeLine{00582                 p.vy[i] = 0;}
\DoxyCodeLine{00583                 for (d = 0; d < DIM*DIM; d++) \{}
\DoxyCodeLine{00584                     p.dSdt[i*DIM*DIM + d] = 0;}
\DoxyCodeLine{00585                 \}}
\DoxyCodeLine{00586                 p.drhodt[i] = 0;}
\DoxyCodeLine{00587             \} else \{}
\DoxyCodeLine{00588             \}}
\DoxyCodeLine{00589     \}}
\DoxyCodeLine{00590 \#endif}
\DoxyCodeLine{00591 \}}
\DoxyCodeLine{00592 }
\DoxyCodeLine{00593 }
\DoxyCodeLine{00594 }
\DoxyCodeLine{00595 \_\_global\_\_ void BoundaryForce(int *interactions) }
\DoxyCodeLine{00596 \{}
\DoxyCodeLine{00597 \#if 0}
\DoxyCodeLine{00598 \#warning: brushes on}
\DoxyCodeLine{00599     register int i, inc;}
\DoxyCodeLine{00600     int matId, d, e, matIdj;}
\DoxyCodeLine{00601     int k, j, numInteractions;}
\DoxyCodeLine{00602     double distance;}
\DoxyCodeLine{00603     double ljf = 0;}
\DoxyCodeLine{00604     // D is somehow related to the largest velocity}
\DoxyCodeLine{00605     double D = 10.0;}
\DoxyCodeLine{00606     const double tiny = 1e-\/6;}
\DoxyCodeLine{00607     const double r0 = 0.022574999999999998;}
\DoxyCodeLine{00608     double dx, dy, dz;}
\DoxyCodeLine{00609     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00610     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{00611             matId = p.materialId[i];}
\DoxyCodeLine{00612             // only for regolith with matId == 0}
\DoxyCodeLine{00613             if (matId > 0)}
\DoxyCodeLine{00614                 continue;}
\DoxyCodeLine{00615             numInteractions = p.noi[i];}
\DoxyCodeLine{00616             for (k = 0; k < numInteractions; k++) \{}
\DoxyCodeLine{00617             // the interaction partner}
\DoxyCodeLine{00618                 j = interactions[i * MAX\_NUM\_INTERACTIONS + k];}
\DoxyCodeLine{00619 }
\DoxyCodeLine{00620                 // check if interaction partner is boundary\_particle and if not, continue}
\DoxyCodeLine{00621                 matIdj = p.materialId[j];}
\DoxyCodeLine{00622                 if (matIdj == BOUNDARY\_PARTICLE\_ID) \{}
\DoxyCodeLine{00623                 // calculate lennard jones force}
\DoxyCodeLine{00624                     dx = p.x[i] -\/ p.x[j];}
\DoxyCodeLine{00625                     dy = p.y[i] -\/ p.y[j];}
\DoxyCodeLine{00626                     dz = 0.0;}
\DoxyCodeLine{00627 \#if DIM > 2}
\DoxyCodeLine{00628                     dz = p.z[i] -\/ p.z[j];}
\DoxyCodeLine{00629 \#endif}
\DoxyCodeLine{00630                     distance = dx*dx + dy*dy + dz*dz;}
\DoxyCodeLine{00631                     distance += tiny;}
\DoxyCodeLine{00632                     distance = sqrt(distance);}
\DoxyCodeLine{00633                     if (r0/distance < 1) \{}
\DoxyCodeLine{00634                         ljf =  D * (pow(r0/distance, 12) -\/ pow(r0/distance, 6)) * pow(distance, -\/2);}
\DoxyCodeLine{00635                         p.ax[i] -\/= ljf*dx;}
\DoxyCodeLine{00636                         p.ay[i] -\/= ljf*dy;}
\DoxyCodeLine{00637 \#if DIM > 2}
\DoxyCodeLine{00638                         p.az[i] -\/= ljf*dz;}
\DoxyCodeLine{00639 \#endif}
\DoxyCodeLine{00640                     \} }
\DoxyCodeLine{00641                 \} }
\DoxyCodeLine{00642 }
\DoxyCodeLine{00643 \#if 0            }
\DoxyCodeLine{00644                 // check if interaction partner is brush and if not, continue}
\DoxyCodeLine{00645                 matIdj = p.materialId[j];}
\DoxyCodeLine{00646                 if (matIdj == 1 || matIdj == 2) \{}
\DoxyCodeLine{00647                 // calculate lennard jones force}
\DoxyCodeLine{00648                     dx = p.x[i] -\/ p.x[j];}
\DoxyCodeLine{00649                     dy = p.y[i] -\/ p.y[j];}
\DoxyCodeLine{00650                     dz = p.z[i] -\/ p.z[j];}
\DoxyCodeLine{00651                     distance = dx*dx + dy*dy + dz*dz;}
\DoxyCodeLine{00652                     distance += tiny;}
\DoxyCodeLine{00653                     distance = sqrt(distance);}
\DoxyCodeLine{00654                     if (r0/distance < 1) \{}
\DoxyCodeLine{00655                         ljf = p.m[i] *  D * (pow(r0/distance, 12) -\/ pow(r0/distance, 4)) * pow(distance, -\/2);}
\DoxyCodeLine{00656                         p.ax[i] += ljf*dx;}
\DoxyCodeLine{00657                         p.ay[i] += ljf*dy;}
\DoxyCodeLine{00658                         p.az[i] += ljf*dz;}
\DoxyCodeLine{00659                     \} }
\DoxyCodeLine{00660                 \} }
\DoxyCodeLine{00661 \#endif}
\DoxyCodeLine{00662             \}}
\DoxyCodeLine{00663     \}}
\DoxyCodeLine{00664 \#endif}
\DoxyCodeLine{00665 \}}

\end{DoxyCode}
