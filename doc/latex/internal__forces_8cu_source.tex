\hypertarget{internal__forces_8cu_source}{}\doxysection{internal\+\_\+forces.\+cu}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 /**}
\DoxyCodeLine{00002  * @author      Christoph Schaefer, Oliver Wandel and Thomas I. Maindl}
\DoxyCodeLine{00003  *}
\DoxyCodeLine{00004  * @section     LICENSE}
\DoxyCodeLine{00005  * Copyright (c) 2019 Christoph Schaefer}
\DoxyCodeLine{00006  *}
\DoxyCodeLine{00007  * This file is part of miluphcuda.}
\DoxyCodeLine{00008  *}
\DoxyCodeLine{00009  * miluphcuda is free software: you can redistribute it and/or modify}
\DoxyCodeLine{00010  * it under the terms of the GNU General Public License as published by}
\DoxyCodeLine{00011  * the Free Software Foundation, either version 3 of the License, or}
\DoxyCodeLine{00012  * (at your option) any later version.}
\DoxyCodeLine{00013  *}
\DoxyCodeLine{00014  * miluphcuda is distributed in the hope that it will be useful,}
\DoxyCodeLine{00015  * but WITHOUT ANY WARRANTY; without even the implied warranty of}
\DoxyCodeLine{00016  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
\DoxyCodeLine{00017  * GNU General Public License for more details.}
\DoxyCodeLine{00018  *}
\DoxyCodeLine{00019  * You should have received a copy of the GNU General Public License}
\DoxyCodeLine{00020  * along with miluphcuda.  If not, see <http://www.gnu.org/licenses/>.}
\DoxyCodeLine{00021  *}
\DoxyCodeLine{00022  */}
\DoxyCodeLine{00023 }
\DoxyCodeLine{00024 \#include "{}miluph.h"{}}
\DoxyCodeLine{00025 \#include "{}timeintegration.h"{}}
\DoxyCodeLine{00026 \#include "{}parameter.h"{}}
\DoxyCodeLine{00027 \#include "{}internal\_forces.h"{}}
\DoxyCodeLine{00028 \#include "{}boundary.h"{}}
\DoxyCodeLine{00029 \#include "{}pressure.h"{}}
\DoxyCodeLine{00030 \#include "{}linalg.h"{}}
\DoxyCodeLine{00031 \#include "{}viscosity.h"{}}
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033 }
\DoxyCodeLine{00034 }
\DoxyCodeLine{00035 }
\DoxyCodeLine{00036 extern \_\_constant\_\_ int isRelaxationRun;}
\DoxyCodeLine{00037 extern \_\_device\_\_ SPH\_kernel kernel;}
\DoxyCodeLine{00038 }
\DoxyCodeLine{00039 //\_\_launch\_bounds\_\_(64, 16)}
\DoxyCodeLine{00040 \_\_global\_\_ void internalForces(int *interactions) \{}
\DoxyCodeLine{00041     int i, k, inc, j, numInteractions;}
\DoxyCodeLine{00042     int f, kk;}
\DoxyCodeLine{00043 }
\DoxyCodeLine{00044     double W;}
\DoxyCodeLine{00045     double tmp, densityi, densityj;}
\DoxyCodeLine{00046     double ax, ay;}
\DoxyCodeLine{00047     double sml;}
\DoxyCodeLine{00048 \#if DIM == 3}
\DoxyCodeLine{00049     double az;}
\DoxyCodeLine{00050 \#endif}
\DoxyCodeLine{00051 }
\DoxyCodeLine{00052     int matId;}
\DoxyCodeLine{00053     int matIdj;}
\DoxyCodeLine{00054     double sml1;}
\DoxyCodeLine{00055 }
\DoxyCodeLine{00056     double vxj, vyj, vzj, Sj[DIM*DIM];}
\DoxyCodeLine{00057 }
\DoxyCodeLine{00058 \#if FRAGMENTATION}
\DoxyCodeLine{00059     double di;}
\DoxyCodeLine{00060 \#endif}
\DoxyCodeLine{00061 }
\DoxyCodeLine{00062 \#if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00063     double vr; // vr = v\_ij * r\_ij}
\DoxyCodeLine{00064     double rr;}
\DoxyCodeLine{00065     double rhobar; // rhobar = 0.5*(rho\_i + rho\_j)}
\DoxyCodeLine{00066     double mu;}
\DoxyCodeLine{00067     double muijmax;}
\DoxyCodeLine{00068     double smooth;}
\DoxyCodeLine{00069     double csbar;}
\DoxyCodeLine{00070     double alpha, beta;}
\DoxyCodeLine{00071 }
\DoxyCodeLine{00072 \#if BALSARA\_SWITCH}
\DoxyCodeLine{00073     double fi, fj;}
\DoxyCodeLine{00074     double curli, curlj;}
\DoxyCodeLine{00075     const double eps\_balsara = 1e-\/4;}
\DoxyCodeLine{00076 \#endif}
\DoxyCodeLine{00077 \#endif}
\DoxyCodeLine{00078 }
\DoxyCodeLine{00079 \#if ARTIFICIAL\_STRESS}
\DoxyCodeLine{00080     double artf = 0;}
\DoxyCodeLine{00081 \#endif}
\DoxyCodeLine{00082 }
\DoxyCodeLine{00083     int d;}
\DoxyCodeLine{00084     int dd;}
\DoxyCodeLine{00085     int e;}
\DoxyCodeLine{00086 \#if SOLID}
\DoxyCodeLine{00087     double sigma\_i[DIM][DIM], sigma\_j[DIM][DIM];}
\DoxyCodeLine{00088     double edot[DIM][DIM], rdot[DIM][DIM];}
\DoxyCodeLine{00089     double S\_i[DIM][DIM];}
\DoxyCodeLine{00090     double sqrt\_J2, I1, alpha\_phi, kc;}
\DoxyCodeLine{00091     double lambda\_dot, tr\_edot;}
\DoxyCodeLine{00092 \#endif}
\DoxyCodeLine{00093 }
\DoxyCodeLine{00094     double dr[DIM];}
\DoxyCodeLine{00095     double dv[DIM];}
\DoxyCodeLine{00096 }
\DoxyCodeLine{00097     double x, vx;}
\DoxyCodeLine{00098 \#if DIM > 1}
\DoxyCodeLine{00099     double y, vy;}
\DoxyCodeLine{00100 \#endif}
\DoxyCodeLine{00101     int boundia = 0;}
\DoxyCodeLine{00102 \#if DIM == 3}
\DoxyCodeLine{00103     double z, vz;}
\DoxyCodeLine{00104 \#endif}
\DoxyCodeLine{00105 }
\DoxyCodeLine{00106     double drhodt;}
\DoxyCodeLine{00107 }
\DoxyCodeLine{00108 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00109     double dedt;}
\DoxyCodeLine{00110 \#endif}
\DoxyCodeLine{00111 }
\DoxyCodeLine{00112     double dvx;}
\DoxyCodeLine{00113 \#if DIM > 1}
\DoxyCodeLine{00114     double dvy;}
\DoxyCodeLine{00115 \#endif}
\DoxyCodeLine{00116 \#if DIM > 2}
\DoxyCodeLine{00117     double dvz;}
\DoxyCodeLine{00118 \#endif}
\DoxyCodeLine{00119 }
\DoxyCodeLine{00120 \#if NAVIER\_STOKES}
\DoxyCodeLine{00121     double eta;}
\DoxyCodeLine{00122 \#endif }
\DoxyCodeLine{00123 }
\DoxyCodeLine{00124     double vvnablaW;}
\DoxyCodeLine{00125     double dWdr;}
\DoxyCodeLine{00126     double dWdx[DIM];}
\DoxyCodeLine{00127     double pij = 0;}
\DoxyCodeLine{00128     double pj = 0;}
\DoxyCodeLine{00129     double r;}
\DoxyCodeLine{00130     double accels[DIM];}
\DoxyCodeLine{00131     double accelsj[DIM];}
\DoxyCodeLine{00132     double accelshearj[DIM];}
\DoxyCodeLine{00133 }
\DoxyCodeLine{00134     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00135     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numRealParticles; i += inc) \{}
\DoxyCodeLine{00136 }
\DoxyCodeLine{00137         matId = p\_rhs.materialId[i];}
\DoxyCodeLine{00138         //do nothing for boundary particles}
\DoxyCodeLine{00139         if (matId == BOUNDARY\_PARTICLE\_ID) continue;}
\DoxyCodeLine{00140         if (EOS\_TYPE\_IGNORE == matEOS[p\_rhs.materialId[i]] || matId == EOS\_TYPE\_IGNORE) \{}
\DoxyCodeLine{00141                 continue;}
\DoxyCodeLine{00142         \}}
\DoxyCodeLine{00143 }
\DoxyCodeLine{00144         numInteractions = p.noi[i];}
\DoxyCodeLine{00145 }
\DoxyCodeLine{00146         ax = 0;}
\DoxyCodeLine{00147         ay = 0;}
\DoxyCodeLine{00148 \#if DIM > 2}
\DoxyCodeLine{00149         az = 0;}
\DoxyCodeLine{00150 \#endif}
\DoxyCodeLine{00151 \#if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00152         alpha = matAlpha[matId];}
\DoxyCodeLine{00153         beta = matBeta[matId];}
\DoxyCodeLine{00154         muijmax = 0;}
\DoxyCodeLine{00155 \#endif}
\DoxyCodeLine{00156         sml1 = p.h[i];}
\DoxyCodeLine{00157 }
\DoxyCodeLine{00158         densityi = p.rho[i];}
\DoxyCodeLine{00159         drhodt = 0;}
\DoxyCodeLine{00160 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00161         dedt = 0;}
\DoxyCodeLine{00162 \#endif}
\DoxyCodeLine{00163 \#if INTEGRATE\_SML}
\DoxyCodeLine{00164         p.dhdt[i] = 0.0;}
\DoxyCodeLine{00165 \#endif}
\DoxyCodeLine{00166 }
\DoxyCodeLine{00167 \#if SOLID}
\DoxyCodeLine{00168         for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00169             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00170                 // set rotation rate and strain rate tensor stuff to zero}
\DoxyCodeLine{00171                 edot[d][e] = 0.0;}
\DoxyCodeLine{00172                 rdot[d][e] = 0.0;}
\DoxyCodeLine{00173             \}}
\DoxyCodeLine{00174         \}}
\DoxyCodeLine{00175 }
\DoxyCodeLine{00176 \#endif}
\DoxyCodeLine{00177         for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00178             accels[d] = 0.0;}
\DoxyCodeLine{00179             accelsj[d] = 0.0;}
\DoxyCodeLine{00180             accelshearj[d] = 0.0;}
\DoxyCodeLine{00181         \}}
\DoxyCodeLine{00182         sml = p.h[i];}
\DoxyCodeLine{00183 }
\DoxyCodeLine{00184 }
\DoxyCodeLine{00185 \#if FRAGMENTATION}
\DoxyCodeLine{00186         di = p.damage\_total[i];}
\DoxyCodeLine{00187         if (di < 0) di = 0;}
\DoxyCodeLine{00188         if (di > 1) di = 1;}
\DoxyCodeLine{00189 \#endif}
\DoxyCodeLine{00190 }
\DoxyCodeLine{00191         x = p.x[i];}
\DoxyCodeLine{00192 \#if DIM > 1}
\DoxyCodeLine{00193         y = p.y[i];}
\DoxyCodeLine{00194 \#if DIM > 2}
\DoxyCodeLine{00195         z = p.z[i];}
\DoxyCodeLine{00196 \#endif}
\DoxyCodeLine{00197 \#endif}
\DoxyCodeLine{00198         vx = p.vx[i];}
\DoxyCodeLine{00199 \#if DIM > 1}
\DoxyCodeLine{00200         vy = p.vy[i];}
\DoxyCodeLine{00201 \#if DIM > 2}
\DoxyCodeLine{00202         vz = p.vz[i];}
\DoxyCodeLine{00203 \#endif}
\DoxyCodeLine{00204 \#endif}
\DoxyCodeLine{00205 }
\DoxyCodeLine{00206 }
\DoxyCodeLine{00207 \#if 1}
\DoxyCodeLine{00208         p.dxdt[i] = 0;}
\DoxyCodeLine{00209         p.ax[i] = 0;}
\DoxyCodeLine{00210 \#if DIM > 1}
\DoxyCodeLine{00211         p.dydt[i] = 0;}
\DoxyCodeLine{00212         p.ay[i] = 0;}
\DoxyCodeLine{00213 \#if DIM > 2}
\DoxyCodeLine{00214         p.dzdt[i] = 0;}
\DoxyCodeLine{00215         p.az[i] = 0;}
\DoxyCodeLine{00216 \#endif}
\DoxyCodeLine{00217 \#endif}
\DoxyCodeLine{00218 \#if SOLID}
\DoxyCodeLine{00219         for (e = 0; e < DIM*DIM; e++) \{}
\DoxyCodeLine{00220             p.dSdt[i*DIM*DIM+e] = 0.0;}
\DoxyCodeLine{00221         \}}
\DoxyCodeLine{00222 \#endif}
\DoxyCodeLine{00223         p.drhodt[i] = 0.0;}
\DoxyCodeLine{00224 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00225         p.dedt[i] = 0.0;}
\DoxyCodeLine{00226 \#endif}
\DoxyCodeLine{00227 \#if INTEGRATE\_SML}
\DoxyCodeLine{00228         p.dhdt[i] = 0.0;}
\DoxyCodeLine{00229 \#endif}
\DoxyCodeLine{00230 \#if FRAGMENTATION}
\DoxyCodeLine{00231         p.dddt[i] = 0.0;}
\DoxyCodeLine{00232 \# if PALPHA\_POROSITY}
\DoxyCodeLine{00233         p.ddamage\_porjutzidt[i] = 0.0;}
\DoxyCodeLine{00234 \# endif}
\DoxyCodeLine{00235 \#endif}
\DoxyCodeLine{00236 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00237         p.dalphadt[i] = 0.0;}
\DoxyCodeLine{00238 \#endif}
\DoxyCodeLine{00239         // if particle has no interactions continue and set all derivs to zero}
\DoxyCodeLine{00240         // but not the accels (these are handled in the tree for gravity)}
\DoxyCodeLine{00241     if (numInteractions < 1) \{}
\DoxyCodeLine{00242     // finally continue}
\DoxyCodeLine{00243        continue;}
\DoxyCodeLine{00244     \}}
\DoxyCodeLine{00245 \#endif}
\DoxyCodeLine{00246 }
\DoxyCodeLine{00247 \#if BALSARA\_SWITCH}
\DoxyCodeLine{00248         curli = 0;}
\DoxyCodeLine{00249         for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00250             curli += p\_rhs.curlv[i*DIM+d]*p\_rhs.curlv[i*DIM+d];}
\DoxyCodeLine{00251         \}}
\DoxyCodeLine{00252         curli = sqrt(curli);}
\DoxyCodeLine{00253         fi = fabs(p\_rhs.divv[i]) / (fabs(p\_rhs.divv[i]) + curli + eps\_balsara*p.cs[i]/p.h[i]);}
\DoxyCodeLine{00254 \#endif}
\DoxyCodeLine{00255 }
\DoxyCodeLine{00256         // THE MAIN SPH LOOP FOR ALL INTERNAL FORCES}
\DoxyCodeLine{00257         // loop over interaction partners for SPH sums}
\DoxyCodeLine{00258         for (k = 0; k < numInteractions; k++) \{}
\DoxyCodeLine{00259             matIdj = -\/1;}
\DoxyCodeLine{00260             // the interaction partner}
\DoxyCodeLine{00261             j = interactions[i * MAX\_NUM\_INTERACTIONS + k];}
\DoxyCodeLine{00262 }
\DoxyCodeLine{00263             matIdj = p\_rhs.materialId[j];}
\DoxyCodeLine{00264             if (EOS\_TYPE\_IGNORE == matEOS[p\_rhs.materialId[j]] || matIdj == EOS\_TYPE\_IGNORE) \{}
\DoxyCodeLine{00265                 continue;}
\DoxyCodeLine{00266             \}}
\DoxyCodeLine{00267 }
\DoxyCodeLine{00268             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00269                 accelsj[d] = 0.0;}
\DoxyCodeLine{00270             \}}
\DoxyCodeLine{00271 }
\DoxyCodeLine{00272             boundia = 0;}
\DoxyCodeLine{00273             boundia = p\_rhs.materialId[j] == BOUNDARY\_PARTICLE\_ID;}
\DoxyCodeLine{00274             /*}
\DoxyCodeLine{00275              * now, if the interaction partner is a BOUNDARY\_PARTICLE}
\DoxyCodeLine{00276              * we need to determine the correct velocity, pressure and stress}
\DoxyCodeLine{00277              * for it}
\DoxyCodeLine{00278              */}
\DoxyCodeLine{00279 \#if (VARIABLE\_SML || INTEGRATE\_SML || DEAL\_WITH\_TOO\_MANY\_INTERACTIONS)}
\DoxyCodeLine{00280             sml = 0.5*(p.h[i] + p.h[j]);}
\DoxyCodeLine{00281 \#endif}
\DoxyCodeLine{00282             if (boundia) \{}
\DoxyCodeLine{00283                 /* set quantities for boundary particle */}
\DoxyCodeLine{00284                 setQuantitiesFixedVirtualParticles(i, j, \&vxj, \&vyj, \&vzj, \&densityj, \&pj, Sj);}
\DoxyCodeLine{00285             \} else \{ /* no boundary particle, just copy */}
\DoxyCodeLine{00286                 vxj = p.vx[j];}
\DoxyCodeLine{00287 \#if DIM > 1}
\DoxyCodeLine{00288                 vyj = p.vy[j];}
\DoxyCodeLine{00289 \#if DIM > 2}
\DoxyCodeLine{00290                 vzj = p.vz[j];}
\DoxyCodeLine{00291 \#endif}
\DoxyCodeLine{00292 \#endif}
\DoxyCodeLine{00293                 densityj = p.rho[j];}
\DoxyCodeLine{00294                 pj = p.p[j];}
\DoxyCodeLine{00295 \#if SOLID}
\DoxyCodeLine{00296                 for (e = 0; e < DIM*DIM; e++)}
\DoxyCodeLine{00297                     Sj[e] = p.S[j*DIM*DIM+e];}
\DoxyCodeLine{00298 \#endif}
\DoxyCodeLine{00299             \}}
\DoxyCodeLine{00300 }
\DoxyCodeLine{00301             // relative vector}
\DoxyCodeLine{00302             dr[0] = x -\/ p.x[j];}
\DoxyCodeLine{00303 \#if DIM > 1}
\DoxyCodeLine{00304             dr[1] = y -\/ p.y[j];}
\DoxyCodeLine{00305 \#if DIM > 2}
\DoxyCodeLine{00306             dr[2] = z -\/ p.z[j];}
\DoxyCodeLine{00307 \#endif}
\DoxyCodeLine{00308 \#endif}
\DoxyCodeLine{00309             r = 0;}
\DoxyCodeLine{00310             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00311                 r += dr[e]*dr[e];}
\DoxyCodeLine{00312                 dWdx[e] = 0.0;}
\DoxyCodeLine{00313             \}}
\DoxyCodeLine{00314             W = 0.0;}
\DoxyCodeLine{00315             dWdr = 0.0;}
\DoxyCodeLine{00316             r = sqrt(r);}
\DoxyCodeLine{00317 }
\DoxyCodeLine{00318             // get kernel values for this interaction}
\DoxyCodeLine{00319             kernel(\&W, dWdx, \&dWdr, dr, sml);}
\DoxyCodeLine{00320             dv[0] = dvx = vx -\/ vxj;}
\DoxyCodeLine{00321 \#if DIM > 1}
\DoxyCodeLine{00322             dv[1] = dvy = vy -\/ vyj;}
\DoxyCodeLine{00323 \#if DIM > 2}
\DoxyCodeLine{00324             dv[2] = dvz = vz -\/ vzj;}
\DoxyCodeLine{00325 \#endif}
\DoxyCodeLine{00326 \#endif}
\DoxyCodeLine{00327 }
\DoxyCodeLine{00328             vvnablaW = dvx * dWdx[0];}
\DoxyCodeLine{00329 \#if DIM > 1}
\DoxyCodeLine{00330             vvnablaW += dvy * dWdx[1];}
\DoxyCodeLine{00331 \#if DIM > 2}
\DoxyCodeLine{00332             vvnablaW += dvz * dWdx[2];}
\DoxyCodeLine{00333 \#endif}
\DoxyCodeLine{00334 \#endif}
\DoxyCodeLine{00335 }
\DoxyCodeLine{00336 \#if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00337             rr = 0.0;}
\DoxyCodeLine{00338             vr = 0.0;}
\DoxyCodeLine{00339             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00340                 rr += dr[e]*dr[e];}
\DoxyCodeLine{00341                 vr += dv[e]*dr[e];}
\DoxyCodeLine{00342             \}}
\DoxyCodeLine{00343 \#endif}
\DoxyCodeLine{00344 }
\DoxyCodeLine{00345 }
\DoxyCodeLine{00346 \#if SOLID}
\DoxyCodeLine{00347             //get sigma\_i}
\DoxyCodeLine{00348             if (matEOS[matId] != EOS\_TYPE\_REGOLITH) \{}
\DoxyCodeLine{00349                 for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00350                     for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00351                         sigma\_i[d][e] = p\_rhs.sigma[stressIndex(i, d, e)];}
\DoxyCodeLine{00352                     \}}
\DoxyCodeLine{00353                 \}}
\DoxyCodeLine{00354             \} else \{ // EOS type = regolith}
\DoxyCodeLine{00355                 for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00356                     for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00357                         sigma\_i[d][e] = p.S[stressIndex(i, d, e)];}
\DoxyCodeLine{00358                     \}}
\DoxyCodeLine{00359                 \}}
\DoxyCodeLine{00360             \} //material if}
\DoxyCodeLine{00361 }
\DoxyCodeLine{00362             //get sigma\_j}
\DoxyCodeLine{00363             if (matEOS[p\_rhs.materialId[j]] != EOS\_TYPE\_REGOLITH) \{}
\DoxyCodeLine{00364                 for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00365                     for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00366                         sigma\_j[d][e] = p\_rhs.sigma[stressIndex(j, d, e)];}
\DoxyCodeLine{00367                     \}}
\DoxyCodeLine{00368                 \}}
\DoxyCodeLine{00369             \} else \{ // EOS type = regolith}
\DoxyCodeLine{00370                 for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00371                     for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00372                         sigma\_j[d][e] = Sj[DIM*d+e];}
\DoxyCodeLine{00373                     \}}
\DoxyCodeLine{00374                 \}}
\DoxyCodeLine{00375             \} //material if}
\DoxyCodeLine{00376 }
\DoxyCodeLine{00377 \#endif //SOLID}
\DoxyCodeLine{00378 }
\DoxyCodeLine{00379 \#if SOLID}
\DoxyCodeLine{00380             // do calculation of edot and rdot only for real particle interaction partners and not}
\DoxyCodeLine{00381             // for boundary particle interaction partners}
\DoxyCodeLine{00382 }
\DoxyCodeLine{00383             // we do not need this for VISCOUS\_REGOLITH particles since they have}
\DoxyCodeLine{00384             // a given deviatoric stress which is not integrated}
\DoxyCodeLine{00385 }
\DoxyCodeLine{00386             // calculate rotation rate and strain rate}
\DoxyCodeLine{00387             // tensor}
\DoxyCodeLine{00388             // see Benz (1995) or Libersky (1993)}
\DoxyCodeLine{00389             // Warning: Benz has typos in his paper....}
\DoxyCodeLine{00390             // edot\_ab = 0.5 * (d\_b v\_a + d\_a v\_b)}
\DoxyCodeLine{00391             // rdot\_ab = 0.5 * (d\_b v\_a -\/ d\_a v\_b)}
\DoxyCodeLine{00392             if (EOS\_TYPE\_VISCOUS\_REGOLITH != matEOS[matId]) \{}
\DoxyCodeLine{00393                 //printf("{}\%d\(\backslash\)n"{}, boundia);}
\DoxyCodeLine{00394                 tmp = p.m[j];}
\DoxyCodeLine{00395 \# if TENSORIAL\_CORRECTION}
\DoxyCodeLine{00396                 // TODO: understand}
\DoxyCodeLine{00397                 //tmp = -\/0.5*tmp/densityj*p\_rhs.tensorialCorrectiondWdrr[i*MAX\_NUM\_INTERACTIONS+k];}
\DoxyCodeLine{00398                 tmp = -\/0.5*tmp/densityj*dWdr/r;}
\DoxyCodeLine{00399 }
\DoxyCodeLine{00400 }
\DoxyCodeLine{00401                 // new implementation (after july 2017)}
\DoxyCodeLine{00402                 for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00403                     for (f = 0; f < DIM; f++) \{}
\DoxyCodeLine{00404                         for (kk = 0; kk < DIM; kk++) \{}
\DoxyCodeLine{00405                             edot[e][f] += 0.5 * p.m[j]/p.rho[j] *}
\DoxyCodeLine{00406                                 (p\_rhs.tensorialCorrectionMatrix[i*DIM*DIM+f*DIM+kk] *}
\DoxyCodeLine{00407                                   (-\/dv[e]) * dr[kk] * dWdr/r}
\DoxyCodeLine{00408                                   + p\_rhs.tensorialCorrectionMatrix[i*DIM*DIM+e*DIM+kk] *}
\DoxyCodeLine{00409                                   (-\/dv[f]) * dr[kk] * dWdr/r);}
\DoxyCodeLine{00410 }
\DoxyCodeLine{00411                             rdot[e][f] += 0.5 * p.m[j]/p.rho[j] *}
\DoxyCodeLine{00412                                 (p\_rhs.tensorialCorrectionMatrix[i*DIM*DIM+f*DIM+kk] *}
\DoxyCodeLine{00413                                   (-\/dv[e]) * dr[kk] * dWdr/r}
\DoxyCodeLine{00414                                   -\/ p\_rhs.tensorialCorrectionMatrix[i*DIM*DIM+e*DIM+kk] *}
\DoxyCodeLine{00415                                   (-\/dv[f]) * dr[kk] * dWdr/r);}
\DoxyCodeLine{00416                                             \}}
\DoxyCodeLine{00417                                 \}}
\DoxyCodeLine{00418                             \}}
\DoxyCodeLine{00419 \# else}
\DoxyCodeLine{00420                 tmp = -\/0.5*tmp/densityi;}
\DoxyCodeLine{00421                 edot[0][0] += tmp*(dvx*dWdx[0] + dvx*dWdx[0]);}
\DoxyCodeLine{00422 \#  if DIM > 1}
\DoxyCodeLine{00423                 edot[0][1] += tmp*(dvx*dWdx[1] + dvy*dWdx[0]);}
\DoxyCodeLine{00424                 edot[1][0] += tmp*(dvy*dWdx[0] + dvx*dWdx[1]);}
\DoxyCodeLine{00425                 edot[1][1] += tmp*(dvy*dWdx[1] + dvy*dWdx[1]);}
\DoxyCodeLine{00426 \#  endif}
\DoxyCodeLine{00427 \#  if DIM == 3}
\DoxyCodeLine{00428                 edot[0][2] += tmp*(dvx*dWdx[2] + dvz*dWdx[0]);}
\DoxyCodeLine{00429                 edot[1][2] += tmp*(dvy*dWdx[2] + dvz*dWdx[1]);}
\DoxyCodeLine{00430                 edot[2][0] += tmp*(dvz*dWdx[0] + dvx*dWdx[2]);}
\DoxyCodeLine{00431                 edot[2][1] += tmp*(dvz*dWdx[1] + dvy*dWdx[2]);}
\DoxyCodeLine{00432                 edot[2][2] += tmp*(dvz*dWdx[2] + dvz*dWdx[2]);}
\DoxyCodeLine{00433 \#  endif}
\DoxyCodeLine{00434                 rdot[0][0] += tmp*(dvx*dWdx[0] -\/ dvx*dWdx[0]);}
\DoxyCodeLine{00435 \#  if DIM > 1}
\DoxyCodeLine{00436                 rdot[0][1] += tmp*(dvx*dWdx[1] -\/ dvy*dWdx[0]);}
\DoxyCodeLine{00437                 rdot[1][0] += tmp*(dvy*dWdx[0] -\/ dvx*dWdx[1]);}
\DoxyCodeLine{00438                 rdot[1][1] += tmp*(dvy*dWdx[1] -\/ dvy*dWdx[1]);}
\DoxyCodeLine{00439 \#  endif}
\DoxyCodeLine{00440 \#  if DIM == 3}
\DoxyCodeLine{00441                 rdot[0][2] += tmp*(dvx*dWdx[2] -\/ dvz*dWdx[0]);}
\DoxyCodeLine{00442                 rdot[1][2] += tmp*(dvy*dWdx[2] -\/ dvz*dWdx[1]);}
\DoxyCodeLine{00443                 rdot[2][0] += tmp*(dvz*dWdx[0] -\/ dvx*dWdx[2]);}
\DoxyCodeLine{00444                 rdot[2][1] += tmp*(dvz*dWdx[1] -\/ dvy*dWdx[2]);}
\DoxyCodeLine{00445                 rdot[2][2] += tmp*(dvz*dWdx[2] -\/ dvz*dWdx[2]);}
\DoxyCodeLine{00446 \#  endif // DIM == 3}
\DoxyCodeLine{00447 \# endif // TENSORIAL\_CORRECTION}
\DoxyCodeLine{00448             \} // not EOS\_TYPE\_VISCOUS\_REGOLITH}
\DoxyCodeLine{00449 \#endif // SOLID}
\DoxyCodeLine{00450 }
\DoxyCodeLine{00451 }
\DoxyCodeLine{00452 }
\DoxyCodeLine{00453             pij = 0.0;}
\DoxyCodeLine{00454 \#if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00455             // artificial viscosity force only if v\_ij * r\_ij < 0}
\DoxyCodeLine{00456             if (vr < 0) \{}
\DoxyCodeLine{00457                 csbar = 0.5*(p.cs[i] + p.cs[j]);}
\DoxyCodeLine{00458                 smooth = 0.5*(sml1 + p.h[j]);}
\DoxyCodeLine{00459 }
\DoxyCodeLine{00460                 const double eps\_artvisc = 1e-\/2;}
\DoxyCodeLine{00461                 mu = smooth*vr/(rr + smooth*smooth*eps\_artvisc);}
\DoxyCodeLine{00462 }
\DoxyCodeLine{00463                 if (mu > muijmax) \{}
\DoxyCodeLine{00464                     muijmax = mu;}
\DoxyCodeLine{00465                 \}}
\DoxyCodeLine{00466                 rhobar = 0.5*(densityi + densityj);}
\DoxyCodeLine{00467 }
\DoxyCodeLine{00468 \# if BALSARA\_SWITCH}
\DoxyCodeLine{00469                 curlj = 0;}
\DoxyCodeLine{00470                 for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00471                     curlj += p\_rhs.curlv[j*DIM+d]*p\_rhs.curlv[j*DIM+d];}
\DoxyCodeLine{00472                 \}}
\DoxyCodeLine{00473                 curlj = sqrt(curlj);}
\DoxyCodeLine{00474                 fj = fabs(p\_rhs.divv[j]) / (fabs(p\_rhs.divv[j]) + curlj + eps\_balsara*p.cs[j]/p.h[j]);}
\DoxyCodeLine{00475                 mu *= (fi+fj)/2.;}
\DoxyCodeLine{00476 \# endif}
\DoxyCodeLine{00477 }
\DoxyCodeLine{00478                 pij = (beta*mu -\/ alpha*csbar) * mu/rhobar;}
\DoxyCodeLine{00479 \# if INVISCID\_SPH}
\DoxyCodeLine{00480                 pij =  ((2 * mu -\/ csbar) * p.beta[i] * mu) / rhobar;}
\DoxyCodeLine{00481 \# endif}
\DoxyCodeLine{00482             \}}
\DoxyCodeLine{00483 }
\DoxyCodeLine{00484 }
\DoxyCodeLine{00485 \#endif // ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00486 }
\DoxyCodeLine{00487 }
\DoxyCodeLine{00488 \#if NAVIER\_STOKES}
\DoxyCodeLine{00489             eta = matnu[matId] * (p.rho[i] + p.rho[j]) * 0.5 ;}
\DoxyCodeLine{00490             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00491                 accelshearj[d] = 0;}
\DoxyCodeLine{00492                 for (dd = 0; dd < DIM; dd++) \{}
\DoxyCodeLine{00493 \# if (SPHEQUATIONS == SPH\_VERSION1)}
\DoxyCodeLine{00494                     accelshearj[d] += eta * p.m[j] * (p.Tshear[stressIndex(j,d,dd)]/(p.rho[j]*p.rho[j]) + p.Tshear[stressIndex(i,d,dd)]/(p.rho[i]*p.rho[i])) *dWdx[dd];}
\DoxyCodeLine{00495 \# elif (SPHEQUATIONS == SPH\_VERSION2)}
\DoxyCodeLine{00496                     accelshearj[d] += eta * p.m[j] * (p.Tshear[stressIndex(j,d,dd)]+p.Tshear[stressIndex(i,d,dd)])/(p.rho[i]*p.rho[j]) *dWdx[dd];}
\DoxyCodeLine{00497 \# endif // SPHEQUATIONS}
\DoxyCodeLine{00498                 \}}
\DoxyCodeLine{00499             \}}
\DoxyCodeLine{00500 \#endif // NAVIER\_STOKES}
\DoxyCodeLine{00501 }
\DoxyCodeLine{00502 }
\DoxyCodeLine{00503 \#if SOLID}
\DoxyCodeLine{00504 \# if ARTIFICIAL\_STRESS}
\DoxyCodeLine{00505             artf = fixTensileInstability(i, j);}
\DoxyCodeLine{00506             artf =  pow(artf, matexponent\_tensor[matId]);}
\DoxyCodeLine{00507 \# endif}
\DoxyCodeLine{00508             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00509                 accelsj[d] = 0;}
\DoxyCodeLine{00510                 for (dd = 0; dd < DIM; dd++) \{}
\DoxyCodeLine{00511                     // this is stable for rotating rod with two different densities, tested cms July 2018}
\DoxyCodeLine{00512                     //accelsj[d] = p.m[j] * (sigma\_j[d][dd]+sigma\_i[d][dd])/(p.rho[i]*p.rho[j]) *dWdx[dd];}
\DoxyCodeLine{00513 }
\DoxyCodeLine{00514                     // the same but with tensorial correction}
\DoxyCodeLine{00515 \# if (SPHEQUATIONS == SPH\_VERSION1)}
\DoxyCodeLine{00516                     // warning! look below, the accelsj for each inner loop are added to accels[d] }
\DoxyCodeLine{00517                     // this is very confusing}
\DoxyCodeLine{00518                     accelsj[d] = p.m[j] * (sigma\_j[d][dd]/(p.rho[j]*p.rho[j]) + sigma\_i[d][dd]/(p.rho[i]*p.rho[i])) *dWdx[dd];}
\DoxyCodeLine{00519 \# elif (SPHEQUATIONS == SPH\_VERSION2)}
\DoxyCodeLine{00520                     accelsj[d] = p.m[j] * (sigma\_j[d][dd]+sigma\_i[d][dd])/(p.rho[i]*p.rho[j]) *dWdx[dd];}
\DoxyCodeLine{00521 \# else}
\DoxyCodeLine{00522 \# error wrong choice of SPHEQUATIONS settings in parameter.h}
\DoxyCodeLine{00523 \# endif // SPHEQUATIONS}
\DoxyCodeLine{00524 }
\DoxyCodeLine{00525                     // the standard formula as also used by Martin Jutzi}
\DoxyCodeLine{00526                     //accelsj[d] = p.m[j] * (sigma\_j[d][dd]/(p.rho[j]*p.rho[j]) + sigma\_i[d][dd]/(p.rho[i]*p.rho[i])) *dWdx[dd];}
\DoxyCodeLine{00527 }
\DoxyCodeLine{00528                     // the version as suggested by Libersky, Randles, Carney, Dickinson 1997}
\DoxyCodeLine{00529                     // unstable for a rotating rod!}
\DoxyCodeLine{00530 /*                    for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00531                         accelsj[d] +=  -\/p.m[j]/(p.rho[i]*p.rho[j]) * (sigma\_j[d][dd] -\/}
\DoxyCodeLine{00532                                 sigma\_i[d][dd]) * dWdr/r * dr[e] *}
\DoxyCodeLine{00533                             p\_rhs.tensorialCorrectionMatrix[i*DIM*DIM+dd*DIM+e];}
\DoxyCodeLine{00534                       \} */}
\DoxyCodeLine{00535 }
\DoxyCodeLine{00536 }
\DoxyCodeLine{00537 }
\DoxyCodeLine{00538 // Correction for tensile instability fix according to Monaghan, jcp 159 (2000)}
\DoxyCodeLine{00539 \# if ARTIFICIAL\_STRESS}
\DoxyCodeLine{00540                     double arts\_rij;}
\DoxyCodeLine{00541 \#  if (SPHEQUATIONS == SPH\_VERSION1)}
\DoxyCodeLine{00542                     arts\_rij = p\_rhs.R[stressIndex(i,d,dd)]/(p.rho[i]*p.rho[i])}
\DoxyCodeLine{00543                               + p\_rhs.R[stressIndex(j,d,dd)]/(p.rho[j]*p.rho[j]);}
\DoxyCodeLine{00544 \#  elif (SPHEQUATIONS == SPH\_VERSION2)}
\DoxyCodeLine{00545                     arts\_rij = (p\_rhs.R[stressIndex(i,d,dd)] + p\_rhs.R[stressIndex(j,d,dd)])/(p.rho[i]*p.rho[j]);}
\DoxyCodeLine{00546 \#  endif // SPHEQUATIONS}
\DoxyCodeLine{00547                     // add the special artificial stress}
\DoxyCodeLine{00548                     accels[d] += p.m[j] * arts\_rij * artf * dWdx[dd];}
\DoxyCodeLine{00549 \# endif // ARTIFICIAL\_STRESS}
\DoxyCodeLine{00550 }
\DoxyCodeLine{00551                     // bs...}
\DoxyCodeLine{00552                    // accels[d] += p.m[j] * (sigma\_j[d][dd]/pow(p.rho[j],2) + sigma\_i[d][dd]/pow(p.rho[i],2)) * dWdr/r * (-\/dr[dd]) * (-\/dr[d]) * p\_rhs.tensorialCorrectionMatrix[i*DIM*DIM+d*DIM+dd];}
\DoxyCodeLine{00553 }
\DoxyCodeLine{00554                     accels[d] += accelsj[d];}
\DoxyCodeLine{00555                 \}}
\DoxyCodeLine{00556             \}}
\DoxyCodeLine{00557 \#else // NOT SOLID}
\DoxyCodeLine{00558 \# if (SPHEQUATIONS == SPH\_VERSION1)}
\DoxyCodeLine{00559             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00560                 accelsj[d] =  -\/p.m[j] * (p.p[i]/(p.rho[i]*p.rho[i]) + p.p[j]/(p.rho[j]*p.rho[j])) * dWdx[d];}
\DoxyCodeLine{00561                 accels[d] += accelsj[d];}
\DoxyCodeLine{00562             \}}
\DoxyCodeLine{00563 \# elif (SPHEQUATIONS == SPH\_VERSION2)}
\DoxyCodeLine{00564             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00565                 accelsj[d] =  -\/p.m[j] * ((p.p[i]+p.p[j])/(p.rho[i]*p.rho[j])) * dWdx[d];}
\DoxyCodeLine{00566                 accels[d] += accelsj[d];}
\DoxyCodeLine{00567             \}}
\DoxyCodeLine{00568 \# endif // SPHEQUATIONS}
\DoxyCodeLine{00569 }
\DoxyCodeLine{00570 \#endif // SOLID}
\DoxyCodeLine{00571 }
\DoxyCodeLine{00572 \#if NAVIER\_STOKES}
\DoxyCodeLine{00573 // add viscous accel to total accel}
\DoxyCodeLine{00574             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00575                 accels[d] += accelshearj[d];}
\DoxyCodeLine{00576             \}}
\DoxyCodeLine{00577 \#endif}
\DoxyCodeLine{00578 }
\DoxyCodeLine{00579 \# if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00580             accels[0] += p.m[j]*(-\/pij)*dWdx[0];}
\DoxyCodeLine{00581 \#  if DIM > 1}
\DoxyCodeLine{00582             accels[1] += p.m[j]*(-\/pij)*dWdx[1];}
\DoxyCodeLine{00583 \#   if DIM > 2}
\DoxyCodeLine{00584             accels[2] += p.m[j]*(-\/pij)*dWdx[2];}
\DoxyCodeLine{00585 \#   endif}
\DoxyCodeLine{00586 \# endif}
\DoxyCodeLine{00587 \# endif}
\DoxyCodeLine{00588 }
\DoxyCodeLine{00589 }
\DoxyCodeLine{00590 \#if SOLID}
\DoxyCodeLine{00591             // use old version, not Frank Ott's}
\DoxyCodeLine{00592             //drhodt += p.m[j]*vvnablaW;}
\DoxyCodeLine{00593             // density integration stuff}
\DoxyCodeLine{00594             // see Frank Ott's thesis for details}
\DoxyCodeLine{00595             //drhodt += p.m[i]*vvnablaW;}
\DoxyCodeLine{00596             // Randles and Libersky's version (1996)}
\DoxyCodeLine{00597 \#if 0  //TENSORIAL\_CORRECTION}
\DoxyCodeLine{00598             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00599                 for (dd = 0; dd < DIM; dd++) \{}
\DoxyCodeLine{00600                     drhodt += p.rho[i]/p.rho[j] * p.m[j]*dv[d]*dWdr/r}
\DoxyCodeLine{00601                               * dr[dd] * p\_rhs.tensorialCorrectionMatrix[i*DIM*DIM+d*DIM+dd];}
\DoxyCodeLine{00602                 \}}
\DoxyCodeLine{00603             \}}
\DoxyCodeLine{00604 }
\DoxyCodeLine{00605 \#else}
\DoxyCodeLine{00606             drhodt += p.rho[i]/p.rho[j] * p.m[j] * vvnablaW;}
\DoxyCodeLine{00607 \#endif // TENSORIAL CORRECTIONS}
\DoxyCodeLine{00608 }
\DoxyCodeLine{00609 }
\DoxyCodeLine{00610 }
\DoxyCodeLine{00611 \#else // HYDRO now}
\DoxyCodeLine{00612             //drhodt += p.m[j]*vvnablaW;}
\DoxyCodeLine{00613             drhodt += p.rho[i]/p.rho[j] * p.m[j] * vvnablaW;}
\DoxyCodeLine{00614 \#endif // SOLID}
\DoxyCodeLine{00615 }
\DoxyCodeLine{00616 }
\DoxyCodeLine{00617 \#if INTEGRATE\_SML}
\DoxyCodeLine{00618             // minus since vvnablaW is v\_i -\/ v\_j \(\backslash\)nabla W\_ij}
\DoxyCodeLine{00619             p.dhdt[i] -\/= 1./DIM * p.h[i]/densityi * p.m[j] * vvnablaW;}
\DoxyCodeLine{00620 \#endif}
\DoxyCodeLine{00621 }
\DoxyCodeLine{00622 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00623 \# if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00624             if (!isRelaxationRun) \{}
\DoxyCodeLine{00625                 dedt += 0.5 * p.m[j] * pij * vvnablaW;}
\DoxyCodeLine{00626             \}}
\DoxyCodeLine{00627 \# endif}
\DoxyCodeLine{00628 }
\DoxyCodeLine{00629 \# if SOLID}
\DoxyCodeLine{00630 \# if 0 // deactivated cms 2019-\/07-\/02 SOLID}
\DoxyCodeLine{00631 // new implementation cms 2019-\/05-\/23}
\DoxyCodeLine{00632             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00633                 for (dd = 0; dd < DIM; dd++) \{}
\DoxyCodeLine{00634 \#  if (SPHEQUATIONS == SPH\_VERSION1)}
\DoxyCodeLine{00635                     dedt += 0.5 * p.m[j] * (p\_rhs.sigma[stressIndex(i,d,dd)]/(p.rho[i]*p.rho[i]) + p\_rhs.sigma[stressIndex(j,d,dd)]/(p.rho[j]*p.rho[j])) * dv[d] * dWdx[dd];}
\DoxyCodeLine{00636 \#  elif (SPHEQUATIONS == SPH\_VERSION2)}
\DoxyCodeLine{00637                     dedt += 0.5 * p.m[j] * (p\_rhs.sigma[stressIndex(i,d,dd)] + p\_rhs.sigma[stressIndex(j,d,dd)])/(p.rho[i]*p.rho[j]) * dv[d] * dWdx[dd];}
\DoxyCodeLine{00638 \#endif}
\DoxyCodeLine{00639 \#if DEBUG}
\DoxyCodeLine{00640                     if (isnan(dedt)) \{}
\DoxyCodeLine{00641                         printf("{}no \%d m=\%e sigma\_i[\%d][\%d]=\%e sigma\_j[\%d][\%d]= \%e dv[\%d] \%e  dWdx[\%d] \%e  p\_i \%e  p\_j \%e rho\_i \%e rho\_j \%e pij \%e cs\_i \%e cs\_j \%e\(\backslash\)n"{}, i, p.m[j], d, dd, p\_rhs.sigma[stressIndex(i,d,dd)], d, dd,p\_rhs.sigma[stressIndex(j,d,dd)], d, dv[d], dd, dWdx[dd], p.p[i], p.p[j], p.rho[i], p.rho[j], pij,p.cs[i], p.cs[j]);}
\DoxyCodeLine{00642                         assert(0);}
\DoxyCodeLine{00643                     \}}
\DoxyCodeLine{00644 \#endif}
\DoxyCodeLine{00645                 \}}
\DoxyCodeLine{00646             \}}
\DoxyCodeLine{00647 \#endif // 0 deactivation from cms 2019-\/07-\/02}
\DoxyCodeLine{00648 }
\DoxyCodeLine{00649 \# else // dedt for non-\/solid}
\DoxyCodeLine{00650             // remember, accelsj  are accelerations by particle j, and dv = v\_i -\/ v\_j}
\DoxyCodeLine{00651             dedt += 0.5 * accelsj[0] * -\/dvx;}
\DoxyCodeLine{00652 \#  if DIM > 1}
\DoxyCodeLine{00653             dedt += 0.5 * accelsj[1] * -\/dvy;}
\DoxyCodeLine{00654 \#  endif}
\DoxyCodeLine{00655 \#  if DIM > 2}
\DoxyCodeLine{00656             dedt += 0.5 * accelsj[2] * -\/dvz;}
\DoxyCodeLine{00657 \#  endif}
\DoxyCodeLine{00658 \# endif // SOLID}
\DoxyCodeLine{00659 }
\DoxyCodeLine{00660 \#endif // INTEGRATE ENERGY}
\DoxyCodeLine{00661 }
\DoxyCodeLine{00662         \} // neighbors loop end}
\DoxyCodeLine{00663         ax = accels[0];}
\DoxyCodeLine{00664 \#if DIM > 1}
\DoxyCodeLine{00665         ay = accels[1];}
\DoxyCodeLine{00666 \#endif}
\DoxyCodeLine{00667 \#if DIM > 2}
\DoxyCodeLine{00668         az = accels[2];}
\DoxyCodeLine{00669 \#endif}
\DoxyCodeLine{00670         p.ax[i] = ax;}
\DoxyCodeLine{00671 \#if DIM > 1}
\DoxyCodeLine{00672         p.ay[i] = ay;}
\DoxyCodeLine{00673 \#endif}
\DoxyCodeLine{00674 \#if DIM > 2}
\DoxyCodeLine{00675         p.az[i] = az;}
\DoxyCodeLine{00676 \#endif}
\DoxyCodeLine{00677 }
\DoxyCodeLine{00678         p.drhodt[i] = drhodt;}
\DoxyCodeLine{00679 }
\DoxyCodeLine{00680 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00681 \# if SOLID}
\DoxyCodeLine{00682     double ptmp = 0;}
\DoxyCodeLine{00683     double edottmp = 0;}
\DoxyCodeLine{00684 \#  if FRAGMENTATION}
\DoxyCodeLine{00685     if (p.p[i] < 0) \{}
\DoxyCodeLine{00686         ptmp = (1-\/di) * p.p[i];}
\DoxyCodeLine{00687     \} else \{}
\DoxyCodeLine{00688         ptmp = p.p[i];}
\DoxyCodeLine{00689     \}}
\DoxyCodeLine{00690 \#  else}
\DoxyCodeLine{00691     ptmp = p.p[i];}
\DoxyCodeLine{00692 \#  endif}
\DoxyCodeLine{00693     dedt -\/= 1./p.rho[i]*ptmp * p\_rhs.divv[i];}
\DoxyCodeLine{00694     // symmetrize edot}
\DoxyCodeLine{00695     for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00696         for (dd = 0; dd < d; dd++) \{}
\DoxyCodeLine{00697             edottmp = 0.5*(edot[d][dd] + edot[dd][d]);}
\DoxyCodeLine{00698             edot[d][dd] = edottmp;}
\DoxyCodeLine{00699             edot[dd][d] = edottmp;}
\DoxyCodeLine{00700          \}}
\DoxyCodeLine{00701     \}}
\DoxyCodeLine{00702     for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00703         for (dd = 0; dd < DIM; dd++) \{}
\DoxyCodeLine{00704             double Stmp = p.S[stressIndex(i,d,dd)];}
\DoxyCodeLine{00705 \#  if FRAGMENTATION}
\DoxyCodeLine{00706         Stmp *= (1-\/di);}
\DoxyCodeLine{00707 \#  endif}
\DoxyCodeLine{00708         dedt += 1./p.rho[i]*Stmp*edot[d][dd];}
\DoxyCodeLine{00709         \}}
\DoxyCodeLine{00710     \}}
\DoxyCodeLine{00711 \# endif}
\DoxyCodeLine{00712         p.dedt[i] = dedt;}
\DoxyCodeLine{00713 \#endif}
\DoxyCodeLine{00714 }
\DoxyCodeLine{00715 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00716         if (matEOS[matId] == EOS\_TYPE\_JUTZI || matEOS[matId] == EOS\_TYPE\_JUTZI\_MURNAGHAN) \{}
\DoxyCodeLine{00717             if (p.alpha\_jutzi[i] <= 1.0) \{}
\DoxyCodeLine{00718                 p.dalphadt[i] = 0.0;}
\DoxyCodeLine{00719                 p.alpha\_jutzi[i] = 1.0;}
\DoxyCodeLine{00720             \} else \{}
\DoxyCodeLine{00721 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00722                 p.dalphadt[i] = ((p.dedt[i] * p.delpdele[i] + p.alpha\_jutzi[i] * p.drhodt[i] * p.delpdelrho[i])}
\DoxyCodeLine{00723                               * p.dalphadp[i]) / (p.alpha\_jutzi[i] + p.dalphadp[i] * (p.p[i] -\/ p.rho[i] * p.delpdelrho[i]));}
\DoxyCodeLine{00724 \#else}
\DoxyCodeLine{00725                 p.dalphadt[i] = ((p.alpha\_jutzi[i] * p.drhodt[i] * p.delpdelrho[i])}
\DoxyCodeLine{00726                               * p.dalphadp[i]) / (p.alpha\_jutzi[i] + p.dalphadp[i] * (p.p[i] -\/ p.rho[i] * p.delpdelrho[i]));}
\DoxyCodeLine{00727 }
\DoxyCodeLine{00728 \#endif}
\DoxyCodeLine{00729                 if (p.dalphadt[i] > 0.0) \{}
\DoxyCodeLine{00730                     p.dalphadt[i] = 0.0;}
\DoxyCodeLine{00731                 \}}
\DoxyCodeLine{00732             \}}
\DoxyCodeLine{00733         \} else \{}
\DoxyCodeLine{00734             p.dalphadt[i] = 0.0;}
\DoxyCodeLine{00735         \}}
\DoxyCodeLine{00736 \#endif}
\DoxyCodeLine{00737 }
\DoxyCodeLine{00738 \#if EPSALPHA\_POROSITY}
\DoxyCodeLine{00739         /* calculate the change in epsilon and alpha per time */}
\DoxyCodeLine{00740         if (matEOS[matId] == EOS\_TYPE\_EPSILON) \{}
\DoxyCodeLine{00741             double dalpha\_epspordeps = 0.0;}
\DoxyCodeLine{00742             p.depsilon\_vdt[i] = 0.0;}
\DoxyCodeLine{00743             int f;}
\DoxyCodeLine{00744             double kappa = matporepsilon\_kappa[matId];}
\DoxyCodeLine{00745             double alpha\_0 = matporepsilon\_alpha\_0[matId];}
\DoxyCodeLine{00746             double eps\_e = matporepsilon\_epsilon\_e[matId];}
\DoxyCodeLine{00747             double eps\_x = matporepsilon\_epsilon\_x[matId];}
\DoxyCodeLine{00748             double eps\_c = matporepsilon\_epsilon\_c[matId];}
\DoxyCodeLine{00749             for (f = 0; f < DIM; f++) \{}
\DoxyCodeLine{00750                 p.depsilon\_vdt[i] += edot[f][f];}
\DoxyCodeLine{00751             \}}
\DoxyCodeLine{00752             if (p.alpha\_epspor[i] <= 1.0) \{}
\DoxyCodeLine{00753                 p.dalpha\_epspordt[i] = 0.0;}
\DoxyCodeLine{00754                 p.alpha\_epspor[i] = 1.0;}
\DoxyCodeLine{00755                 if (p.depsilon\_vdt[i] > 0.0)}
\DoxyCodeLine{00756                     p.depsilon\_vdt[i] = 0.0;}
\DoxyCodeLine{00757             \} else \{}
\DoxyCodeLine{00758                 if (p.depsilon\_vdt[i] < 0.0) \{}
\DoxyCodeLine{00759                     if (p.epsilon\_v[i] >= eps\_e) \{}
\DoxyCodeLine{00760                         dalpha\_epspordeps = 0.0;}
\DoxyCodeLine{00761                     \} else if (p.epsilon\_v[i] < eps\_e \&\& p.epsilon\_v[i] >= eps\_x) \{}
\DoxyCodeLine{00762                         dalpha\_epspordeps = alpha\_0 * kappa * exp(kappa * (p.epsilon\_v[i] -\/ eps\_e));}
\DoxyCodeLine{00763                     \} else if (p.epsilon\_v[i] < eps\_x \&\& p.epsilon\_v[i] > eps\_c) \{}
\DoxyCodeLine{00764                         dalpha\_epspordeps = 2.0 * (1.0 -\/ alpha\_0 * exp(kappa * (eps\_x -\/ eps\_e))) * (eps\_c -\/ p.epsilon\_v[i]) / (pow((eps\_c -\/ eps\_x), 2));}
\DoxyCodeLine{00765                     \} else if (p.epsilon\_v[i] <= eps\_c) \{}
\DoxyCodeLine{00766                         p.alpha\_epspor[i] = 1.0;}
\DoxyCodeLine{00767                         dalpha\_epspordeps = 0.0;}
\DoxyCodeLine{00768                     \}}
\DoxyCodeLine{00769                 \} else \{}
\DoxyCodeLine{00770                     p.depsilon\_vdt[i] = 0.0;}
\DoxyCodeLine{00771                 \}}
\DoxyCodeLine{00772                 p.dalpha\_epspordt[i] = dalpha\_epspordeps * p.depsilon\_vdt[i];}
\DoxyCodeLine{00773             \}}
\DoxyCodeLine{00774         \} else \{}
\DoxyCodeLine{00775             p.dalpha\_epspordt[i] = 0.0;}
\DoxyCodeLine{00776             p.depsilon\_vdt[i] = 0.0;}
\DoxyCodeLine{00777         \}}
\DoxyCodeLine{00778 \#endif}
\DoxyCodeLine{00779 }
\DoxyCodeLine{00780 \#if SOLID}
\DoxyCodeLine{00781         // now we can find the change of the stress tensor components}
\DoxyCodeLine{00782         double shear = matShearmodulus[matId];}
\DoxyCodeLine{00783         double bulk = matBulkmodulus[matId];}
\DoxyCodeLine{00784         double young = matYoungModulus[matId];}
\DoxyCodeLine{00785         int f;}
\DoxyCodeLine{00786 \#if JC\_PLASTICITY}
\DoxyCodeLine{00787             double edotp[DIM][DIM]; // plastic strain rate}
\DoxyCodeLine{00788 \#endif}
\DoxyCodeLine{00789 \#if SIRONO\_POROSITY}
\DoxyCodeLine{00790         if (matEOS[matId] == EOS\_TYPE\_SIRONO) \{}
\DoxyCodeLine{00791             shear = 0.5 * p.K[i];}
\DoxyCodeLine{00792             bulk = p.K[i];}
\DoxyCodeLine{00793             young = (9.0 * bulk * shear / (3.0 * bulk + shear));}
\DoxyCodeLine{00794         \}}
\DoxyCodeLine{00795 \#endif}
\DoxyCodeLine{00796 }
\DoxyCodeLine{00797         if (matEOS[matId] != EOS\_TYPE\_REGOLITH \&\& matEOS[matId] != EOS\_TYPE\_VISCOUS\_REGOLITH) \{}
\DoxyCodeLine{00798             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00799                 for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00800                     // Hooke's law}
\DoxyCodeLine{00801                     p.dSdt[stressIndex(i,d,e)] = 2.0 * shear * edot[d][e];}
\DoxyCodeLine{00802 \#if JC\_PLASTICITY}
\DoxyCodeLine{00803                             edotp[d][e] = (1 -\/ p.jc\_f[i]) * edot[d][e];}
\DoxyCodeLine{00804 \#endif}
\DoxyCodeLine{00805                     // rotation terms}
\DoxyCodeLine{00806                     for (f = 0; f < DIM; f++) \{}
\DoxyCodeLine{00807                         // trace}
\DoxyCodeLine{00808                         if (d == e) \{}
\DoxyCodeLine{00809                             p.dSdt[stressIndex(i,d,e)] -\/= 2.0 * shear * edot[f][f] / 3.0;}
\DoxyCodeLine{00810 \#if JC\_PLASTICITY}
\DoxyCodeLine{00811                                     edotp[d][e] += (-\/1./3)*(1-\/p.jc\_f[i])*edot[f][f];}
\DoxyCodeLine{00812 \#endif}
\DoxyCodeLine{00813                         \}}
\DoxyCodeLine{00814                         p.dSdt[stressIndex(i,d,e)] += p.S[stressIndex(i,d,f)] * rdot[e][f];}
\DoxyCodeLine{00815                         p.dSdt[stressIndex(i,d,e)] += p.S[stressIndex(i,e,f)] * rdot[d][f];}
\DoxyCodeLine{00816                     \}}
\DoxyCodeLine{00817 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00818 \# if STRESS\_PALPHA\_POROSITY}
\DoxyCodeLine{00819 \#  if FRAGMENTATION}
\DoxyCodeLine{00820                     if (matEOS[matId] == EOS\_TYPE\_JUTZI || matEOS[matId] == EOS\_TYPE\_JUTZI\_MURNAGHAN) \{}
\DoxyCodeLine{00821                         p.dSdt[stressIndex(i,d,e)] = p.f[i] / p.alpha\_jutzi[i] * p.dSdt[stressIndex(i,d,e)]}
\DoxyCodeLine{00822                                                             -\/ 1.0 / (p.alpha\_jutzi[i]*p.alpha\_jutzi[i]) * (1-\/di)*p.S[stressIndex(i,d,e)] * p.dalphadt[i];}
\DoxyCodeLine{00823                     \}}
\DoxyCodeLine{00824 }
\DoxyCodeLine{00825 \#  else}
\DoxyCodeLine{00826                     if (matEOS[matId] == EOS\_TYPE\_JUTZI || matEOS[matId] == EOS\_TYPE\_JUTZI\_MURNAGHAN) \{}
\DoxyCodeLine{00827                         p.dSdt[stressIndex(i,d,e)] = p.f[i] / p.alpha\_jutzi[i] * p.dSdt[stressIndex(i,d,e)]}
\DoxyCodeLine{00828                                                             -\/ 1.0 / (p.alpha\_jutzi[i]*p.alpha\_jutzi[i]) * p.S[stressIndex(i,d,e)] * p.dalphadt[i];}
\DoxyCodeLine{00829                     \}}
\DoxyCodeLine{00830 \#  endif}
\DoxyCodeLine{00831 \# endif}
\DoxyCodeLine{00832 \#endif}
\DoxyCodeLine{00833 }
\DoxyCodeLine{00834 }
\DoxyCodeLine{00835                 \}}
\DoxyCodeLine{00836             \}}
\DoxyCodeLine{00837 }
\DoxyCodeLine{00838 }
\DoxyCodeLine{00839 \#if JC\_PLASTICITY}
\DoxyCodeLine{00840         /* calculate plastic strain rate tensor from dSdt */}
\DoxyCodeLine{00841         double K2 = 0;}
\DoxyCodeLine{00842         for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00843             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00844                 K2 += 0.5*edotp[d][e]*edotp[d][e];}
\DoxyCodeLine{00845             \}}
\DoxyCodeLine{00846         \}}
\DoxyCodeLine{00847         p.edotp[i] = 2./3. * sqrt(3*K2);}
\DoxyCodeLine{00848 }
\DoxyCodeLine{00849         /* change of temperature due to plastic deformation */}
\DoxyCodeLine{00850         double work = 0;}
\DoxyCodeLine{00851         for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00852             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00853                 work += sigma\_i[d][e] * edotp[d][e];}
\DoxyCodeLine{00854             \}}
\DoxyCodeLine{00855         \}}
\DoxyCodeLine{00856         /* these are the particles that fail the adiabatic assumption */}
\DoxyCodeLine{00857         if (work < 0) \{}
\DoxyCodeLine{00858           /*  fprintf(stderr, "{}Warning: work related to plastic strain is negative for particle \%d located at \(\backslash\)t"{}, i);}
\DoxyCodeLine{00859             for (d = 0; d < DIM; d++)}
\DoxyCodeLine{00860                 fprintf(stderr, "{}x[\%d]: \%g \(\backslash\)t"{}, d, p[i].x[d]);}
\DoxyCodeLine{00861             fprintf(stderr, "{}\(\backslash\)n"{}); */}
\DoxyCodeLine{00862             work = 0;}
\DoxyCodeLine{00863         \}}
\DoxyCodeLine{00864         /* daniel Thun daniel thun */}
\DoxyCodeLine{00865         p.dTdt[i] = work / (matCp[p\_rhs.materialId[i]] * p.rho[i]);}
\DoxyCodeLine{00866         if (p.dTdt[i] < 0) \{}
\DoxyCodeLine{00867             //fprintf(stderr, "{}\%d work: \%g, Cp: \%g, rho: \%g\(\backslash\)n"{}, i, work, matCp[p\_rhs.materialId[i]], p.rho[i]);}
\DoxyCodeLine{00868         \}}
\DoxyCodeLine{00869         if (p.noi[i] < 1)}
\DoxyCodeLine{00870             p.dTdt[i] = 0.0;}
\DoxyCodeLine{00871 }
\DoxyCodeLine{00872 \#endif  /* JC\_PLASTICITY */}
\DoxyCodeLine{00873 }
\DoxyCodeLine{00874 \#if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00875         p.muijmax[i] = muijmax;}
\DoxyCodeLine{00876 \#endif}
\DoxyCodeLine{00877 }
\DoxyCodeLine{00878         double tensileMax = 0;}
\DoxyCodeLine{00879 \#if SOLID}
\DoxyCodeLine{00880         tensileMax = calculateMaxEigenvalue(sigma\_i);}
\DoxyCodeLine{00881         p.local\_strain[i] = tensileMax/young;}
\DoxyCodeLine{00882 \#endif}
\DoxyCodeLine{00883 \#if FRAGMENTATION}
\DoxyCodeLine{00884             // calculate the damage caused by the strain}
\DoxyCodeLine{00885             // 1st: get maximum eigenvalue of sigma\_i}
\DoxyCodeLine{00886             // 2nd: get local scalar strain out of maximum tensile stress}
\DoxyCodeLine{00887             //di = pow(di, DIM); // it is already \string^DIM}
\DoxyCodeLine{00888             int n\_active = 0;}
\DoxyCodeLine{00889             if (di < 1.0) \{}
\DoxyCodeLine{00890                 p.local\_strain[i] = ((tensileMax)/((1.0 -\/ di) * young));}
\DoxyCodeLine{00891                 // 3rd: calculate evolution of damage}
\DoxyCodeLine{00892                 // note: ddamagedt**1./DIM is calculated}
\DoxyCodeLine{00893                 // speed of a longitudinal elastic wave, see eg. Melosh, Impact Cratering}
\DoxyCodeLine{00894                 // crack growth velocity = 0.4 times c\_elast}
\DoxyCodeLine{00895                 double c\_g = 0.4 * sqrt((bulk + 4.0 * shear * (1.0 -\/ di) / 3.0) * 1.0 / densityi);}
\DoxyCodeLine{00896                 // find number of active flaws}
\DoxyCodeLine{00897                 for (d = 0; d < p.numFlaws[i]; d++) \{}
\DoxyCodeLine{00898                     if (p\_rhs.flaws[i*maxNumFlaws+d] < p.local\_strain[i]) \{}
\DoxyCodeLine{00899                         n\_active++;}
\DoxyCodeLine{00900                     \}}
\DoxyCodeLine{00901                 \}}
\DoxyCodeLine{00902                 p.numActiveFlaws[i] = max(n\_active, p.numActiveFlaws[i]);}
\DoxyCodeLine{00903                 p.dddt[i] = n\_active * c\_g / sml1;}
\DoxyCodeLine{00904                 if (p.dddt[i] < 0) \{}
\DoxyCodeLine{00905                     printf("{}error!\(\backslash\)n"{});}
\DoxyCodeLine{00906                     printf("{}\%e \%e \%e \%d \%d \%e \%e \(\backslash\)n"{}, p.x[i], p.y[i], p.damage\_total[i], p.numFlaws[i],}
\DoxyCodeLine{00907                             p.numActiveFlaws[i], p.dddt[i], p.local\_strain[i]);}
\DoxyCodeLine{00908                 \}}
\DoxyCodeLine{00909 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00910                 if (matEOS[matId] == EOS\_TYPE\_JUTZI || matEOS[matId] == EOS\_TYPE\_JUTZI\_MURNAGHAN) \{}
\DoxyCodeLine{00911                     double deld = 0.01;         /* variation in the damage to avoid infinity problem */}
\DoxyCodeLine{00912                     double alpha\_0 = matporjutzi\_alpha\_0[matId];}
\DoxyCodeLine{00913                     if (alpha\_0 > 1) \{}
\DoxyCodeLine{00914                         p.ddamage\_porjutzidt[i] = -\/ 1.0/DIM * (pow(1.0 -\/ (p.alpha\_jutzi[i] -\/ 1.0) / (alpha\_0 -\/ 1.0) + deld, 1.0/DIM -\/ 1.0))}
\DoxyCodeLine{00915                                          / (pow(1.0 + deld, 1.0/DIM) -\/ pow(deld, 1.0/DIM)) * 1.0/(alpha\_0 -\/ 1.0) * p.dalphadt[i];}
\DoxyCodeLine{00916                     \}}
\DoxyCodeLine{00917                 \}}
\DoxyCodeLine{00918 \#endif}
\DoxyCodeLine{00919 }
\DoxyCodeLine{00920             \} else \{}
\DoxyCodeLine{00921                 // particle already dead}
\DoxyCodeLine{00922                 p.local\_strain[i] = 0.0;}
\DoxyCodeLine{00923                 n\_active = p.numFlaws[i];}
\DoxyCodeLine{00924                 p.numActiveFlaws[i] = n\_active;}
\DoxyCodeLine{00925                 p.dddt[i] = 0.0;}
\DoxyCodeLine{00926                 p.d[i] = 1.0;}
\DoxyCodeLine{00927             \}}
\DoxyCodeLine{00928 }
\DoxyCodeLine{00929 \#endif}
\DoxyCodeLine{00930 }
\DoxyCodeLine{00931 }
\DoxyCodeLine{00932         \} else if (matEOS[matId] != EOS\_TYPE\_VISCOUS\_REGOLITH) \{ // if materialtype = regolith}
\DoxyCodeLine{00933 }
\DoxyCodeLine{00934             alpha\_phi = matAlphaPhi[matId];}
\DoxyCodeLine{00935             kc = matCohesionCoefficient[matId];}
\DoxyCodeLine{00936 }
\DoxyCodeLine{00937             tr\_edot = 0.0;}
\DoxyCodeLine{00938             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00939                 tr\_edot += edot[d][d];}
\DoxyCodeLine{00940             \}}
\DoxyCodeLine{00941 }
\DoxyCodeLine{00942 \#if DIM == 2}
\DoxyCodeLine{00943             double poissons\_ratio = (3*bulk -\/ 2*shear) / (2*(3*bulk + shear));}
\DoxyCodeLine{00944             I1 = (1 + poissons\_ratio) * (p.S[stressIndex(i, 0, 0)] + p.S[stressIndex(i, 1, 1)]);}
\DoxyCodeLine{00945 \#else}
\DoxyCodeLine{00946             I1 = p.S[stressIndex(i,0,0)] + p.S[stressIndex(i,1,1)] + p.S[stressIndex(i,2,2)];}
\DoxyCodeLine{00947 \#endif}
\DoxyCodeLine{00948 }
\DoxyCodeLine{00949 }
\DoxyCodeLine{00950             //get S}
\DoxyCodeLine{00951             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00952                 for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00953                     S\_i[d][e] = p.S[stressIndex(i, d, e)];}
\DoxyCodeLine{00954                 \}}
\DoxyCodeLine{00955                 S\_i[d][d] -\/= I1/3.0;}
\DoxyCodeLine{00956             \}}
\DoxyCodeLine{00957 \#if DIM == 2}
\DoxyCodeLine{00958             double sz = poissons\_ratio*(S\_i[0][0] + S\_i[1][1]);}
\DoxyCodeLine{00959 \#endif}
\DoxyCodeLine{00960 }
\DoxyCodeLine{00961             //calculate sqrt(J2)}
\DoxyCodeLine{00962             sqrt\_J2 = 0.0;}
\DoxyCodeLine{00963             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00964                 for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00965                     sqrt\_J2 += S\_i[d][e]*S\_i[d][e];}
\DoxyCodeLine{00966                 \}}
\DoxyCodeLine{00967             \}}
\DoxyCodeLine{00968 \#if DIM == 2}
\DoxyCodeLine{00969             sqrt\_J2 += sz*sz;}
\DoxyCodeLine{00970 \#endif}
\DoxyCodeLine{00971             sqrt\_J2 *= 0.5;}
\DoxyCodeLine{00972             sqrt\_J2 = sqrt(sqrt\_J2);}
\DoxyCodeLine{00973 }
\DoxyCodeLine{00974             //calculate lambda\_dot}
\DoxyCodeLine{00975             lambda\_dot = 0.0;}
\DoxyCodeLine{00976             if (!(sqrt\_J2 + alpha\_phi * I1 -\/ kc < 0)) \{}
\DoxyCodeLine{00977 }
\DoxyCodeLine{00978                 if (sqrt\_J2 > 0.0) \{}
\DoxyCodeLine{00979                     for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00980                         for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00981                             lambda\_dot += S\_i[d][e]*edot[d][e];}
\DoxyCodeLine{00982                         \}}
\DoxyCodeLine{00983                     \}}
\DoxyCodeLine{00984                     lambda\_dot *= shear/sqrt\_J2;}
\DoxyCodeLine{00985                 \}}
\DoxyCodeLine{00986                 lambda\_dot += 3*alpha\_phi*bulk*tr\_edot;}
\DoxyCodeLine{00987                 /*lambda\_dot /= 9*alpha\_phi*alpha\_phi*bulk + shear;*/}
\DoxyCodeLine{00988                 lambda\_dot /= shear;}
\DoxyCodeLine{00989             \}}
\DoxyCodeLine{00990 }
\DoxyCodeLine{00991             // do not mess up with the elastic regime}
\DoxyCodeLine{00992             if (lambda\_dot < 0)}
\DoxyCodeLine{00993                 lambda\_dot = 0.0;}
\DoxyCodeLine{00994 }
\DoxyCodeLine{00995             //calculate dsigmadt}
\DoxyCodeLine{00996             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00997                 for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00998                     p.dSdt[stressIndex(i,d,e)] = 2*shear*edot[d][e];}
\DoxyCodeLine{00999                     for (f = 0; f < DIM; f++) \{}
\DoxyCodeLine{01000                         p.dSdt[stressIndex(i,d,e)] += p.S[stressIndex(i,d,f)]*rdot[e][f] + p.S[stressIndex(i,f,e)]*rdot[d][f];}
\DoxyCodeLine{01001                     \}}
\DoxyCodeLine{01002                     if (sqrt\_J2 > 0.0) \{}
\DoxyCodeLine{01003                         p.dSdt[stressIndex(i,d,e)] -\/= S\_i[d][e]*lambda\_dot*shear/sqrt\_J2;}
\DoxyCodeLine{01004                     \}}
\DoxyCodeLine{01005                 \}}
\DoxyCodeLine{01006                 /*p.dSdt[stressIndex(i,d,d)] += tr\_edot*(bulk-\/2*shear/3.0) -\/ 3*lambda\_dot*alpha\_phi*bulk;*/}
\DoxyCodeLine{01007                 p.dSdt[stressIndex(i,d,d)] += tr\_edot*(bulk-\/2*shear/3.0);}
\DoxyCodeLine{01008             \}}
\DoxyCodeLine{01009 }
\DoxyCodeLine{01010 }
\DoxyCodeLine{01011 \#if FRAGMENTATION}
\DoxyCodeLine{01012     /* disable fragmentation for regolith, cause there's none */}
\DoxyCodeLine{01013                 p.local\_strain[i] = 0.0;}
\DoxyCodeLine{01014                 p.numActiveFlaws[i] = 0;}
\DoxyCodeLine{01015                 p.dddt[i] = 0.0;}
\DoxyCodeLine{01016 \#endif}
\DoxyCodeLine{01017 }
\DoxyCodeLine{01018 }
\DoxyCodeLine{01019         \} else if (matEOS[matId] == EOS\_TYPE\_VISCOUS\_REGOLITH) \{}
\DoxyCodeLine{01020             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{01021                 for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{01022                     p.dSdt[stressIndex(i,d,e)] = 0.0;}
\DoxyCodeLine{01023                 \}}
\DoxyCodeLine{01024             \}}
\DoxyCodeLine{01025         \}//end material-\/if}
\DoxyCodeLine{01026 }
\DoxyCodeLine{01027 \#endif // SOLID}
\DoxyCodeLine{01028 }
\DoxyCodeLine{01029 }
\DoxyCodeLine{01030     \} // particle loop end}
\DoxyCodeLine{01031 \}}
\DoxyCodeLine{01032 }
\DoxyCodeLine{01033 }
\DoxyCodeLine{01034 \#if VISCOUS\_REGOLITH}
\DoxyCodeLine{01035 \_\_global\_\_ void calculatedeviatoricStress(int *interactions)}
\DoxyCodeLine{01036 \{}
\DoxyCodeLine{01037     register int i, j, inc, d, e, k;}
\DoxyCodeLine{01038     register int mt;}
\DoxyCodeLine{01039     int noi;}
\DoxyCodeLine{01040     int f, kk;}
\DoxyCodeLine{01041     double dx, dy, dvx, dvy;}
\DoxyCodeLine{01042     double dv[DIM];}
\DoxyCodeLine{01043     double dr[DIM];}
\DoxyCodeLine{01044     double W, dWdx[DIM];}
\DoxyCodeLine{01045     double dWdr;}
\DoxyCodeLine{01046     double x, y;}
\DoxyCodeLine{01047 \#if DIM == 3}
\DoxyCodeLine{01048     double dz, z, dvz;}
\DoxyCodeLine{01049 \#endif}
\DoxyCodeLine{01050     double edot[DIM][DIM], edottrace;}
\DoxyCodeLine{01051     double densityi, densityj, tmp;}
\DoxyCodeLine{01052     register double srp; // strain-\/rate parameter}
\DoxyCodeLine{01053     register double mustar;}
\DoxyCodeLine{01054     double mumax = 2e3; // FixMe! This is the upper limit of the Mohr-\/Coulomb yield stress criterion}
\DoxyCodeLine{01055     int matId;}
\DoxyCodeLine{01056     double sml;}
\DoxyCodeLine{01057     double r;}
\DoxyCodeLine{01058 }
\DoxyCodeLine{01059     inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{01060     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numParticles; i += inc) \{}
\DoxyCodeLine{01061         mt = p\_rhs.materialId[i];}
\DoxyCodeLine{01062         sml = p.h[i];}
\DoxyCodeLine{01063         matId = mt;}
\DoxyCodeLine{01064         if (matEOS[mt] != EOS\_TYPE\_VISCOUS\_REGOLITH) \{}
\DoxyCodeLine{01065             continue;}
\DoxyCodeLine{01066         \}}
\DoxyCodeLine{01067         noi = p.noi[i];}
\DoxyCodeLine{01068 }
\DoxyCodeLine{01069         for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{01070             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{01071                 edot[d][e] = 0.0;}
\DoxyCodeLine{01072             \}}
\DoxyCodeLine{01073         \}}
\DoxyCodeLine{01074         densityi = p.rho[i];}
\DoxyCodeLine{01075         x = p.x[i];}
\DoxyCodeLine{01076         y = p.y[i];}
\DoxyCodeLine{01077 \#if DIM > 2}
\DoxyCodeLine{01078         z = p.z[i];}
\DoxyCodeLine{01079 \#endif}
\DoxyCodeLine{01080          /* interaction loop */}
\DoxyCodeLine{01081         for (k = 0; k < noi; k++) \{}
\DoxyCodeLine{01082             // interacting particle id}
\DoxyCodeLine{01083             j = interactions[i * MAX\_NUM\_INTERACTIONS + k];}
\DoxyCodeLine{01084             if (EOS\_TYPE\_IGNORE == matEOS[p\_rhs.materialId[j]] || EOS\_TYPE\_IGNORE == p\_rhs.materialId[j]) \{}
\DoxyCodeLine{01085                 continue;}
\DoxyCodeLine{01086             \}}
\DoxyCodeLine{01087             densityj = p.rho[j];}
\DoxyCodeLine{01088             /* relative vector */}
\DoxyCodeLine{01089             dr[0] = dx = x -\/ p.x[j];}
\DoxyCodeLine{01090             dr[1] = dy = y -\/ p.y[j];}
\DoxyCodeLine{01091             dv[0] = dvx = p.vx[i] -\/ p.vx[j];}
\DoxyCodeLine{01092             dv[1] = dvy = p.vy[i] -\/ p.vy[j];}
\DoxyCodeLine{01093 \#if DIM > 2}
\DoxyCodeLine{01094             dr[2] = dz = z -\/ p.z[j];}
\DoxyCodeLine{01095             dv[2] = dvz = p.vz[i] -\/ p.vz[j];}
\DoxyCodeLine{01096 \#endif}
\DoxyCodeLine{01097             r = 0;}
\DoxyCodeLine{01098             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{01099                 r += dr[e]*dr[e];}
\DoxyCodeLine{01100             \}}
\DoxyCodeLine{01101             r = sqrt(r);}
\DoxyCodeLine{01102 \#if (VARIABLE\_SML || INTEGRATE\_SML || DEAL\_WITH\_TOO\_MANY\_INTERACTIONS)}
\DoxyCodeLine{01103             sml = 0.5*(p.h[i] + p.h[j]);}
\DoxyCodeLine{01104 \#endif}
\DoxyCodeLine{01105             kernel(\&W, dWdx, \&dWdr, dr, sml);}
\DoxyCodeLine{01106           //  printf("{}W \%e dWdx \%e dWdy \%e dWdz \%e i \%d j \%d dx \%e dy \%e dz \%e\(\backslash\)n"{}, W, dWdx, dWdy, dWdz, i, j, dx, dy, dz);}
\DoxyCodeLine{01107             // do calculation of edot and rdot only for real particle interaction partners and not}
\DoxyCodeLine{01108             // for boundary particle interaction partners}
\DoxyCodeLine{01109 }
\DoxyCodeLine{01110             // calculate rotation rate and strain rate}
\DoxyCodeLine{01111             // tensor}
\DoxyCodeLine{01112             // see Benz (1995) or Libersky (1993)}
\DoxyCodeLine{01113             // Warning: Benz has typos in his paper....}
\DoxyCodeLine{01114             // edot\_ab = 0.5 * (d\_b v\_a + d\_a v\_b)}
\DoxyCodeLine{01115             // rdot\_ab = 0.5 * (d\_b v\_a -\/ d\_a v\_b)}
\DoxyCodeLine{01116             tmp = p.m[j];}
\DoxyCodeLine{01117 \#if TENSORIAL\_CORRECTION}
\DoxyCodeLine{01118             tmp = -\/0.5*tmp/densityj*dWdr/r;}
\DoxyCodeLine{01119             // new implementation (after july 2017)}
\DoxyCodeLine{01120             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{01121                 for (f = 0; f < DIM; f++) \{}
\DoxyCodeLine{01122                     for (kk = 0; kk < DIM; kk++) \{}
\DoxyCodeLine{01123                         edot[e][f] += 0.5 * p.m[j]/p.rho[j] *}
\DoxyCodeLine{01124                             (p\_rhs.tensorialCorrectionMatrix[i*DIM*DIM+f*DIM+kk] *}
\DoxyCodeLine{01125                               (-\/dv[e]) * dr[kk] * dWdr/r}
\DoxyCodeLine{01126                               + p\_rhs.tensorialCorrectionMatrix[i*DIM*DIM+e*DIM+kk] *}
\DoxyCodeLine{01127                               (-\/dv[f]) * dr[kk] * dWdr/r);}
\DoxyCodeLine{01128                     \}}
\DoxyCodeLine{01129                 \}}
\DoxyCodeLine{01130             \}}
\DoxyCodeLine{01131 \#else}
\DoxyCodeLine{01132             tmp = -\/0.5*tmp/densityi;}
\DoxyCodeLine{01133             edot[0][0] += tmp*(dvx*dWdx[0] + dvx*dWdx[0]);}
\DoxyCodeLine{01134             edot[0][1] += tmp*(dvx*dWdx[1] + dvy*dWdx[0]);}
\DoxyCodeLine{01135             edot[1][0] += tmp*(dvy*dWdx[0] + dvx*dWdx[1]);}
\DoxyCodeLine{01136             edot[1][1] += tmp*(dvy*dWdx[1] + dvy*dWdx[1]);}
\DoxyCodeLine{01137 \#if DIM > 2}
\DoxyCodeLine{01138             edot[0][2] += tmp*(dvx*dWdx[2] + dvz*dWdx[0]);}
\DoxyCodeLine{01139             edot[1][2] += tmp*(dvy*dWdx[2] + dvz*dWdx[1]);}
\DoxyCodeLine{01140             edot[2][0] += tmp*(dvz*dWdx[0] + dvx*dWdx[2]);}
\DoxyCodeLine{01141             edot[2][1] += tmp*(dvz*dWdx[1] + dvy*dWdx[2]);}
\DoxyCodeLine{01142             edot[2][2] += tmp*(dvz*dWdx[2] + dvz*dWdx[2]);}
\DoxyCodeLine{01143 \#endif}
\DoxyCodeLine{01144 \#endif // TENSORIAL\_CORRECTION}
\DoxyCodeLine{01145 }
\DoxyCodeLine{01146 }
\DoxyCodeLine{01147 \#if 0}
\DoxyCodeLine{01148             if (isnan(dvx) || isnan(dvy) || isnan(dvz)) \{}
\DoxyCodeLine{01149 //                printf("{}ACCELS \%e \%e \%e\(\backslash\)n"{}, ax, ay, az);}
\DoxyCodeLine{01150                 printf("{}MATERIAL IDs \%d \%d\(\backslash\)n"{}, matId, p\_rhs.materialId[j]);}
\DoxyCodeLine{01151                 printf("{}ilocations -\/-\/-\/ jlocations \%e \%e \%e  -\/-\/-\/ \%e \%e \%e\(\backslash\)n"{}, p.x[i], p.y[i], p.z[i], p.x[j], p.y[j], p.z[j]);}
\DoxyCodeLine{01152                 printf("{}dWdx  -\/-\/-\/ \%e \%e \%e\(\backslash\)n"{}, dWdx, dWdy, dWdz);}
\DoxyCodeLine{01153                 printf("{}DX \%e \%e \%e\(\backslash\)n"{}, dx, dy, dz);}
\DoxyCodeLine{01154                 printf("{}DENSITIES: i \%e j \%e\(\backslash\)n"{}, densityi, densityj);}
\DoxyCodeLine{01155                 printf("{}PRESSURES: i \%e j \%e\(\backslash\)n"{}, p.p[i], p.p[j]);}
\DoxyCodeLine{01156                 printf("{} EDOTI"{});}
\DoxyCodeLine{01157                 for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{01158                     for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{01159                         printf("{}EDOTI[\%d][\%d] = \%e"{}, e, d, edot[e][d]);}
\DoxyCodeLine{01160                     \}}
\DoxyCodeLine{01161                \}}
\DoxyCodeLine{01162                 printf("{}TMP: \%e \(\backslash\)n"{} , tmp);}
\DoxyCodeLine{01163                 assert(1);}
\DoxyCodeLine{01164             \}}
\DoxyCodeLine{01165 \#endif}
\DoxyCodeLine{01166 }
\DoxyCodeLine{01167         \} /* interaction loop end */}
\DoxyCodeLine{01168 }
\DoxyCodeLine{01169         edottrace = 0.0;}
\DoxyCodeLine{01170         /* trace of the strain rate tensor */}
\DoxyCodeLine{01171         for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{01172             edottrace += edot[d][d];}
\DoxyCodeLine{01173         \}}
\DoxyCodeLine{01174         /* remove edottrace from edot to make traceless tensor */}
\DoxyCodeLine{01175         edot[0][0] -\/= 1./3 * edottrace;}
\DoxyCodeLine{01176         edot[1][1] -\/= 1./3 * edottrace;}
\DoxyCodeLine{01177 \#if DIM > 2}
\DoxyCodeLine{01178         edot[2][2] -\/= 1./3 * edottrace;}
\DoxyCodeLine{01179 \#endif}
\DoxyCodeLine{01180         // now let's calculate S from edot and cohesion and internal friction}
\DoxyCodeLine{01181         // formulae (26) and (29) from Ulrich et al. 2013}
\DoxyCodeLine{01182         srp = 0.0;}
\DoxyCodeLine{01183         for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{01184             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{01185                 srp += edot[d][e]*edot[d][e];}
\DoxyCodeLine{01186             \}}
\DoxyCodeLine{01187         \}}
\DoxyCodeLine{01188         //printf("{}srp: \%e\(\backslash\)n"{}, srp);}
\DoxyCodeLine{01189         srp = sqrt(4*srp);}
\DoxyCodeLine{01190         mustar = matCohesion[mt] + p.p[i]*tan(matFrictionAngle[mt]);}
\DoxyCodeLine{01191         if (srp > 0) \{}
\DoxyCodeLine{01192             mustar /= srp;}
\DoxyCodeLine{01193             if (mustar > mumax) \{}
\DoxyCodeLine{01194                 mustar = mumax;}
\DoxyCodeLine{01195             \}}
\DoxyCodeLine{01196         \} else \{}
\DoxyCodeLine{01197             mustar = mumax;}
\DoxyCodeLine{01198         \}}
\DoxyCodeLine{01199         //printf("{}\%d \%e \%e \%e \%e \%e\(\backslash\)n"{}, mt, srp, mustar,  matCohesion[mt], p.p[i], matFrictionAngle[mt]);}
\DoxyCodeLine{01200 }
\DoxyCodeLine{01201         /* deviatoric stress */}
\DoxyCodeLine{01202         for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{01203             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{01204                 p.S[stressIndex(i, d, e)] = 2*edot[d][e]*mustar;}
\DoxyCodeLine{01205             \}}
\DoxyCodeLine{01206         \}}
\DoxyCodeLine{01207 }
\DoxyCodeLine{01208     \} // loop over particles}
\DoxyCodeLine{01209 \}}
\DoxyCodeLine{01210 \#endif // VISCOUS\_REGOLITH}

\end{DoxyCode}
