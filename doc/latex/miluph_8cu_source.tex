\hypertarget{miluph_8cu_source}{}\doxysection{miluph.\+cu}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 /**}
\DoxyCodeLine{00002  * @author      Christoph Schaefer cm.schaefer@gmail.com and Thomas I. Maindl}
\DoxyCodeLine{00003  *}
\DoxyCodeLine{00004  * @section     LICENSE}
\DoxyCodeLine{00005  * Copyright (c) 2019 Christoph Schaefer}
\DoxyCodeLine{00006  *}
\DoxyCodeLine{00007  * This file is part of miluphcuda.}
\DoxyCodeLine{00008  *}
\DoxyCodeLine{00009  * miluphcuda is free software: you can redistribute it and/or modify}
\DoxyCodeLine{00010  * it under the terms of the GNU General Public License as published by}
\DoxyCodeLine{00011  * the Free Software Foundation, either version 3 of the License, or}
\DoxyCodeLine{00012  * (at your option) any later version.}
\DoxyCodeLine{00013  *}
\DoxyCodeLine{00014  * miluphcuda is distributed in the hope that it will be useful,}
\DoxyCodeLine{00015  * but WITHOUT ANY WARRANTY; without even the implied warranty of}
\DoxyCodeLine{00016  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
\DoxyCodeLine{00017  * GNU General Public License for more details.}
\DoxyCodeLine{00018  *}
\DoxyCodeLine{00019  * You should have received a copy of the GNU General Public License}
\DoxyCodeLine{00020  * along with miluphcuda.  If not, see <http://www.gnu.org/licenses/>.}
\DoxyCodeLine{00021  *}
\DoxyCodeLine{00022  */}
\DoxyCodeLine{00023 }
\DoxyCodeLine{00024 \#include "{}miluph.h"{}}
\DoxyCodeLine{00025 \#include "{}pressure.h"{}}
\DoxyCodeLine{00026 \#include "{}memory\_handling.h"{}}
\DoxyCodeLine{00027 \#include "{}device\_tools.h"{}}
\DoxyCodeLine{00028 \#include "{}kernel.h"{}}
\DoxyCodeLine{00029 \#include "{}little\_helpers.h"{}}
\DoxyCodeLine{00030 \#include <cuda\_runtime.h>}
\DoxyCodeLine{00031 }
\DoxyCodeLine{00032 \#if HDF5IO}
\DoxyCodeLine{00033 \#include <hdf5.h>}
\DoxyCodeLine{00034 \#endif}
\DoxyCodeLine{00035 }
\DoxyCodeLine{00036 \#if USE\_SIGNAL\_HANDLER}
\DoxyCodeLine{00037 \#include <unistd.h>}
\DoxyCodeLine{00038 \#include <stdlib.h>}
\DoxyCodeLine{00039 \#include <signal.h>}
\DoxyCodeLine{00040 \#include <stdio.h>}
\DoxyCodeLine{00041 volatile int terminate\_flag = 0;}
\DoxyCodeLine{00042 \#endif}
\DoxyCodeLine{00043 }
\DoxyCodeLine{00044 }
\DoxyCodeLine{00045 }
\DoxyCodeLine{00046 RunParameter param;}
\DoxyCodeLine{00047 }
\DoxyCodeLine{00048 // the pointers to the arrays on the host}
\DoxyCodeLine{00049 struct Particle p\_host;}
\DoxyCodeLine{00050 // the pointers to the arrays on the device}
\DoxyCodeLine{00051 \_\_constant\_\_ struct Particle p;}
\DoxyCodeLine{00052 // helper pointers for immutables}
\DoxyCodeLine{00053 \_\_constant\_\_ struct Particle p\_rhs;}
\DoxyCodeLine{00054 // the pointers to the arrays on the device residung on the host}
\DoxyCodeLine{00055 struct Particle p\_device;}
\DoxyCodeLine{00056 // the pointers for the runge-\/kutta substeps}
\DoxyCodeLine{00057 \_\_constant\_\_ struct Particle rk[3];}
\DoxyCodeLine{00058 struct Particle rk\_device[3];}
\DoxyCodeLine{00059 }
\DoxyCodeLine{00060 // the pointers for the predictor-\/corrector scheme}
\DoxyCodeLine{00061 struct Particle predictor\_device;}
\DoxyCodeLine{00062 \_\_constant\_\_ struct Particle predictor;}
\DoxyCodeLine{00063 }
\DoxyCodeLine{00064 // the stuff for gravitating point masses}
\DoxyCodeLine{00065 struct Pointmass pointmass\_host;}
\DoxyCodeLine{00066 \_\_constant\_\_ struct Pointmass pointmass;}
\DoxyCodeLine{00067 struct Pointmass pointmass\_device;}
\DoxyCodeLine{00068 struct Pointmass rk\_pointmass\_device[3];}
\DoxyCodeLine{00069 \_\_constant\_\_ struct Pointmass rk\_pointmass[3];}
\DoxyCodeLine{00070 struct Pointmass predictor\_pointmass\_device;}
\DoxyCodeLine{00071 \_\_constant\_\_ struct Pointmass predictor\_pointmass;}
\DoxyCodeLine{00072 int numberOfPointmasses;}
\DoxyCodeLine{00073 int memorySizeForPointmasses;}
\DoxyCodeLine{00074 }
\DoxyCodeLine{00075 }
\DoxyCodeLine{00076 int restartedRun = FALSE;}
\DoxyCodeLine{00077 }
\DoxyCodeLine{00078 extern double startTime;}
\DoxyCodeLine{00079 }
\DoxyCodeLine{00080 double treeTheta;}
\DoxyCodeLine{00081 }
\DoxyCodeLine{00082 int maxNumFlaws\_host;}
\DoxyCodeLine{00083 int *interactions;}
\DoxyCodeLine{00084 int *interactions\_host;}
\DoxyCodeLine{00085 }
\DoxyCodeLine{00086 int *childList\_host;}
\DoxyCodeLine{00087 }
\DoxyCodeLine{00088 int numberOfParticles;}
\DoxyCodeLine{00089 int numberOfRealParticles;}
\DoxyCodeLine{00090 int maxNumberOfParticles;}
\DoxyCodeLine{00091 }
\DoxyCodeLine{00092 int memorySizeForTree;}
\DoxyCodeLine{00093 int memorySizeForParticles;}
\DoxyCodeLine{00094 int memorySizeForInteractions;}
\DoxyCodeLine{00095 int memorySizeForChildren;}
\DoxyCodeLine{00096 int memorySizeForStress;}
\DoxyCodeLine{00097 \#if FRAGMENTATION}
\DoxyCodeLine{00098 int memorySizeForActivationThreshold;}
\DoxyCodeLine{00099 \#endif}
\DoxyCodeLine{00100 }
\DoxyCodeLine{00101 int numberOfMultiprocessors;}
\DoxyCodeLine{00102 }
\DoxyCodeLine{00103 int numberOfChildren = pow(2, DIM);}
\DoxyCodeLine{00104 int numberOfNodes;}
\DoxyCodeLine{00105 }
\DoxyCodeLine{00106 }
\DoxyCodeLine{00107 // the sph-\/kernel function pointers}
\DoxyCodeLine{00108 extern \_\_device\_\_ SPH\_kernel kernel;}
\DoxyCodeLine{00109 extern \_\_device\_\_ SPH\_kernel wendlandc2\_p;}
\DoxyCodeLine{00110 extern \_\_device\_\_ SPH\_kernel wendlandc4\_p;}
\DoxyCodeLine{00111 extern \_\_device\_\_ SPH\_kernel wendlandc6\_p;}
\DoxyCodeLine{00112 extern \_\_device\_\_ SPH\_kernel cubic\_spline\_p;}
\DoxyCodeLine{00113 extern \_\_device\_\_ SPH\_kernel spiky\_p;}
\DoxyCodeLine{00114 extern \_\_device\_\_ SPH\_kernel quartic\_spline\_p;}
\DoxyCodeLine{00115 SPH\_kernel kernel\_h;}
\DoxyCodeLine{00116 }
\DoxyCodeLine{00117 }
\DoxyCodeLine{00118 }
\DoxyCodeLine{00119 }
\DoxyCodeLine{00120 static void print\_compile\_information(void)}
\DoxyCodeLine{00121 \{}
\DoxyCodeLine{00122     /* give info about physical model */}
\DoxyCodeLine{00123     char yesno[10];}
\DoxyCodeLine{00124     fprintf(stdout, "{}Parameters: \(\backslash\)n"{}}
\DoxyCodeLine{00125                     "{}Number of dimensions: \%d\(\backslash\)n"{}, DIM);}
\DoxyCodeLine{00126 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00127     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00128 \#else}
\DoxyCodeLine{00129     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00130 \#endif}
\DoxyCodeLine{00131     fprintf(stdout, "{}Solve energy equation:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00132 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00133     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00134 \#else}
\DoxyCodeLine{00135     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00136 \#endif}
\DoxyCodeLine{00137     fprintf(stdout, "{}Solve continuity equation:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00138 \#if NAVIER\_STOKES}
\DoxyCodeLine{00139     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00140 \#else}
\DoxyCodeLine{00141     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00142 \#endif}
\DoxyCodeLine{00143     fprintf(stdout, "{}Solve Navier-\/Stokes equation:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00144 \#if DENSITY\_FLOOR}
\DoxyCodeLine{00145     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00146 \#else}
\DoxyCodeLine{00147     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00148 \#endif}
\DoxyCodeLine{00149     fprintf(stdout, "{}using density floor: \(\backslash\)t    \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00150 \#if SOLID}
\DoxyCodeLine{00151     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00152 \#else}
\DoxyCodeLine{00153     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00154 \#endif}
\DoxyCodeLine{00155     fprintf(stdout, "{}Solid mechanics:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00156 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00157     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00158 \#else}
\DoxyCodeLine{00159     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00160 \#endif}
\DoxyCodeLine{00161     fprintf(stdout, "{}Additional point masses: \(\backslash\)t \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00162 \#if FRAGMENTATION}
\DoxyCodeLine{00163     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00164 \#else}
\DoxyCodeLine{00165     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00166 \#endif}
\DoxyCodeLine{00167     fprintf(stdout, "{}Fracture model:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00168 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00169     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00170 \#else}
\DoxyCodeLine{00171     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00172 \#endif}
\DoxyCodeLine{00173     fprintf(stdout, "{}P-\/alpha porosity model:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00174 \#if SIRONO\_POROSITY}
\DoxyCodeLine{00175     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00176 \#else}
\DoxyCodeLine{00177     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00178 \#endif}
\DoxyCodeLine{00179     fprintf(stdout, "{}Sirono porosity model:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00180 \#if EPSALPHA\_POROSITY}
\DoxyCodeLine{00181     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00182 \#else}
\DoxyCodeLine{00183     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00184 \#endif}
\DoxyCodeLine{00185     fprintf(stdout, "{}Epsilon-\/alpha porosity model:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00186 \#if VON\_MISES\_PLASTICITY}
\DoxyCodeLine{00187     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00188 \#else}
\DoxyCodeLine{00189     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00190 \#endif}
\DoxyCodeLine{00191     fprintf(stdout, "{}Plasticity model:\(\backslash\)t  \%s"{}, yesno);}
\DoxyCodeLine{00192 \#if VON\_MISES\_PLASTICITY}
\DoxyCodeLine{00193 \#if MOHR\_COULOMB\_PLASTICITY}
\DoxyCodeLine{00194     fprintf(stdout, "{}\(\backslash\)t\(\backslash\)t\(\backslash\)t Mohr-\/Coulomb\(\backslash\)n"{});}
\DoxyCodeLine{00195 \#elif DRUCKER\_PRAGER\_PLASTICITY}
\DoxyCodeLine{00196     fprintf(stdout, "{}\(\backslash\)t\(\backslash\)t\(\backslash\)t Drucker-\/Prager\(\backslash\)n"{});}
\DoxyCodeLine{00197 \#elif COLLINS\_PRESSURE\_DEPENDENT\_YIELD\_STRENGTH}
\DoxyCodeLine{00198     fprintf(stdout, "{}\(\backslash\)t\(\backslash\)t\(\backslash\)t Pressure dependent yield strength with cohesion for damaged material\(\backslash\)n"{});}
\DoxyCodeLine{00199 \#else}
\DoxyCodeLine{00200     fprintf(stdout, "{}\(\backslash\)t\(\backslash\)t\(\backslash\)t simple von Mises yield criterion\(\backslash\)n"{});}
\DoxyCodeLine{00201 \#endif}
\DoxyCodeLine{00202 \#else}
\DoxyCodeLine{00203     fprintf(stdout, "{}\(\backslash\)n"{});}
\DoxyCodeLine{00204 \#endif}
\DoxyCodeLine{00205 \#if JC\_PLASTICITY}
\DoxyCodeLine{00206     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00207 \#else}
\DoxyCodeLine{00208     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00209 \#endif}
\DoxyCodeLine{00210     fprintf(stdout, "{}Plasticity model from Johnson -\/ Cook:\(\backslash\)t   \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00211 \#if TENSORIAL\_CORRECTION}
\DoxyCodeLine{00212     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00213 \#else}
\DoxyCodeLine{00214     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00215 \#endif}
\DoxyCodeLine{00216     fprintf(stdout, "{}SPH linear consistency for strain rate and rotation rate tensor only:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00217 \#if ARTIFICIAL\_VISCOSITY}
\DoxyCodeLine{00218     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00219 \#else}
\DoxyCodeLine{00220     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00221 \#endif}
\DoxyCodeLine{00222     fprintf(stdout, "{}Using SPH representation of momentum and energy conservation version: \(\backslash\)t"{}}
\DoxyCodeLine{00223 \#if SPHEQUATIONS == SPH\_VERSION1}
\DoxyCodeLine{00224                         "{}SPH\_VERSION1"{}}
\DoxyCodeLine{00225 \#elif SPHEQUATIONS == SPH\_VERSION2}
\DoxyCodeLine{00226                         "{}SPH\_VERSION2"{}}
\DoxyCodeLine{00227 \#endif}
\DoxyCodeLine{00228                         "{}\(\backslash\)n"{});}
\DoxyCodeLine{00229     fprintf(stdout, "{}Standard SPH artificial viscosity:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00230 \#if XSPH}
\DoxyCodeLine{00231     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00232 \#else}
\DoxyCodeLine{00233     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00234 \#endif}
\DoxyCodeLine{00235     fprintf(stdout, "{}XSPH velocity smoothing:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00236 \#if VARIABLE\_SML}
\DoxyCodeLine{00237     fprintf(stdout, "{}Using variable smoothing:\(\backslash\)t yes\(\backslash\)n"{});}
\DoxyCodeLine{00238 \#if FIXED\_NOI}
\DoxyCodeLine{00239     fprintf(stdout, "{}\(\backslash\)t\(\backslash\)t with fixed number of interaction partners.\(\backslash\)n"{});}
\DoxyCodeLine{00240 \#elif INTEGRATE\_SML}
\DoxyCodeLine{00241     fprintf(stdout, "{}\(\backslash\)t\(\backslash\)t with integration of the smoothing length.\(\backslash\)n"{});}
\DoxyCodeLine{00242 \#else}
\DoxyCodeLine{00243 \#error no such scheme for VARIABLE\_SML}
\DoxyCodeLine{00244 \#endif}
\DoxyCodeLine{00245     fprintf(stdout, "{}Using fixed smoothing lengths: \(\backslash\)t no\(\backslash\)n"{});}
\DoxyCodeLine{00246 \#else}
\DoxyCodeLine{00247     fprintf(stdout, "{}Using variable smoothing:\(\backslash\)t no\(\backslash\)n"{});}
\DoxyCodeLine{00248     fprintf(stdout, "{}Using fixed smoothing lengths: \(\backslash\)t yes\(\backslash\)n"{});}
\DoxyCodeLine{00249 \#endif}
\DoxyCodeLine{00250 \#if READ\_INITIAL\_SML\_FROM\_PARTICLE\_FILE}
\DoxyCodeLine{00251     fprintf(stdout, "{}Reading initial smoothing length for each particle.\(\backslash\)n"{});}
\DoxyCodeLine{00252 \#endif}
\DoxyCodeLine{00253 \#if GHOST\_BOUNDARIES}
\DoxyCodeLine{00254     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00255 \#else}
\DoxyCodeLine{00256     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00257 \#endif}
\DoxyCodeLine{00258     fprintf(stdout, "{}ghost boundaries:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00259     fprintf(stdout, "{}boundary particle id: \%d\(\backslash\)n"{}, BOUNDARY\_PARTICLE\_ID);}
\DoxyCodeLine{00260 \#if HDF5IO}
\DoxyCodeLine{00261     strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00262 \#else}
\DoxyCodeLine{00263     strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00264 \#endif}
\DoxyCodeLine{00265     fprintf(stdout, "{}HDF5 i/o:\(\backslash\)t  \%s\(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00266     if (param.verbose) \{}
\DoxyCodeLine{00267         if (param.hdf5output) \{}
\DoxyCodeLine{00268             strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00269         \} else \{}
\DoxyCodeLine{00270             strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00271         \}}
\DoxyCodeLine{00272         fprintf(stdout, "{}using HDF5 output: \(\backslash\)t \%s \(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00273         if (param.hdf5input) \{}
\DoxyCodeLine{00274             strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00275         \} else \{}
\DoxyCodeLine{00276             strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00277         \}}
\DoxyCodeLine{00278         fprintf(stdout, "{}using HDF5 input: \(\backslash\)t \%s \(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00279         if (param.ascii\_output) \{}
\DoxyCodeLine{00280             strcpy(yesno, "{}yes"{});}
\DoxyCodeLine{00281         \} else \{}
\DoxyCodeLine{00282             strcpy(yesno, "{}no"{});}
\DoxyCodeLine{00283         \}}
\DoxyCodeLine{00284         fprintf(stdout, "{}using ASCII output: \(\backslash\)t \%s \(\backslash\)n"{}, yesno);}
\DoxyCodeLine{00285     \}}
\DoxyCodeLine{00286 }
\DoxyCodeLine{00287     fprintf(stdout, "{}implemented equations of state and corresponding eos type entry in material.cfg:\(\backslash\)n"{});}
\DoxyCodeLine{00288     fprintf(stdout, "{}EOS\_TYPE\_IGNORE          \(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_IGNORE);}
\DoxyCodeLine{00289     fprintf(stdout, "{}EOS\_TYPE\_POLYTROPIC\_GAS  \(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_POLYTROPIC\_GAS);}
\DoxyCodeLine{00290     fprintf(stdout, "{}EOS\_TYPE\_MURNAGHAN       \(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_MURNAGHAN);}
\DoxyCodeLine{00291     fprintf(stdout, "{}EOS\_TYPE\_TILLOTSON       \(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_TILLOTSON);}
\DoxyCodeLine{00292     fprintf(stdout, "{}EOS\_TYPE\_ISOTHERMAL\_GAS  \(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_ISOTHERMAL\_GAS);}
\DoxyCodeLine{00293     fprintf(stdout, "{}EOS\_TYPE\_REGOLITH        \(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_REGOLITH);}
\DoxyCodeLine{00294     fprintf(stdout, "{}EOS\_TYPE\_JUTZI           \(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_JUTZI);}
\DoxyCodeLine{00295     fprintf(stdout, "{}EOS\_TYPE\_JUTZI\_MURNAGHAN \(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_JUTZI\_MURNAGHAN);}
\DoxyCodeLine{00296     fprintf(stdout, "{}EOS\_TYPE\_ANEOS           \(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_ANEOS);}
\DoxyCodeLine{00297     fprintf(stdout, "{}EOS\_TYPE\_VISCOUS\_REGOLITH\(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_VISCOUS\_REGOLITH);}
\DoxyCodeLine{00298     fprintf(stdout, "{}EOS\_TYPE\_IDEAL\_GAS       \(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_IDEAL\_GAS);}
\DoxyCodeLine{00299     fprintf(stdout, "{}EOS\_TYPE\_SIRONO          \(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_SIRONO);}
\DoxyCodeLine{00300     fprintf(stdout, "{}EOS\_TYPE\_EPSILON         \(\backslash\)t\(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_EPSILON);}
\DoxyCodeLine{00301     fprintf(stdout, "{}EOS\_TYPE\_LOCALLY\_ISOTHERMAL\_GAS \(\backslash\)t\(\backslash\)t \%d\(\backslash\)n"{}, EOS\_TYPE\_LOCALLY\_ISOTHERMAL\_GAS);}
\DoxyCodeLine{00302 }
\DoxyCodeLine{00303 }
\DoxyCodeLine{00304 \}}
\DoxyCodeLine{00305 }
\DoxyCodeLine{00306 static void format\_information(char *name)}
\DoxyCodeLine{00307 \{}
\DoxyCodeLine{00308     char physics[10];}
\DoxyCodeLine{00309     int noc = 0;}
\DoxyCodeLine{00310     int i, j, k;}
\DoxyCodeLine{00311 \#if SOLID}
\DoxyCodeLine{00312     strcpy(physics, "{}solid"{});}
\DoxyCodeLine{00313 \#else}
\DoxyCodeLine{00314     strcpy(physics, "{}hydro"{});}
\DoxyCodeLine{00315 \#endif}
\DoxyCodeLine{00316 }
\DoxyCodeLine{00317     fprintf(stdout, "{}Data file format for \%s\(\backslash\)n"{}, name);}
\DoxyCodeLine{00318     fprintf(stdout, "{}dimension = \%d\(\backslash\)n"{}, DIM);}
\DoxyCodeLine{00319     fprintf(stdout, "{}\%s version (hydro or solid): \%s\(\backslash\)n"{}, name, physics);}
\DoxyCodeLine{00320     fprintf(stdout, "{}\(\backslash\)n"{});}
\DoxyCodeLine{00321     fprintf(stdout, "{}input file format for file <string.XXXX>:\(\backslash\)n"{});}
\DoxyCodeLine{00322     for (i = 0; i < DIM; i++)}
\DoxyCodeLine{00323         fprintf(stdout, "{}\%d:x[\%d] "{}, i+1, i);}
\DoxyCodeLine{00324     noc = DIM; /* x */}
\DoxyCodeLine{00325     for (i = noc, j = 0; i < noc+DIM; i++, j++)}
\DoxyCodeLine{00326         fprintf(stdout, "{}\%d:v[\%d] "{}, i+1, j);}
\DoxyCodeLine{00327     noc += DIM; /* v */}
\DoxyCodeLine{00328     noc++;  /* m */}
\DoxyCodeLine{00329     fprintf(stdout, "{}\%d:mass "{}, noc);}
\DoxyCodeLine{00330 \#if INTEGRATE\_DENSITY}
\DoxyCodeLine{00331     noc++;   /* rho */}
\DoxyCodeLine{00332     fprintf(stdout, "{}\%d:density "{}, noc);}
\DoxyCodeLine{00333 \#endif}
\DoxyCodeLine{00334 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00335     noc++;   /* e */}
\DoxyCodeLine{00336     fprintf(stdout, "{}\%d:energy "{}, noc);}
\DoxyCodeLine{00337 \#endif}
\DoxyCodeLine{00338 \#if READ\_INITIAL\_SML\_FROM\_PARTICLE\_FILE}
\DoxyCodeLine{00339     noc++; /* smoothing length */}
\DoxyCodeLine{00340     fprintf(stdout, "{}\%d:smoothing length "{}, noc);}
\DoxyCodeLine{00341 \#endif}
\DoxyCodeLine{00342     noc++; /* material\_type */}
\DoxyCodeLine{00343     fprintf(stdout, "{}\%d:material type "{}, noc);}
\DoxyCodeLine{00344 \#if JC\_PLASTICITY}
\DoxyCodeLine{00345     noc++;   /* ep */}
\DoxyCodeLine{00346     fprintf(stdout, "{}\%d:strain "{}, noc);}
\DoxyCodeLine{00347     noc++;   /* T */}
\DoxyCodeLine{00348     fprintf(stdout, "{}\%d:temperature "{}, noc);}
\DoxyCodeLine{00349 \#endif}
\DoxyCodeLine{00350 \#if FRAGMENTATION}
\DoxyCodeLine{00351     noc++; /* number of flaws */}
\DoxyCodeLine{00352     fprintf(stdout, "{}\%d:number of flaws "{}, noc);}
\DoxyCodeLine{00353     noc++; /* damage */}
\DoxyCodeLine{00354     fprintf(stdout, "{}\%d:DIM-\/root of tensile damage "{}, noc);}
\DoxyCodeLine{00355 \#endif}
\DoxyCodeLine{00356 \#if SOLID}
\DoxyCodeLine{00357     k = noc+1;}
\DoxyCodeLine{00358     for (i = 0; i < DIM; i++) \{}
\DoxyCodeLine{00359         for (j = 0; j < DIM; j++) \{}
\DoxyCodeLine{00360             fprintf(stdout, "{}\%d:S/sigma[\%d][\%d] "{}, k, i, j);}
\DoxyCodeLine{00361             k++;}
\DoxyCodeLine{00362         \}}
\DoxyCodeLine{00363     \}}
\DoxyCodeLine{00364     noc += DIM*DIM; /* S */}
\DoxyCodeLine{00365 \#endif}
\DoxyCodeLine{00366 \#if SIRONO\_POROSITY}
\DoxyCodeLine{00367     noc++;  /* rho\_0prime */}
\DoxyCodeLine{00368     fprintf(stdout, "{}\%d:rho\_0prime "{}, noc);}
\DoxyCodeLine{00369     noc++;  /* rho\_c\_plus */}
\DoxyCodeLine{00370     fprintf(stdout, "{}\%d:rho\_c\_plus "{}, noc);}
\DoxyCodeLine{00371     noc++;  /* rho\_c\_minus */}
\DoxyCodeLine{00372     fprintf(stdout, "{}\%d:rho\_c\_minus "{}, noc);}
\DoxyCodeLine{00373     noc++;  /* compressive\_strength */}
\DoxyCodeLine{00374     fprintf(stdout, "{}\%d:compressive\_strength "{}, noc);}
\DoxyCodeLine{00375     noc++;  /* tensile\_strength */}
\DoxyCodeLine{00376     fprintf(stdout, "{}\%d:tensile\_strength "{}, noc);}
\DoxyCodeLine{00377     noc++;  /* bulk modulus K */}
\DoxyCodeLine{00378     fprintf(stdout, "{}\%d:bulk modulus K "{}, noc);}
\DoxyCodeLine{00379     noc++;  /* flag\_rho\_0prime */}
\DoxyCodeLine{00380     fprintf(stdout, "{}\%d:flag\_rho\_0prime "{}, noc);}
\DoxyCodeLine{00381     noc++;  /* flag\_plastic */}
\DoxyCodeLine{00382     fprintf(stdout, "{}\%d:flag\_plastic "{}, noc);}
\DoxyCodeLine{00383     noc++;  /* shear\_strength */}
\DoxyCodeLine{00384     fprintf(stdout, "{}\%d:shear\_strength "{}, noc);}
\DoxyCodeLine{00385 \#endif}
\DoxyCodeLine{00386 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00387     noc++; /* alpha\_jutzi */}
\DoxyCodeLine{00388     fprintf(stdout, "{}\%d:alpha\_jutzi "{}, noc);}
\DoxyCodeLine{00389     noc++; /* pressure */}
\DoxyCodeLine{00390     fprintf(stdout, "{}\%d:pressure "{}, noc);}
\DoxyCodeLine{00391 \#endif}
\DoxyCodeLine{00392 \#if EPSALPHA\_POROSITY}
\DoxyCodeLine{00393     noc++; /* alpha\_epspor */}
\DoxyCodeLine{00394     fprintf(stdout, "{}\%d:alpha\_epspor "{}, noc);}
\DoxyCodeLine{00395     noc++; /* epsilon\_v */}
\DoxyCodeLine{00396     fprintf(stdout, "{}\%d:epsilon\_v "{}, noc);}
\DoxyCodeLine{00397 \#endif}
\DoxyCodeLine{00398 \#if FRAGMENTATION}
\DoxyCodeLine{00399     noc++;}
\DoxyCodeLine{00400     fprintf(stdout, "{}\%d-\/>\%d+number of flaws:activation thresholds for this particle\(\backslash\)n"{}, noc, noc);}
\DoxyCodeLine{00401 \#endif}
\DoxyCodeLine{00402     fprintf(stdout, "{}\(\backslash\)n"{});}
\DoxyCodeLine{00403 \#if HDF5IO}
\DoxyCodeLine{00404     fprintf(stdout, "{}output file format: (non-\/hdf5, for hdf5 use h5ls):\(\backslash\)n"{});}
\DoxyCodeLine{00405 \#else}
\DoxyCodeLine{00406     fprintf(stdout, "{}output file format: only ascii since HDF5IO was not defined during compile time:\(\backslash\)n"{});}
\DoxyCodeLine{00407 \#endif}
\DoxyCodeLine{00408 }
\DoxyCodeLine{00409     for (i = 0; i < DIM; i++)}
\DoxyCodeLine{00410         fprintf(stdout, "{}\%d:x[\%d] "{}, i+1, i);}
\DoxyCodeLine{00411     noc = DIM; /* x */}
\DoxyCodeLine{00412     for (i = noc, j = 0; i < noc+DIM; i++, j++)}
\DoxyCodeLine{00413         fprintf(stdout, "{}\%d:v[\%d] "{}, i+1, j);}
\DoxyCodeLine{00414     noc += DIM; /* v */}
\DoxyCodeLine{00415     noc++;  /* m */}
\DoxyCodeLine{00416     fprintf(stdout, "{}\%d:mass "{}, noc);}
\DoxyCodeLine{00417     noc++;   /* rho */}
\DoxyCodeLine{00418     fprintf(stdout, "{}\%d:density "{}, noc);}
\DoxyCodeLine{00419     noc++;   /* e */}
\DoxyCodeLine{00420 \#if INTEGRATE\_ENERGY}
\DoxyCodeLine{00421     fprintf(stdout, "{}\%d:energy "{}, noc);}
\DoxyCodeLine{00422     noc++; /* sml */}
\DoxyCodeLine{00423 \#endif}
\DoxyCodeLine{00424     fprintf(stdout, "{}\%d:smoothing length "{}, noc);}
\DoxyCodeLine{00425     noc++; /* number of interaction partners */}
\DoxyCodeLine{00426     fprintf(stdout, "{}\%d:number of interaction partners "{}, noc);}
\DoxyCodeLine{00427     noc++; /* material\_type */}
\DoxyCodeLine{00428     fprintf(stdout, "{}\%d:material type "{}, noc);}
\DoxyCodeLine{00429 \#if JC\_PLASTICITY}
\DoxyCodeLine{00430     noc++;   /* ep */}
\DoxyCodeLine{00431     fprintf(stdout, "{}\%d:strain "{}, noc);}
\DoxyCodeLine{00432     noc++;   /* T */}
\DoxyCodeLine{00433     fprintf(stdout, "{}\%d:temperature "{}, noc);}
\DoxyCodeLine{00434 \#endif}
\DoxyCodeLine{00435 \#if FRAGMENTATION}
\DoxyCodeLine{00436     noc++; /* number of flaws */}
\DoxyCodeLine{00437     fprintf(stdout, "{}\%d:number of flaws "{}, noc);}
\DoxyCodeLine{00438     noc++; /* number of activated flaws */}
\DoxyCodeLine{00439     fprintf(stdout, "{}\%d:number of activated flaws "{}, noc);}
\DoxyCodeLine{00440     noc++; /* damage */}
\DoxyCodeLine{00441     fprintf(stdout, "{}\%d:DIM-\/root of tensile damage "{}, noc);}
\DoxyCodeLine{00442 \#endif}
\DoxyCodeLine{00443 \#if !PALPHA\_POROSITY}
\DoxyCodeLine{00444     noc++; /* pressure */}
\DoxyCodeLine{00445     fprintf(stdout, "{}\%d:pressure "{}, noc);}
\DoxyCodeLine{00446 \#endif}
\DoxyCodeLine{00447 \#if SOLID}
\DoxyCodeLine{00448     noc++; /* local\_strain  */}
\DoxyCodeLine{00449     fprintf(stdout, "{}\%d:local\_strain "{}, noc);}
\DoxyCodeLine{00450     k = noc+1;}
\DoxyCodeLine{00451     for (i = 0; i < DIM; i++) \{}
\DoxyCodeLine{00452         for (j = 0; j < DIM; j++) \{}
\DoxyCodeLine{00453             fprintf(stdout, "{}\%d:S/sigma[\%d][\%d] "{}, k, i, j);}
\DoxyCodeLine{00454             k++;}
\DoxyCodeLine{00455         \}}
\DoxyCodeLine{00456     \}}
\DoxyCodeLine{00457     noc += DIM*DIM; /* S */}
\DoxyCodeLine{00458 \#endif}
\DoxyCodeLine{00459 \#if NAVIER\_STOKES}
\DoxyCodeLine{00460     k = noc+1;}
\DoxyCodeLine{00461     for (i = 0; i < DIM; i++) \{}
\DoxyCodeLine{00462         for (j = 0; j < DIM; j++) \{}
\DoxyCodeLine{00463             fprintf(stdout, "{}\%d:Tshear[\%d][\%d] "{}, k, i, j);}
\DoxyCodeLine{00464             k++;}
\DoxyCodeLine{00465         \}}
\DoxyCodeLine{00466     \}}
\DoxyCodeLine{00467     noc += DIM*DIM; /* Tshear */}
\DoxyCodeLine{00468 \#endif}
\DoxyCodeLine{00469 \#if SIRONO\_POROSITY}
\DoxyCodeLine{00470     noc++;  /* rho\_0prime */}
\DoxyCodeLine{00471     fprintf(stdout, "{}\%d:rho\_0prime "{}, noc);}
\DoxyCodeLine{00472     noc++;  /* rho\_c\_plus */}
\DoxyCodeLine{00473     fprintf(stdout, "{}\%d:rho\_c\_plus "{}, noc);}
\DoxyCodeLine{00474     noc++;  /* rho\_c\_minus */}
\DoxyCodeLine{00475     fprintf(stdout, "{}\%d:rho\_c\_minus "{}, noc);}
\DoxyCodeLine{00476     noc++;  /* compressive\_strength */}
\DoxyCodeLine{00477     fprintf(stdout, "{}\%d:compressive\_strength "{}, noc);}
\DoxyCodeLine{00478     noc++;  /* tensile\_strength */}
\DoxyCodeLine{00479     fprintf(stdout, "{}\%d:tensile\_strength "{}, noc);}
\DoxyCodeLine{00480     noc++;  /* bulk modulus K */}
\DoxyCodeLine{00481     fprintf(stdout, "{}\%d:bulk modulus K "{}, noc);}
\DoxyCodeLine{00482     noc++;  /* flag\_rho\_0prime */}
\DoxyCodeLine{00483     fprintf(stdout, "{}\%d:flag\_rho\_0prime "{}, noc);}
\DoxyCodeLine{00484     noc++;  /* flag\_plastic */}
\DoxyCodeLine{00485     fprintf(stdout, "{}\%d:flag\_plastic "{}, noc);}
\DoxyCodeLine{00486     noc++;  /* shear\_strength */}
\DoxyCodeLine{00487     fprintf(stdout, "{}\%d:shear\_strength "{}, noc);}
\DoxyCodeLine{00488 \#endif}
\DoxyCodeLine{00489 \#if PALPHA\_POROSITY}
\DoxyCodeLine{00490     noc++; /* alpha\_jutzi */}
\DoxyCodeLine{00491     fprintf(stdout, "{}\%d:alpha\_jutzi "{}, noc);}
\DoxyCodeLine{00492     noc++; /* pressure */}
\DoxyCodeLine{00493     fprintf(stdout, "{}\%d:pressure "{}, noc);}
\DoxyCodeLine{00494 \#endif}
\DoxyCodeLine{00495 \#if EPSALPHA\_POROSITY}
\DoxyCodeLine{00496     noc++; /* alpha\_epspor */}
\DoxyCodeLine{00497     fprintf(stdout, "{}\%d:alpha\_epspor "{}, noc);}
\DoxyCodeLine{00498     noc++; /* epsilon\_v */}
\DoxyCodeLine{00499     fprintf(stdout, "{}\%d:epsilon\_v "{}, noc);}
\DoxyCodeLine{00500 \#endif}
\DoxyCodeLine{00501 \#if FRAGMENTATION}
\DoxyCodeLine{00502     noc++;}
\DoxyCodeLine{00503     fprintf(stdout, "{}\%d-\/>\%d+number of flaws:activation thresholds for this particle\(\backslash\)n"{}, noc, noc);}
\DoxyCodeLine{00504 \#endif}
\DoxyCodeLine{00505     fprintf(stdout, "{}\(\backslash\)n"{});}
\DoxyCodeLine{00506     fprintf(stdout, "{}Additional information (such as time, momentum, energy, and angular momentum of the particle distribution is stored in <string.XXXX>.info\(\backslash\)n"{});}
\DoxyCodeLine{00507 }
\DoxyCodeLine{00508 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00509     fprintf(stdout, "{}Data file format for <string.XXXX>.mass\(\backslash\)n"{});}
\DoxyCodeLine{00510     for (i = 0; i < DIM; i++) \{}
\DoxyCodeLine{00511         fprintf(stdout, "{}\%d:x[\%d] "{}, i+1, i);}
\DoxyCodeLine{00512     \}}
\DoxyCodeLine{00513     for (i = 0; i < DIM; i++) \{}
\DoxyCodeLine{00514         fprintf(stdout, "{}\%d:v[\%d] "{}, i+DIM+1, i);}
\DoxyCodeLine{00515     \}}
\DoxyCodeLine{00516     fprintf(stdout, "{}\%d:mass \%d:rmin \%d:rmax"{}, DIM+DIM+1, DIM+DIM+2, DIM+DIM+3);}
\DoxyCodeLine{00517     fprintf(stdout, "{}\(\backslash\)n"{});}
\DoxyCodeLine{00518 \#if HDF5IO}
\DoxyCodeLine{00519     fprintf(stdout, "{}output file format for <string.XXXX>.mass: (non-\/hdf5, for hdf5 use h5ls):\(\backslash\)n"{});}
\DoxyCodeLine{00520 \#else}
\DoxyCodeLine{00521     fprintf(stdout, "{}output file format for <string.XXXX>.mass: only ascii since HDF5IO was not defined during compile time:\(\backslash\)n"{});}
\DoxyCodeLine{00522 \#endif}
\DoxyCodeLine{00523     for (i = 0; i < DIM; i++) \{}
\DoxyCodeLine{00524         fprintf(stdout, "{}\%d:x[\%d] "{}, i+1, i);}
\DoxyCodeLine{00525     \}}
\DoxyCodeLine{00526     for (i = 0; i < DIM; i++) \{}
\DoxyCodeLine{00527         fprintf(stdout, "{}\%d:v[\%d] "{}, i+DIM+1, i);}
\DoxyCodeLine{00528     \}}
\DoxyCodeLine{00529     fprintf(stdout, "{}\%d:mass \%d:rmin \%d:rmax"{}, DIM+DIM+1, DIM+DIM+2, DIM+DIM+3);}
\DoxyCodeLine{00530     fprintf(stdout, "{}\(\backslash\)n"{});}
\DoxyCodeLine{00531 \#endif}
\DoxyCodeLine{00532 }
\DoxyCodeLine{00533 \}}
\DoxyCodeLine{00534 }
\DoxyCodeLine{00535 }
\DoxyCodeLine{00536 }
\DoxyCodeLine{00537 void usage(char *name) \{}
\DoxyCodeLine{00538     fprintf(stderr,}
\DoxyCodeLine{00539             "{}Usage \%s [options]\(\backslash\)n"{}}
\DoxyCodeLine{00540             "{}   sph program, version \%s.\(\backslash\)n"{}}
\DoxyCodeLine{00541             "{}Best options:\(\backslash\)n"{}}
\DoxyCodeLine{00542             "{}\(\backslash\)t-\/h, -\/-\/help\(\backslash\)t\(\backslash\)t\(\backslash\)t This message.\(\backslash\)n"{}}
\DoxyCodeLine{00543             "{}\(\backslash\)t-\/v, -\/-\/verbose\(\backslash\)t\(\backslash\)t\(\backslash\)t Be talkative (stdout).\(\backslash\)n\(\backslash\)n"{}}
\DoxyCodeLine{00544             "{}Available options:\(\backslash\)n"{}}
\DoxyCodeLine{00545             "{}\(\backslash\)t-\/a, -\/-\/theta\(\backslash\)t\(\backslash\)t\(\backslash\)t Theta Criterion for Barnes-\/Hut Tree (default: 0.5)\(\backslash\)n"{}}
\DoxyCodeLine{00546             "{}\(\backslash\)t-\/A, -\/-\/no\_ascii\_output \(\backslash\)t\(\backslash\)t Disable ASCII output files (default is FALSE).\(\backslash\)n"{}}
\DoxyCodeLine{00547             "{}\(\backslash\)t-\/b, -\/-\/boundary\_ratio\(\backslash\)t\(\backslash\)t Ratio of additional ghost boundary particles (default: 0).\(\backslash\)n"{}}
\DoxyCodeLine{00548             "{}\(\backslash\)t-\/d, -\/-\/device\_id <int> \(\backslash\)t\(\backslash\)t Try to use device with id <int> for computation (default: 0).\(\backslash\)n"{}}
\DoxyCodeLine{00549             "{}\(\backslash\)t-\/D, -\/-\/directselfgravity\(\backslash\)t\(\backslash\)t Calculate selfgravity using direct particle-\/particle force and not the tree (slower).\(\backslash\)n"{}}
\DoxyCodeLine{00550             "{}\(\backslash\)t-\/f, -\/-\/filename\(\backslash\)t\(\backslash\)t\(\backslash\)t Name of input data file (default: disk.0000).\(\backslash\)n"{}}
\DoxyCodeLine{00551             "{}\(\backslash\)t\(\backslash\)t\(\backslash\)t\(\backslash\)t\(\backslash\)t Input data file name format is something like 'string'.XXXX, where\(\backslash\)n"{}}
\DoxyCodeLine{00552             "{}\(\backslash\)t\(\backslash\)t\(\backslash\)t\(\backslash\)t\(\backslash\)t XXXX means runlevel and zeros.\(\backslash\)n"{}}
\DoxyCodeLine{00553             "{}\(\backslash\)t-\/g, -\/-\/decouplegravity\(\backslash\)t\(\backslash\)t Decouple hydro time scale from gravitational time scale.\(\backslash\)n"{}}
\DoxyCodeLine{00554             "{}\(\backslash\)t-\/G, -\/-\/information\(\backslash\)t\(\backslash\)t Print information about detected nvidia GPUs on this host.\(\backslash\)n"{}}
\DoxyCodeLine{00555 \#if HDF5IO}
\DoxyCodeLine{00556             "{}\(\backslash\)t-\/H, -\/-\/hdf5\_output \(\backslash\)t\(\backslash\)t Use hdf5 for output (default is FALSE).\(\backslash\)n"{}}
\DoxyCodeLine{00557 \#endif}
\DoxyCodeLine{00558             "{}\(\backslash\)t-\/I, -\/-\/integrator\(\backslash\)t\(\backslash\)t Available Integrators are euler (1st order), euler\_pc and monaghan\_pc (2nd order),\(\backslash\)n"{}}
\DoxyCodeLine{00559             "{}\(\backslash\)t\(\backslash\)t\(\backslash\)t\(\backslash\)t\(\backslash\)t rk2\_adaptive (2nd order with adaptive time step).\(\backslash\)n"{}}
\DoxyCodeLine{00560             "{}\(\backslash\)t-\/k, -\/-\/kernel\(\backslash\)t\(\backslash\)t\(\backslash\)t use kernel function (default: cubic\_spline)\(\backslash\)n"{}}
\DoxyCodeLine{00561             "{}\(\backslash\)t      \(\backslash\)t\(\backslash\)t\(\backslash\)t\(\backslash\)t possible values: wendlandc2, wendlandc4, wendlandc6, cubic\_spline, quartic\_spline, spiky.\(\backslash\)n"{}}
\DoxyCodeLine{00562             "{}\(\backslash\)t-\/L, -\/-\/angular\_momentum <value> \(\backslash\)t Check for conservation of angular momentum. (default: off)\(\backslash\)n"{}}
\DoxyCodeLine{00563             "{}\(\backslash\)t\(\backslash\)t\(\backslash\)t\(\backslash\)t\(\backslash\)t Simulations stops once the relative difference between current angular momentum and initial angular momentum is larger than <value>.\(\backslash\)n"{}}
\DoxyCodeLine{00564             "{}\(\backslash\)t-\/m, -\/-\/materialconfig\(\backslash\)t\(\backslash\)t Name of config file including material config\(\backslash\)n"{}}
\DoxyCodeLine{00565             "{}\(\backslash\)t-\/M, -\/-\/maxtimestep\(\backslash\)t\(\backslash\)t Upper limit for the timestep (rk2\_integrator), timestep size for euler, respectively.\(\backslash\)n"{}}
\DoxyCodeLine{00566             "{}\(\backslash\)t-\/n, -\/-\/num\(\backslash\)t\(\backslash\)t\(\backslash\)t Number of simulation steps.\(\backslash\)n"{}}
\DoxyCodeLine{00567             "{}\(\backslash\)t-\/Y, -\/-\/format\(\backslash\)t\(\backslash\)t\(\backslash\)t Print information about input and output format of the data files,\(\backslash\)n"{}}
\DoxyCodeLine{00568             "{}\(\backslash\)t\(\backslash\)t\(\backslash\)t\(\backslash\)t\(\backslash\)t and about the compile time options of the binary.\(\backslash\)n"{}}
\DoxyCodeLine{00569             "{}\(\backslash\)t-\/Q, -\/-\/precision\(\backslash\)t\(\backslash\)t\(\backslash\)t Precision of the rk2\_adaptive integrator (default: 1e-\/6).\(\backslash\)n"{}}
\DoxyCodeLine{00570             "{}\(\backslash\)t-\/r, -\/-\/restart\(\backslash\)t\(\backslash\)t\(\backslash\)t Assume that ascii input file is old output file.\(\backslash\)n"{}}
\DoxyCodeLine{00571             "{}\(\backslash\)t-\/s, -\/-\/selfgravity\(\backslash\)t\(\backslash\)t Use selfgravity.\(\backslash\)n"{}}
\DoxyCodeLine{00572             "{}\(\backslash\)t-\/t, -\/-\/timeperstep\(\backslash\)t\(\backslash\)t Time for one simulation step.\(\backslash\)n"{}}
\DoxyCodeLine{00573             "{}\(\backslash\)t-\/T, -\/-\/starttime\(\backslash\)t\(\backslash\)t\(\backslash\)t Start time of simulation.\(\backslash\)n"{}}
\DoxyCodeLine{00574 \#if HDF5IO}
\DoxyCodeLine{00575             "{}\(\backslash\)t-\/X, -\/-\/hdf5\_input \(\backslash\)t\(\backslash\)t Use hdf5 for input (default is FALSE), file 'string'.XXXX.h5 will be opened.\(\backslash\)n"{}}
\DoxyCodeLine{00576 \#endif}
\DoxyCodeLine{00577             "{}\(\backslash\)nTake a deep look at parameter.h. There you do necessary physical settings.\(\backslash\)n"{}}
\DoxyCodeLine{00578             "{}Authors: Christoph Schaefer, Sven Riecker, Oliver Wandel, Samuel Scherrer, Christoph Burger, Thomas Maindl.\(\backslash\)n"{}}
\DoxyCodeLine{00579             "{}More information on github: https://github.com/christophmschaefer/miluphcuda\(\backslash\)n"{},}
\DoxyCodeLine{00580         name, VERSION);}
\DoxyCodeLine{00581     exit(0);}
\DoxyCodeLine{00582 \}}
\DoxyCodeLine{00583 }
\DoxyCodeLine{00584 int main(int argc, char *argv[]) \{}
\DoxyCodeLine{00585     // default run parameter}
\DoxyCodeLine{00586     param.performanceTest = FALSE;}
\DoxyCodeLine{00587     numberOfParticles = 0;}
\DoxyCodeLine{00588     numberOfPointmasses = 0;}
\DoxyCodeLine{00589     timePerStep = 1.0;}
\DoxyCodeLine{00590     startTime = 0.0;}
\DoxyCodeLine{00591     int wanted\_device = 0;}
\DoxyCodeLine{00592     char configFile[255];}
\DoxyCodeLine{00593     strcpy(configFile, "{}material.cfg"{});}
\DoxyCodeLine{00594     // default integration scheme}
\DoxyCodeLine{00595     char integrationscheme[255] = "{}rk2\_adaptive"{};}
\DoxyCodeLine{00596 }
\DoxyCodeLine{00597     static struct option opts[] = \{}
\DoxyCodeLine{00598         \{ "{}verbose"{}, 0, NULL, 'v' \},}
\DoxyCodeLine{00599         \{ "{}restart"{}, 0, NULL, 'r' \},}
\DoxyCodeLine{00600         \{ "{}numberoftimesteps"{}, 1, NULL, 'n' \},}
\DoxyCodeLine{00601         \{ "{}device\_id"{}, 1, NULL, 'd' \},}
\DoxyCodeLine{00602         \{ "{}timeperstep"{}, 1, NULL, 't' \},}
\DoxyCodeLine{00603         \{ "{}maxtimestep"{}, 1, NULL, 'M' \},}
\DoxyCodeLine{00604         \{ "{}starttime"{}, 1, NULL, 'T' \},}
\DoxyCodeLine{00605         \{ "{}theta"{}, 1, NULL, 'a' \},}
\DoxyCodeLine{00606         \{ "{}precision"{}, 1, NULL, 'Q' \},}
\DoxyCodeLine{00607         \{ "{}hdf5\_output"{}, 0, NULL, 'H' \},}
\DoxyCodeLine{00608         \{ "{}hdf5\_input"{}, 0, NULL, 'X' \},}
\DoxyCodeLine{00609         \{ "{}no\_ascii\_output"{}, 0, NULL, 'A' \},}
\DoxyCodeLine{00610         \{ "{}decouplegravity"{}, 0, NULL, 'g' \},}
\DoxyCodeLine{00611         \{ "{}format"{}, 0, NULL, 'Y' \},}
\DoxyCodeLine{00612         \{ "{}filename"{}, 1,        NULL, 'f' \},}
\DoxyCodeLine{00613         \{ "{}angular\_momentum"{}, 1,        NULL, 'L' \},}
\DoxyCodeLine{00614         \{ "{}kernel"{}, 1,  NULL, 'k' \},}
\DoxyCodeLine{00615         \{ "{}materialconfig"{}, 1, NULL, 'm'\},}
\DoxyCodeLine{00616         \{ "{}selfgravity"{}, 0, NULL, 's' \},}
\DoxyCodeLine{00617         \{ "{}directselfgravity"{}, 0, NULL, 'D' \},}
\DoxyCodeLine{00618         \{ "{}help"{}, 0, NULL, 'h' \},}
\DoxyCodeLine{00619         \{ "{}information"{}, 0, NULL, 'G' \},}
\DoxyCodeLine{00620         \{ "{}integrator"{}, 1, NULL, 'I' \},}
\DoxyCodeLine{00621         \{ "{}boundary\_ratio"{}, 0, NULL, 'b'\},}
\DoxyCodeLine{00622         \{ NULL, 0, 0, 0 \}}
\DoxyCodeLine{00623     \};}
\DoxyCodeLine{00624 }
\DoxyCodeLine{00625     if (argc == 1) \{}
\DoxyCodeLine{00626         usage(argv[0]);}
\DoxyCodeLine{00627     \}}
\DoxyCodeLine{00628 }
\DoxyCodeLine{00629 }
\DoxyCodeLine{00630 }
\DoxyCodeLine{00631     param.hdf5input = FALSE;}
\DoxyCodeLine{00632     param.hdf5output = FALSE;}
\DoxyCodeLine{00633     param.restart = FALSE;}
\DoxyCodeLine{00634     param.ascii\_output = TRUE;}
\DoxyCodeLine{00635     param.maxtimestep = -\/1;}
\DoxyCodeLine{00636     param.rk\_epsrel = 1e-\/6;}
\DoxyCodeLine{00637     param.angular\_momentum\_check = -\/1.0;}
\DoxyCodeLine{00638     strcpy(param.kernel, "{}cubic\_spline"{});}
\DoxyCodeLine{00639     param.boundary\_ratio = 0;}
\DoxyCodeLine{00640 }
\DoxyCodeLine{00641     treeTheta = 0.5; // default theta}
\DoxyCodeLine{00642     param.selfgravity = FALSE;}
\DoxyCodeLine{00643     param.directselfgravity = FALSE;}
\DoxyCodeLine{00644     param.decouplegravity = 0;}
\DoxyCodeLine{00645 }
\DoxyCodeLine{00646 \#if USE\_SIGNAL\_HANDLER}
\DoxyCodeLine{00647     signal(SIGINT, signal\_handler);}
\DoxyCodeLine{00648 \#endif}
\DoxyCodeLine{00649 }
\DoxyCodeLine{00650     int i, c;}
\DoxyCodeLine{00651     while ((c = getopt\_long(argc, argv, "{}Q:d:M:b:m:L:k:T:DI:t:a:n:f:b:rXYvhHshVgGA"{}, opts, \&i)) != -\/1) \{}
\DoxyCodeLine{00652         switch (c) \{}
\DoxyCodeLine{00653             case 'M':}
\DoxyCodeLine{00654                 param.maxtimestep = atof(optarg);}
\DoxyCodeLine{00655                 if (param.maxtimestep < 0) \{}
\DoxyCodeLine{00656                     fprintf(stderr, "{}Error. Maximum possible timestep should be > 0.\(\backslash\)n"{});}
\DoxyCodeLine{00657                     exit(1);}
\DoxyCodeLine{00658                 \}}
\DoxyCodeLine{00659                 break;}
\DoxyCodeLine{00660             case 'Q':}
\DoxyCodeLine{00661                 param.rk\_epsrel = atof(optarg);}
\DoxyCodeLine{00662                 if (param.rk\_epsrel < 0 || param.rk\_epsrel >= 1) \{}
\DoxyCodeLine{00663                     fprintf(stderr, "{}Error. Accuracy of the rk2 integrator should be 0 < rk\_epsrel < 1."{});}
\DoxyCodeLine{00664                     exit(1);}
\DoxyCodeLine{00665                 \}}
\DoxyCodeLine{00666                 break;}
\DoxyCodeLine{00667             case 'G':}
\DoxyCodeLine{00668                 printfDeviceInformation();}
\DoxyCodeLine{00669                 exit(0);}
\DoxyCodeLine{00670                 break;}
\DoxyCodeLine{00671             case 'd':}
\DoxyCodeLine{00672                 wanted\_device = atoi(optarg);}
\DoxyCodeLine{00673                 printfDeviceInformation();}
\DoxyCodeLine{00674                 fprintf(stdout, "{}Trying to use CUDA device \%d\(\backslash\)n"{}, wanted\_device);}
\DoxyCodeLine{00675                 cudaSetDevice(wanted\_device);}
\DoxyCodeLine{00676                 break;}
\DoxyCodeLine{00677             case 'g':}
\DoxyCodeLine{00678                 param.decouplegravity = 1;}
\DoxyCodeLine{00679                 break;}
\DoxyCodeLine{00680             case 'A':}
\DoxyCodeLine{00681                 param.ascii\_output = FALSE;}
\DoxyCodeLine{00682                 break;}
\DoxyCodeLine{00683             case 'L':}
\DoxyCodeLine{00684                 param.angular\_momentum\_check = atof(optarg);}
\DoxyCodeLine{00685                 if (param.angular\_momentum\_check < 0) \{}
\DoxyCodeLine{00686                     fprintf(stderr, "{}angular\_momentum value should be > 0.\(\backslash\)n"{});}
\DoxyCodeLine{00687                     exit(1);}
\DoxyCodeLine{00688                 \}}
\DoxyCodeLine{00689                 break;}
\DoxyCodeLine{00690             case 'b':}
\DoxyCodeLine{00691                 param.boundary\_ratio = atof(optarg);}
\DoxyCodeLine{00692                 if (param.boundary\_ratio < 0) \{}
\DoxyCodeLine{00693                     fprintf(stderr, "{}Boundary particle ratio should be positive.\(\backslash\)n"{});}
\DoxyCodeLine{00694                     exit(1);}
\DoxyCodeLine{00695                 \}}
\DoxyCodeLine{00696                 break;}
\DoxyCodeLine{00697             case 'a':}
\DoxyCodeLine{00698                 treeTheta = atof(optarg);}
\DoxyCodeLine{00699                 param.selfgravity = TRUE;}
\DoxyCodeLine{00700                 if (treeTheta < 0 || treeTheta >= 1) \{}
\DoxyCodeLine{00701                     fprintf(stderr, "{}Er? Check theta.\(\backslash\)n"{});}
\DoxyCodeLine{00702                     exit(1);}
\DoxyCodeLine{00703                 \}}
\DoxyCodeLine{00704                 break;}
\DoxyCodeLine{00705             case 'v':}
\DoxyCodeLine{00706                 param.verbose = TRUE;}
\DoxyCodeLine{00707                 break;}
\DoxyCodeLine{00708             case 'r':}
\DoxyCodeLine{00709                 param.restart = TRUE;}
\DoxyCodeLine{00710                 break;}
\DoxyCodeLine{00711             case 'T':}
\DoxyCodeLine{00712                 startTime = atof(optarg);}
\DoxyCodeLine{00713                 if (startTime < 0) \{}
\DoxyCodeLine{00714                     fprintf(stderr, "{}Hm? Negative start time?\(\backslash\)n"{});}
\DoxyCodeLine{00715                     exit(1);}
\DoxyCodeLine{00716                 \}}
\DoxyCodeLine{00717                 break;}
\DoxyCodeLine{00718             case 't':}
\DoxyCodeLine{00719                 timePerStep = atof(optarg);}
\DoxyCodeLine{00720                 if (timePerStep < 0) \{}
\DoxyCodeLine{00721                     fprintf(stderr, "{}Huh? Check time per step.\(\backslash\)n"{});}
\DoxyCodeLine{00722                     exit(1);}
\DoxyCodeLine{00723                 \}}
\DoxyCodeLine{00724                 break;}
\DoxyCodeLine{00725             case 'f':}
\DoxyCodeLine{00726                 if (!strcpy(inputFile.name, optarg))}
\DoxyCodeLine{00727                     exit(1);}
\DoxyCodeLine{00728                 break;}
\DoxyCodeLine{00729             case 'n':}
\DoxyCodeLine{00730                 numberOfTimesteps = atoi(optarg);}
\DoxyCodeLine{00731                 if (numberOfTimesteps < 0) \{}
\DoxyCodeLine{00732                     fprintf(stderr, "{}Invalid number of simulation steps.\(\backslash\)n"{});}
\DoxyCodeLine{00733                     exit(1);}
\DoxyCodeLine{00734                 \}}
\DoxyCodeLine{00735                 break;}
\DoxyCodeLine{00736             case 'm':}
\DoxyCodeLine{00737                 if (!strcpy(configFile, optarg)) \{}
\DoxyCodeLine{00738                     fprintf(stderr, "{}Something wrong with material config file."{});}
\DoxyCodeLine{00739                     exit(1);}
\DoxyCodeLine{00740                 \}}
\DoxyCodeLine{00741                 break;}
\DoxyCodeLine{00742             case 's':}
\DoxyCodeLine{00743                 param.selfgravity = TRUE;}
\DoxyCodeLine{00744                 break;}
\DoxyCodeLine{00745             case 'D':}
\DoxyCodeLine{00746                 param.directselfgravity = TRUE;}
\DoxyCodeLine{00747                 break;}
\DoxyCodeLine{00748             case 'H':}
\DoxyCodeLine{00749                 param.hdf5output = TRUE;}
\DoxyCodeLine{00750                 break;}
\DoxyCodeLine{00751             case 'X':}
\DoxyCodeLine{00752                 param.hdf5input = TRUE;}
\DoxyCodeLine{00753                 break;}
\DoxyCodeLine{00754             case 'I':}
\DoxyCodeLine{00755                 if (!strcpy(integrationscheme, optarg)) \{}
\DoxyCodeLine{00756                     fprintf(stderr, "{}Something's wrong with the integrator name.\(\backslash\)n"{});}
\DoxyCodeLine{00757                     exit(1);}
\DoxyCodeLine{00758                 \}}
\DoxyCodeLine{00759                 break;}
\DoxyCodeLine{00760             case 'k':}
\DoxyCodeLine{00761                 if (!strcpy(param.kernel, optarg)) \{}
\DoxyCodeLine{00762                     fprintf(stderr, "{}Something's wrong with the kernel function.\(\backslash\)n"{});}
\DoxyCodeLine{00763                     exit(1);}
\DoxyCodeLine{00764                 \}}
\DoxyCodeLine{00765                 break;}
\DoxyCodeLine{00766             case 'Y':}
\DoxyCodeLine{00767                 format\_information(argv[0]);}
\DoxyCodeLine{00768                 print\_compile\_information();}
\DoxyCodeLine{00769                 exit(0);}
\DoxyCodeLine{00770             case 'h':}
\DoxyCodeLine{00771                 usage(argv[0]);}
\DoxyCodeLine{00772                 exit(0);}
\DoxyCodeLine{00773             default:}
\DoxyCodeLine{00774                 usage(argv[0]);}
\DoxyCodeLine{00775                 exit(0);}
\DoxyCodeLine{00776         \}}
\DoxyCodeLine{00777     \}}
\DoxyCodeLine{00778 }
\DoxyCodeLine{00779     // get the information about the number of particles in the file}
\DoxyCodeLine{00780     if ((inputFile.data = fopen(inputFile.name, "{}r"{})) == NULL) \{}
\DoxyCodeLine{00781         fprintf(stderr, "{}Wtf? File \%s not found.\(\backslash\)n"{}, inputFile.name);}
\DoxyCodeLine{00782         if (param.hdf5input) \{}
\DoxyCodeLine{00783 \#if HDF5IO}
\DoxyCodeLine{00784             fprintf(stderr, "{}Hope you know what you're up to and search for a h5 file\(\backslash\)n"{});}
\DoxyCodeLine{00785             char h5filename[256];}
\DoxyCodeLine{00786             strcpy(h5filename, inputFile.name);}
\DoxyCodeLine{00787             strcat(h5filename, "{}.h5"{});}
\DoxyCodeLine{00788 }
\DoxyCodeLine{00789             hid\_t file\_id = H5Fopen (h5filename, H5F\_ACC\_RDONLY, H5P\_DEFAULT);}
\DoxyCodeLine{00790             if (file\_id < 0) \{}
\DoxyCodeLine{00791                 fprintf(stderr, "{}********************** Error opening file \%s\(\backslash\)n"{}, h5filename);}
\DoxyCodeLine{00792                 exit(1);}
\DoxyCodeLine{00793             \} else \{}
\DoxyCodeLine{00794                 fprintf(stdout, "{}Using hdf5 input file \%s\(\backslash\)n"{}, h5filename);}
\DoxyCodeLine{00795             \}}
\DoxyCodeLine{00796 }
\DoxyCodeLine{00797             /* open the dataset for the positions */}
\DoxyCodeLine{00798             hid\_t x\_id = H5Dopen(file\_id, "{}/x"{}, H5P\_DEFAULT);}
\DoxyCodeLine{00799             if (x\_id < 0) \{}
\DoxyCodeLine{00800                 fprintf(stderr, "{}Could not find locations in hdf5 file.  Exiting.\(\backslash\)n"{});}
\DoxyCodeLine{00801             \}}
\DoxyCodeLine{00802             /* determine number of particles stored in hdf5 file */}
\DoxyCodeLine{00803             hid\_t dspace = H5Dget\_space(x\_id);}
\DoxyCodeLine{00804             const int ndims = H5Sget\_simple\_extent\_ndims(dspace);}
\DoxyCodeLine{00805             hsize\_t dims[ndims];}
\DoxyCodeLine{00806             H5Sget\_simple\_extent\_dims(dspace, dims, NULL);}
\DoxyCodeLine{00807             int my\_anop = dims[0];}
\DoxyCodeLine{00808             fprintf(stdout, "{}Found \%d particles in \%s.\(\backslash\)n"{}, my\_anop, h5filename);}
\DoxyCodeLine{00809             numberOfParticles = my\_anop;}
\DoxyCodeLine{00810             H5Fclose(file\_id);}
\DoxyCodeLine{00811 \#endif}
\DoxyCodeLine{00812         \} else \{}
\DoxyCodeLine{00813             exit(1);}
\DoxyCodeLine{00814         \}}
\DoxyCodeLine{00815     \} else \{}
\DoxyCodeLine{00816         // reading number of lines in file}
\DoxyCodeLine{00817         int count = 0;}
\DoxyCodeLine{00818         char c;}
\DoxyCodeLine{00819         for (c = getc(inputFile.data); c != EOF; c = getc(inputFile.data)) \{}
\DoxyCodeLine{00820             if (c == '\(\backslash\)n') \{}
\DoxyCodeLine{00821                 count++;}
\DoxyCodeLine{00822             \}}
\DoxyCodeLine{00823         \}}
\DoxyCodeLine{00824         fprintf(stdout, "{}Found \%d particles in \%s.\(\backslash\)n"{}, count, inputFile.name);}
\DoxyCodeLine{00825         fclose(inputFile.data);}
\DoxyCodeLine{00826         numberOfParticles = count;}
\DoxyCodeLine{00827     \}}
\DoxyCodeLine{00828 }
\DoxyCodeLine{00829 \#if GRAVITATING\_POINT\_MASSES}
\DoxyCodeLine{00830     // get the information about the number of particles in mass file}
\DoxyCodeLine{00831     char massfilename[256];}
\DoxyCodeLine{00832     FILE *inputf;}
\DoxyCodeLine{00833     strcpy(massfilename, inputFile.name);}
\DoxyCodeLine{00834     strcat(massfilename, "{}.mass"{});}
\DoxyCodeLine{00835 }
\DoxyCodeLine{00836     if ((inputf = fopen(massfilename, "{}r"{})) == NULL) \{}
\DoxyCodeLine{00837         fprintf(stderr, "{}File for the point masses \%s not found.\(\backslash\)n"{}, massfilename);}
\DoxyCodeLine{00838         if (param.hdf5input) \{}
\DoxyCodeLine{00839 \# if HDF5IO}
\DoxyCodeLine{00840             fprintf(stderr, "{}Hope you know what you're up to and search for a h5 file\(\backslash\)n"{});}
\DoxyCodeLine{00841             char h5filename[256];}
\DoxyCodeLine{00842             strcpy(h5filename, inputFile.name);}
\DoxyCodeLine{00843             strcat(h5filename, "{}.mass.h5"{});}
\DoxyCodeLine{00844 }
\DoxyCodeLine{00845             hid\_t file\_id = H5Fopen (h5filename, H5F\_ACC\_RDONLY, H5P\_DEFAULT);}
\DoxyCodeLine{00846             if (file\_id < 0) \{}
\DoxyCodeLine{00847                 fprintf(stderr, "{}********************** Error opening file \%s\(\backslash\)n"{}, h5filename);}
\DoxyCodeLine{00848                 exit(1);}
\DoxyCodeLine{00849             \} else \{}
\DoxyCodeLine{00850                 fprintf(stdout, "{}Using hdf5 input file \%s\(\backslash\)n"{}, h5filename);}
\DoxyCodeLine{00851             \}}
\DoxyCodeLine{00852 }
\DoxyCodeLine{00853             /* open the dataset for the positions */}
\DoxyCodeLine{00854             hid\_t x\_id = H5Dopen(file\_id, "{}/x"{}, H5P\_DEFAULT);}
\DoxyCodeLine{00855             if (x\_id < 0) \{}
\DoxyCodeLine{00856                 fprintf(stderr, "{}Could not find locations in hdf5 file.  Exiting.\(\backslash\)n"{});}
\DoxyCodeLine{00857             \}}
\DoxyCodeLine{00858             /* determine number of particles stored in hdf5 file */}
\DoxyCodeLine{00859             hid\_t dspace = H5Dget\_space(x\_id);}
\DoxyCodeLine{00860             const int ndims = H5Sget\_simple\_extent\_ndims(dspace);}
\DoxyCodeLine{00861             hsize\_t dims[ndims];}
\DoxyCodeLine{00862             H5Sget\_simple\_extent\_dims(dspace, dims, NULL);}
\DoxyCodeLine{00863             int my\_anop = dims[0];}
\DoxyCodeLine{00864             fprintf(stdout, "{}Found \%d point masses in \%s.\(\backslash\)n"{}, my\_anop, h5filename);}
\DoxyCodeLine{00865             numberOfPointmasses = my\_anop;}
\DoxyCodeLine{00866             H5Fclose(file\_id);}
\DoxyCodeLine{00867 \# endif}
\DoxyCodeLine{00868         \} else \{}
\DoxyCodeLine{00869             exit(1);}
\DoxyCodeLine{00870         \}}
\DoxyCodeLine{00871     \} else \{}
\DoxyCodeLine{00872         // reading number of lines in file}
\DoxyCodeLine{00873         int count = 0;}
\DoxyCodeLine{00874         char c;}
\DoxyCodeLine{00875         for (c = getc(inputf); c != EOF; c = getc(inputf)) \{}
\DoxyCodeLine{00876             if (c == '\(\backslash\)n') \{}
\DoxyCodeLine{00877                 count++;}
\DoxyCodeLine{00878             \}}
\DoxyCodeLine{00879         \}}
\DoxyCodeLine{00880         fprintf(stdout, "{}Found \%d particles in \%s.\(\backslash\)n"{}, count, massfilename);}
\DoxyCodeLine{00881         fclose(inputf);}
\DoxyCodeLine{00882         numberOfPointmasses = count;}
\DoxyCodeLine{00883     \}}
\DoxyCodeLine{00884 \#endif}
\DoxyCodeLine{00885 }
\DoxyCodeLine{00886     maxNumberOfParticles = (int) ( (1+param.boundary\_ratio) * numberOfParticles);}
\DoxyCodeLine{00887     numberOfRealParticles = numberOfParticles;}
\DoxyCodeLine{00888 }
\DoxyCodeLine{00889     if (param.verbose) \{}
\DoxyCodeLine{00890         print\_compile\_information();}
\DoxyCodeLine{00891     \}}
\DoxyCodeLine{00892 }
\DoxyCodeLine{00893     if (param.selfgravity \&\& param.directselfgravity) \{}
\DoxyCodeLine{00894         fprintf(stderr, "{}Warning: both selfgravity and directselfgravity parameters are set.\(\backslash\)n"{});}
\DoxyCodeLine{00895         fprintf(stderr, "{}unsetting selfgravity and using directselfgravity.\(\backslash\)n"{});}
\DoxyCodeLine{00896         param.selfgravity = FALSE;}
\DoxyCodeLine{00897     \}}
\DoxyCodeLine{00898 }
\DoxyCodeLine{00899 }
\DoxyCodeLine{00900     // check for plasticity model}
\DoxyCodeLine{00901 \#if VON\_MISES\_PLASTICITY \&\& JC\_PLASTICITY}
\DoxyCodeLine{00902     fprintf(stderr, "{}Error: Can't use both Von Mises and Johnson-\/Cook Plasticity Models at the same time. Decide for one and recompile.\(\backslash\)n"{});}
\DoxyCodeLine{00903     exit(1);}
\DoxyCodeLine{00904 \#endif}
\DoxyCodeLine{00905 }
\DoxyCodeLine{00906     // choose integrator}
\DoxyCodeLine{00907     fprintf(stdout, "{}Integrator information\(\backslash\)n"{});}
\DoxyCodeLine{00908     if (0 == strcmp(integrationscheme, "{}rk2\_adaptive"{})) \{}
\DoxyCodeLine{00909         fprintf(stdout, "{}using rk2 adaptive\(\backslash\)n"{});}
\DoxyCodeLine{00910         integrator = \&rk2Adaptive;}
\DoxyCodeLine{00911         param.integrator\_type = RK2\_ADAPTIVE;}
\DoxyCodeLine{00912         printf("{}with accurary rk\_epsrel: \%g\(\backslash\)n"{}, param.rk\_epsrel);}
\DoxyCodeLine{00913     \} else if (0 == strcmp(integrationscheme, "{}euler"{})) \{}
\DoxyCodeLine{00914         fprintf(stdout, "{}using euler\(\backslash\)n"{});}
\DoxyCodeLine{00915         integrator = \&euler;}
\DoxyCodeLine{00916         param.integrator\_type = EULER;}
\DoxyCodeLine{00917     \} else if (0 == strcmp(integrationscheme, "{}monaghan\_pc"{})) \{}
\DoxyCodeLine{00918         fprintf(stdout, "{}using monaghan\_pc\(\backslash\)n"{});}
\DoxyCodeLine{00919         integrator = \&predictor\_corrector;}
\DoxyCodeLine{00920         param.integrator\_type = MONAGHAN\_PC;}
\DoxyCodeLine{00921     \} else if (0 == strcmp(integrationscheme, "{}euler\_pc"{})) \{}
\DoxyCodeLine{00922         fprintf(stdout, "{}using euler\_pc\(\backslash\)n"{});}
\DoxyCodeLine{00923         integrator = \&predictor\_corrector\_euler;}
\DoxyCodeLine{00924         param.integrator\_type = EULER\_PC;}
\DoxyCodeLine{00925     \} else \{}
\DoxyCodeLine{00926         fprintf(stderr, "{}Err. No such integration scheme implemented yet.\(\backslash\)n"{});}
\DoxyCodeLine{00927         exit(1);}
\DoxyCodeLine{00928     \}}
\DoxyCodeLine{00929 }
\DoxyCodeLine{00930     // choose SPH kernel}
\DoxyCodeLine{00931     fprintf(stdout, "{}SPH kernel information\(\backslash\)t"{});}
\DoxyCodeLine{00932     if (0 == strcmp(param.kernel, "{}wendlandc2"{})) \{}
\DoxyCodeLine{00933         fprintf(stdout, "{}using wendlandc2 kernel\(\backslash\)n"{});}
\DoxyCodeLine{00934         cudaMemcpyFromSymbol(\&kernel\_h, wendlandc2\_p, sizeof(SPH\_kernel));}
\DoxyCodeLine{00935         cudaMemcpyToSymbol(kernel, \&kernel\_h, sizeof(SPH\_kernel));}
\DoxyCodeLine{00936     \} else if (0 == strcmp(param.kernel, "{}wendlandc4"{})) \{}
\DoxyCodeLine{00937         fprintf(stdout, "{}using wendlandc4 kernel\(\backslash\)n"{});}
\DoxyCodeLine{00938         cudaMemcpyFromSymbol(\&kernel\_h, wendlandc4\_p, sizeof(SPH\_kernel));}
\DoxyCodeLine{00939         cudaMemcpyToSymbol(kernel, \&kernel\_h, sizeof(SPH\_kernel));}
\DoxyCodeLine{00940     \} else if (0 == strcmp(param.kernel, "{}wendlandc6"{})) \{}
\DoxyCodeLine{00941         fprintf(stdout, "{}using wendlandc6 kernel\(\backslash\)n"{});}
\DoxyCodeLine{00942         cudaMemcpyFromSymbol(\&kernel\_h, wendlandc6\_p, sizeof(SPH\_kernel));}
\DoxyCodeLine{00943         cudaMemcpyToSymbol(kernel, \&kernel\_h, sizeof(SPH\_kernel));}
\DoxyCodeLine{00944     \} else if (0 == strcmp(param.kernel, "{}cubic\_spline"{})) \{}
\DoxyCodeLine{00945         fprintf(stdout, "{}using cubic\_spline kernel\(\backslash\)n"{});}
\DoxyCodeLine{00946         cudaMemcpyFromSymbol(\&kernel\_h, cubic\_spline\_p, sizeof(SPH\_kernel));}
\DoxyCodeLine{00947         cudaMemcpyToSymbol(kernel, \&kernel\_h, sizeof(SPH\_kernel));}
\DoxyCodeLine{00948     \} else if (0 == strcmp(param.kernel, "{}spiky"{})) \{}
\DoxyCodeLine{00949         fprintf(stdout, "{}using spiky kernel\(\backslash\)n"{});}
\DoxyCodeLine{00950         cudaMemcpyFromSymbol(\&kernel\_h, spiky\_p, sizeof(SPH\_kernel));}
\DoxyCodeLine{00951         cudaMemcpyToSymbol(kernel, \&kernel\_h, sizeof(SPH\_kernel));}
\DoxyCodeLine{00952     \} else if (0 == strcmp(param.kernel, "{}quartic\_spline"{})) \{}
\DoxyCodeLine{00953         fprintf(stdout, "{}using quartic\_spline kernel\(\backslash\)n"{});}
\DoxyCodeLine{00954         cudaMemcpyFromSymbol(\&kernel\_h, quartic\_spline\_p, sizeof(SPH\_kernel));}
\DoxyCodeLine{00955         cudaMemcpyToSymbol(kernel, \&kernel\_h, sizeof(SPH\_kernel));}
\DoxyCodeLine{00956     \} else \{}
\DoxyCodeLine{00957         fprintf(stderr, "{}Err. No such kernel function implemented yet: \%s.\(\backslash\)n"{}, param.kernel);}
\DoxyCodeLine{00958         exit(1);}
\DoxyCodeLine{00959     \}}
\DoxyCodeLine{00960 }
\DoxyCodeLine{00961     // print out selfgravity information}
\DoxyCodeLine{00962     fprintf(stdout, "{}Self gravity information\(\backslash\)t"{});}
\DoxyCodeLine{00963     if (param.selfgravity) \{}
\DoxyCodeLine{00964         fprintf(stdout, "{}calculating selfgravity with Barnes Hut tree with theta: \%g\(\backslash\)n"{}, treeTheta);}
\DoxyCodeLine{00965     \} else if (param.directselfgravity) \{}
\DoxyCodeLine{00966         fprintf(stdout, "{}calculating selfgravity using direct particle-\/particle force.\(\backslash\)n"{});}
\DoxyCodeLine{00967     \} else \{}
\DoxyCodeLine{00968         fprintf(stdout, "{}neglecting selfgravity.\(\backslash\)n"{});}
\DoxyCodeLine{00969     \}}
\DoxyCodeLine{00970 }
\DoxyCodeLine{00971 }
\DoxyCodeLine{00972     if (param.maxtimestep < 0)}
\DoxyCodeLine{00973         param.maxtimestep = timePerStep;}
\DoxyCodeLine{00974 }
\DoxyCodeLine{00975     if (param.verbose) printf("{}loading config file...\(\backslash\)n"{});}
\DoxyCodeLine{00976 }
\DoxyCodeLine{00977     loadConfigFromFile(configFile);}
\DoxyCodeLine{00978 }
\DoxyCodeLine{00979     if (param.verbose) printf("{}clearing performance file...\(\backslash\)n"{});}
\DoxyCodeLine{00980 }
\DoxyCodeLine{00981     if (param.performanceTest) clear\_performance\_file();}
\DoxyCodeLine{00982 }
\DoxyCodeLine{00983     if (param.verbose) printf("{}N = \%d\(\backslash\)n"{}, numberOfParticles);}
\DoxyCodeLine{00984     if (param.verbose) printf("{}Allocating memory for \%d particles\(\backslash\)n"{}, maxNumberOfParticles);}
\DoxyCodeLine{00985 }
\DoxyCodeLine{00986     if (param.verbose) printf("{}checking for cuda devices...\(\backslash\)n"{});}
\DoxyCodeLine{00987 }
\DoxyCodeLine{00988     // check cuda}
\DoxyCodeLine{00989     cudaDeviceProp deviceProp;}
\DoxyCodeLine{00990     int cnt;}
\DoxyCodeLine{00991     cudaVerify(cudaGetDeviceProperties(\&deviceProp, wanted\_device));}
\DoxyCodeLine{00992     cudaGetDeviceCount(\&cnt);}
\DoxyCodeLine{00993     if ((deviceProp.major == 9999) \&\& (deviceProp.minor == 9999)) \{}
\DoxyCodeLine{00994         fprintf(stderr, "{}There is no CUDA capable device\(\backslash\)n"{});}
\DoxyCodeLine{00995         exit(-\/1);}
\DoxyCodeLine{00996     \}}
\DoxyCodeLine{00997     fprintf(stdout, "{}Found compute capability \%d.\%d\(\backslash\)n"{}, deviceProp.major, deviceProp.minor);}
\DoxyCodeLine{00998     fprintf(stdout, "{}Need at least compute capability 2.0\(\backslash\)n"{});}
\DoxyCodeLine{00999     fprintf(stdout, "{}Found \#gpus \%d: \%s\(\backslash\)n"{}, cnt, deviceProp.name);}
\DoxyCodeLine{01000     numberOfMultiprocessors = deviceProp.multiProcessorCount;}
\DoxyCodeLine{01001     if (param.verbose) printf("{}found cuda device with \%d multiprocessors.\(\backslash\)n"{}, numberOfMultiprocessors);}
\DoxyCodeLine{01002 }
\DoxyCodeLine{01003 }
\DoxyCodeLine{01004     /* initialise the memory */}
\DoxyCodeLine{01005     init\_allocate\_memory();}
\DoxyCodeLine{01006 }
\DoxyCodeLine{01007 }
\DoxyCodeLine{01008     // read particle data from input file}
\DoxyCodeLine{01009     if (param.verbose) printf("{}reading input file \%s ...\(\backslash\)n"{}, inputFile.name);}
\DoxyCodeLine{01010     if ((inputFile.data = fopen(inputFile.name, "{}r"{})) == NULL) \{}
\DoxyCodeLine{01011         fprintf(stderr, "{}Wtf? File \%s not found.\(\backslash\)n"{}, inputFile.name);}
\DoxyCodeLine{01012         if (param.hdf5input) \{}
\DoxyCodeLine{01013             fprintf(stderr, "{}Hope you know what you're up to and search for a h5 file\(\backslash\)n"{});}
\DoxyCodeLine{01014             read\_particles\_from\_file(inputFile);}
\DoxyCodeLine{01015         \} else \{}
\DoxyCodeLine{01016             exit(1);}
\DoxyCodeLine{01017         \}}
\DoxyCodeLine{01018     \} else \{}
\DoxyCodeLine{01019         read\_particles\_from\_file(inputFile);}
\DoxyCodeLine{01020         fclose(inputFile.data);}
\DoxyCodeLine{01021     \}}
\DoxyCodeLine{01022 }
\DoxyCodeLine{01023     /* init some values */}
\DoxyCodeLine{01024     init\_values();}
\DoxyCodeLine{01025     // copy the particles to the gpu}
\DoxyCodeLine{01026     copy\_particle\_data\_to\_device();}
\DoxyCodeLine{01027     if (cudaSuccess != cudaMemcpyToSymbol(childList, \&childListd, sizeof(void*))) \{}
\DoxyCodeLine{01028         fprintf(stderr, "{}copying of childList to device failed\(\backslash\)n"{});}
\DoxyCodeLine{01029         exit(1);}
\DoxyCodeLine{01030     \}}
\DoxyCodeLine{01031 }
\DoxyCodeLine{01032     /* if hdf5 output is enabled and no hdf5 input is set, write the ascii input file to hdf5 */}
\DoxyCodeLine{01033     if (param.hdf5output \&\& !param.hdf5input) \{}
\DoxyCodeLine{01034         if (param.verbose) \{}
\DoxyCodeLine{01035             fprintf(stdout, "{}Writing input ascii file to hdf5 \%s.h5\(\backslash\)n"{}, inputFile.name);}
\DoxyCodeLine{01036         \}}
\DoxyCodeLine{01037         int asciiflag = param.ascii\_output;}
\DoxyCodeLine{01038         param.ascii\_output = 0;}
\DoxyCodeLine{01039         h5time = startTime;}
\DoxyCodeLine{01040         write\_particles\_to\_file(inputFile);}
\DoxyCodeLine{01041         param.ascii\_output = asciiflag;}
\DoxyCodeLine{01042     \}}
\DoxyCodeLine{01043 }
\DoxyCodeLine{01044     if (param.verbose) \{}
\DoxyCodeLine{01045         printf("{}Simulation time start: \%g\(\backslash\)n"{}, startTime);}
\DoxyCodeLine{01046     \}}
\DoxyCodeLine{01047 }
\DoxyCodeLine{01048     if (param.verbose) printf("{}starting time integration...\(\backslash\)n\(\backslash\)n"{});}
\DoxyCodeLine{01049     cudaProfilerStart();}
\DoxyCodeLine{01050     timeIntegration();}
\DoxyCodeLine{01051     cudaProfilerStop();}
\DoxyCodeLine{01052 }
\DoxyCodeLine{01053     /* free memory */}
\DoxyCodeLine{01054     if (param.verbose) printf("{}freeing memory\(\backslash\)n"{});}
\DoxyCodeLine{01055     free\_memory();}
\DoxyCodeLine{01056 }
\DoxyCodeLine{01057     if (param.verbose) printf("{}resetting GPU...\(\backslash\)n"{});}
\DoxyCodeLine{01058     cudaVerify(cudaDeviceReset());}
\DoxyCodeLine{01059 }
\DoxyCodeLine{01060 }
\DoxyCodeLine{01061     if (param.verbose) printf("{}kthxbye.\(\backslash\)n"{});}
\DoxyCodeLine{01062 }
\DoxyCodeLine{01063 }
\DoxyCodeLine{01064     return 0;}
\DoxyCodeLine{01065 }
\DoxyCodeLine{01066 \}}

\end{DoxyCode}
