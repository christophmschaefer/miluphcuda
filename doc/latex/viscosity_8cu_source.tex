\hypertarget{viscosity_8cu_source}{}\doxysection{viscosity.\+cu}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001 /**}
\DoxyCodeLine{00002  * @author      Marius Morlock and Christoph Schaefer}
\DoxyCodeLine{00003  *}
\DoxyCodeLine{00004  * @section     LICENSE}
\DoxyCodeLine{00005  * Copyright (c) 2019 Christoph Schaefer}
\DoxyCodeLine{00006  *}
\DoxyCodeLine{00007  * This file is part of miluphcuda.}
\DoxyCodeLine{00008  *}
\DoxyCodeLine{00009  * miluphcuda is free software: you can redistribute it and/or modify}
\DoxyCodeLine{00010  * it under the terms of the GNU General Public License as published by}
\DoxyCodeLine{00011  * the Free Software Foundation, either version 3 of the License, or}
\DoxyCodeLine{00012  * (at your option) any later version.}
\DoxyCodeLine{00013  *}
\DoxyCodeLine{00014  * miluphcuda is distributed in the hope that it will be useful,}
\DoxyCodeLine{00015  * but WITHOUT ANY WARRANTY; without even the implied warranty of}
\DoxyCodeLine{00016  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the}
\DoxyCodeLine{00017  * GNU General Public License for more details.}
\DoxyCodeLine{00018  *}
\DoxyCodeLine{00019  * You should have received a copy of the GNU General Public License}
\DoxyCodeLine{00020  * along with miluphcuda.  If not, see <http://www.gnu.org/licenses/>.}
\DoxyCodeLine{00021  *}
\DoxyCodeLine{00022  */}
\DoxyCodeLine{00023 \#include "{}viscosity.h"{}}
\DoxyCodeLine{00024 \#include "{}miluph.h"{}}
\DoxyCodeLine{00025 \#include "{}soundspeed.h"{}}
\DoxyCodeLine{00026 \#include "{}timeintegration.h"{}}
\DoxyCodeLine{00027 \#include "{}kernel.h"{}}
\DoxyCodeLine{00028 \#include "{}parameter.h"{}}
\DoxyCodeLine{00029 }
\DoxyCodeLine{00030 extern \_\_device\_\_ SPH\_kernel kernel;}
\DoxyCodeLine{00031 }
\DoxyCodeLine{00032 }
\DoxyCodeLine{00033 }
\DoxyCodeLine{00034 \#if NAVIER\_STOKES}
\DoxyCodeLine{00035 \_\_global\_\_ void calculate\_shear\_stress\_tensor(int *interactions)}
\DoxyCodeLine{00036 \{}
\DoxyCodeLine{00037 }
\DoxyCodeLine{00038         int i, inc;}
\DoxyCodeLine{00039     int e, f, g;}
\DoxyCodeLine{00040     int j, k;}
\DoxyCodeLine{00041         inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00042     //Particle Loop}
\DoxyCodeLine{00043     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numRealParticles; i += inc) \{}
\DoxyCodeLine{00044         double dv[DIM];}
\DoxyCodeLine{00045         double dr[DIM];}
\DoxyCodeLine{00046         double r;}
\DoxyCodeLine{00047         double sml;}
\DoxyCodeLine{00048         double dWdr, W;}
\DoxyCodeLine{00049         double dWdx[DIM];}
\DoxyCodeLine{00050 }
\DoxyCodeLine{00051         for (k = 0; k < DIM*DIM; k++) \{}
\DoxyCodeLine{00052             p.Tshear[i*DIM*DIM+k] = 0.0;}
\DoxyCodeLine{00053         \}}
\DoxyCodeLine{00054 }
\DoxyCodeLine{00055         for (k = 0; k < p.noi[i]; k++) \{}
\DoxyCodeLine{00056             j = interactions[i * MAX\_NUM\_INTERACTIONS + k];}
\DoxyCodeLine{00057 }
\DoxyCodeLine{00058             dv[0] = p.vx[i] -\/ p.vx[j];}
\DoxyCodeLine{00059 \#if DIM > 1}
\DoxyCodeLine{00060             dv[1] = p.vy[i] -\/ p.vy[j];}
\DoxyCodeLine{00061 \#if DIM > 2}
\DoxyCodeLine{00062             dv[2] = p.vz[i] -\/ p.vz[j];}
\DoxyCodeLine{00063 \#endif}
\DoxyCodeLine{00064 \#endif}
\DoxyCodeLine{00065 }
\DoxyCodeLine{00066             // relative vector}
\DoxyCodeLine{00067             dr[0] = p.x[i] -\/ p.x[j];}
\DoxyCodeLine{00068 \#if DIM > 1}
\DoxyCodeLine{00069             dr[1] = p.y[i] -\/ p.y[j];}
\DoxyCodeLine{00070 \#if DIM > 2}
\DoxyCodeLine{00071             dr[2] = p.z[i] -\/ p.z[j];}
\DoxyCodeLine{00072 \#endif}
\DoxyCodeLine{00073 \#endif}
\DoxyCodeLine{00074 }
\DoxyCodeLine{00075             r = 0;}
\DoxyCodeLine{00076             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00077                 r += dr[e]*dr[e];}
\DoxyCodeLine{00078                 dWdx[e] = 0.0;}
\DoxyCodeLine{00079             \}}
\DoxyCodeLine{00080             W = 0.0;}
\DoxyCodeLine{00081             dWdr = 0.0;}
\DoxyCodeLine{00082             r = sqrt(r);}
\DoxyCodeLine{00083 }
\DoxyCodeLine{00084             sml = p.h[i];}
\DoxyCodeLine{00085 \#if (VARIABLE\_SML || INTEGRATE\_SML || DEAL\_WITH\_TOO\_MANY\_INTERACTIONS)}
\DoxyCodeLine{00086             sml = 0.5*(p.h[i] + p.h[j]);}
\DoxyCodeLine{00087 \#endif}
\DoxyCodeLine{00088             // get kernel values for this interaction}
\DoxyCodeLine{00089             kernel(\&W, dWdx, \&dWdr, dr, sml);}
\DoxyCodeLine{00090 }
\DoxyCodeLine{00091 }
\DoxyCodeLine{00092 \#if TENSORIAL\_CORRECTION}
\DoxyCodeLine{00093             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00094                 for (f = 0; f < DIM; f++) \{}
\DoxyCodeLine{00095                     for (g = 0; g < DIM; g++) \{}
\DoxyCodeLine{00096                         p.Tshear[i*DIM*DIM+e*DIM+f] += p.m[j]/p.rho[j] * (p\_rhs.tensorialCorrectionMatrix[i*DIM*DIM+f*DIM+g] * (-\/dv[e]) * dr[g] * dWdr/r + p\_rhs.tensorialCorrectionMatrix[i*DIM*DIM+e*DIM+g] * (-\/dv[f]) * dr[g] * dWdr/r);}
\DoxyCodeLine{00097                     \}}
\DoxyCodeLine{00098                     // traceless}
\DoxyCodeLine{00099                     if (e == f) \{}
\DoxyCodeLine{00100                         for (g = 0; g < DIM; g++) \{}
\DoxyCodeLine{00101                             p.Tshear[i*DIM*DIM+e*DIM+f] -\/= 2./3 * p.m[j]/p.rho[j] * (p\_rhs.tensorialCorrectionMatrix[i*DIM*DIM+e*DIM+g] * (-\/dv[e]) * dr[g] * dWdr/r);}
\DoxyCodeLine{00102                         \}}
\DoxyCodeLine{00103 }
\DoxyCodeLine{00104                     \}}
\DoxyCodeLine{00105                 \}}
\DoxyCodeLine{00106             \}}
\DoxyCodeLine{00107 \#else}
\DoxyCodeLine{00108             double trace = 0;}
\DoxyCodeLine{00109             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00110 \# if (SPHEQUATIONS == SPH\_VERSION1)}
\DoxyCodeLine{00111                 trace +=  p.m[j]/p.rho[i] * (-\/dv[e])*dWdx[e] ;}
\DoxyCodeLine{00112 \# elif (SPHEQUATIONS == SPH\_VERSION2)}
\DoxyCodeLine{00113                 trace +=  p.m[j]/p.rho[j] * (-\/dv[e])*dWdx[e] ;}
\DoxyCodeLine{00114 \#endif}
\DoxyCodeLine{00115             \}}
\DoxyCodeLine{00116             }
\DoxyCodeLine{00117             for (e = 0; e < DIM; e++) \{}
\DoxyCodeLine{00118                 for (f = 0; f < DIM; f++) \{}
\DoxyCodeLine{00119 \# if (SPHEQUATIONS == SPH\_VERSION1)}
\DoxyCodeLine{00120                     p.Tshear[i*DIM*DIM+e*DIM+f] += p.m[j]/p.rho[i] * (-\/dv[e]*dWdx[f] -\/ dv[f]*dWdx[e]);}
\DoxyCodeLine{00121 \# elif (SPHEQUATIONS == SPH\_VERSION2)}
\DoxyCodeLine{00122                     p.Tshear[i*DIM*DIM+e*DIM+f] += p.m[j]/p.rho[j] * (-\/dv[e]*dWdx[f] -\/ dv[f]*dWdx[e]);}
\DoxyCodeLine{00123 \#endif}
\DoxyCodeLine{00124                     // traceless}
\DoxyCodeLine{00125                     if (e == f) \{}
\DoxyCodeLine{00126 \# if (SPHEQUATIONS == SPH\_VERSION1)}
\DoxyCodeLine{00127                         p.Tshear[i*DIM*DIM+e*DIM+f] -\/= 2./3 * trace;}
\DoxyCodeLine{00128 \# elif (SPHEQUATIONS == SPH\_VERSION2)}
\DoxyCodeLine{00129                         p.Tshear[i*DIM*DIM+e*DIM+f] -\/= 2./3 * trace;}
\DoxyCodeLine{00130 \#endif}
\DoxyCodeLine{00131                     \}}
\DoxyCodeLine{00132                 \}}
\DoxyCodeLine{00133             \}}
\DoxyCodeLine{00134 \#endif}
\DoxyCodeLine{00135         \}}
\DoxyCodeLine{00136     \}}
\DoxyCodeLine{00137 \}}
\DoxyCodeLine{00138 \#endif}
\DoxyCodeLine{00139 }
\DoxyCodeLine{00140 }
\DoxyCodeLine{00141 /*normally known as beta viscosity, here we use beta due to naming concerns of other variables in this code and to avoid confusion */}
\DoxyCodeLine{00142 \#if INVISCID\_SPH}
\DoxyCodeLine{00143 \_\_global\_\_ void betaviscosity(int *interactions)}
\DoxyCodeLine{00144 \{}
\DoxyCodeLine{00145 }
\DoxyCodeLine{00146         register int d, i, j, k, m, inc, numInteractions;}
\DoxyCodeLine{00147         inc = blockDim.x * gridDim.x;}
\DoxyCodeLine{00148 }
\DoxyCodeLine{00149         double dv[DIM], dx[DIM];}
\DoxyCodeLine{00150         double vi[DIM], vj[DIM];}
\DoxyCodeLine{00151         double mj, rhoi;}
\DoxyCodeLine{00152         double W, dWdx[DIM], dWdr;}
\DoxyCodeLine{00153         double divv[DIM], divV, divvdt;}
\DoxyCodeLine{00154         double tau, sml, csound;}
\DoxyCodeLine{00155         double Ai, Ri, Xii;}
\DoxyCodeLine{00156         double curlj[DIM][DIM] = \{0\};}
\DoxyCodeLine{00157         double transpose[DIM][DIM] = \{0\};}
\DoxyCodeLine{00158         double limiterMatrix[DIM][DIM] = \{0\};}
\DoxyCodeLine{00159         double traceLimiter = 0;}
\DoxyCodeLine{00160         double beta\_loc;}
\DoxyCodeLine{00161         double beta\_max = 4;}
\DoxyCodeLine{00162 }
\DoxyCodeLine{00163     //Particle Loop}
\DoxyCodeLine{00164     for (i = threadIdx.x + blockIdx.x * blockDim.x; i < numRealParticles; i += inc) \{}
\DoxyCodeLine{00165         numInteractions = p.noi[i];}
\DoxyCodeLine{00166         sml = p.h[i];}
\DoxyCodeLine{00167         csound = p.cs[i];}
\DoxyCodeLine{00168         rhoi = p.rho[i];}
\DoxyCodeLine{00169         W = 0.0;}
\DoxyCodeLine{00170         dWdr = 0.0;}
\DoxyCodeLine{00171         Ai = 0;}
\DoxyCodeLine{00172         Ri = 0;}
\DoxyCodeLine{00173         Xii = 0;}
\DoxyCodeLine{00174 }
\DoxyCodeLine{00175         //Interaction Partner Loop}
\DoxyCodeLine{00176                 for(k = 0; k < numInteractions; k++) \{}
\DoxyCodeLine{00177                 j = interactions[i * MAX\_NUM\_INTERACTIONS + k];}
\DoxyCodeLine{00178             dx[0] = p.x[i] -\/ p.x[j];}
\DoxyCodeLine{00179             dv[0] = p.vx[i] -\/ p.vx[j];}
\DoxyCodeLine{00180 \#if DIM > 1}
\DoxyCodeLine{00181             dx[1] = p.y[i] -\/ p.y[j];}
\DoxyCodeLine{00182             dv[1] = p.vy[i] -\/ p.vy[j];}
\DoxyCodeLine{00183 \#if DIM > 2}
\DoxyCodeLine{00184             dx[2] = p.z[i] -\/ p.z[j];}
\DoxyCodeLine{00185             dv[2] = p.vz[i] -\/ p.vz[j];}
\DoxyCodeLine{00186 \#endif}
\DoxyCodeLine{00187 \#endif}
\DoxyCodeLine{00188             vi[0] = p.vx[i];}
\DoxyCodeLine{00189             vj[0] = p.vx[j];}
\DoxyCodeLine{00190 \#if DIM > 1}
\DoxyCodeLine{00191             vi[1] = p.vy[i];}
\DoxyCodeLine{00192             vj[1] = p.vy[j];}
\DoxyCodeLine{00193 \#if DIM > 2}
\DoxyCodeLine{00194             vi[2] = p.vz[i];}
\DoxyCodeLine{00195             vj[2] = p.vz[j];}
\DoxyCodeLine{00196 \#endif}
\DoxyCodeLine{00197 \#endif}
\DoxyCodeLine{00198 }
\DoxyCodeLine{00199                kernel(\&W, dWdx, \&dWdr, dx, sml);}
\DoxyCodeLine{00200                mj = p.m[j];}
\DoxyCodeLine{00201 }
\DoxyCodeLine{00202                 /* divv */}
\DoxyCodeLine{00203             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00204                 divv[d] = mj/rhoi * (vj[d] -\/ vi[d]) * dWdx[d];}
\DoxyCodeLine{00205             /* Limiter Matrix */}
\DoxyCodeLine{00206                     for (m = 0; m < DIM; m++) \{}
\DoxyCodeLine{00207                     curlj[d][m] = 0;}
\DoxyCodeLine{00208                     \}}
\DoxyCodeLine{00209             \}}
\DoxyCodeLine{00210 }
\DoxyCodeLine{00211 }
\DoxyCodeLine{00212             for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00213                     curlj[d][d] = -\/1.0/DIM * divv[d];}
\DoxyCodeLine{00214                         for (m = 0; m < DIM; m++) \{}
\DoxyCodeLine{00215                                 curlj[d][m] += (mj/rhoi) *(dv[d]*dWdx[d]/(dx[m]*dWdx[m]) + dv[m]*dWdx[m]/(dx[d]*dWdx[d]))/2;}
\DoxyCodeLine{00216                                 transpose[m][d] = curlj[d][m];}
\DoxyCodeLine{00217                         \}}
\DoxyCodeLine{00218                 \}}
\DoxyCodeLine{00219 }
\DoxyCodeLine{00220                 multiply(curlj, transpose, limiterMatrix);}
\DoxyCodeLine{00221                 for (d = 0; d < DIM; d++) \{}
\DoxyCodeLine{00222                         traceLimiter += limiterMatrix[d][d];}
\DoxyCodeLine{00223                         Ri += 1.0/rhoi * sign(dv[d]) * mj * dWdx[d];}
\DoxyCodeLine{00224                 \}}
\DoxyCodeLine{00225         \} /* Ending Interaction Partner Loop */}
\DoxyCodeLine{00226 }
\DoxyCodeLine{00227 }
\DoxyCodeLine{00228 }
\DoxyCodeLine{00229 }
\DoxyCodeLine{00230         /* Calculating d/dt(divv) */}
\DoxyCodeLine{00231                 divV = p\_rhs.divv[i];}
\DoxyCodeLine{00232                 divvdt = divV -\/ p.divv\_old[i];}
\DoxyCodeLine{00233 }
\DoxyCodeLine{00234 }
\DoxyCodeLine{00235                 /* decay time */}
\DoxyCodeLine{00236                 tau = sml / (2.0 * 0.05 * csound);}
\DoxyCodeLine{00237 }
\DoxyCodeLine{00238                 /* Limiter for strong shear forces */}
\DoxyCodeLine{00239                 Xii = pow(fabs(2 * pow((1.0 -\/ Ri),4) * divV),2) / (pow(fabs(2 * pow((1.0 -\/ Ri),4) * divV),2) + pow(1.0+fabs(traceLimiter),2));}
\DoxyCodeLine{00240                 //fprintf(stdout, "{}Ri: \%e\(\backslash\)n"{}, Ri);}
\DoxyCodeLine{00241                 //fprintf(stdout, "{}vvnablaW: \%e\(\backslash\)n"{}, vvnablaW);}
\DoxyCodeLine{00242                 //fprintf(stdout, "{}traceLimiter: \%e\(\backslash\)n"{}, traceLimiter);}
\DoxyCodeLine{00243                 //fprintf(stdout, "{}Xii: \%e\(\backslash\)n"{}, Xii);}
\DoxyCodeLine{00244 }
\DoxyCodeLine{00245                 /* Calc shock indicator */}
\DoxyCodeLine{00246                 if ((-\/1.0*divvdt) > 0) \{}
\DoxyCodeLine{00247                         Ai = Xii * -\/1.0 * divvdt;}
\DoxyCodeLine{00248                 \}}
\DoxyCodeLine{00249                 else \{}
\DoxyCodeLine{00250                         Ai = 0;}
\DoxyCodeLine{00251                 \}}
\DoxyCodeLine{00252                 //fprintf(stdout, "{}p[\%d].divvdt: \%e\(\backslash\)n"{}, i, p[i].divvdt);}
\DoxyCodeLine{00253                 beta\_loc = beta\_max * pow(sml, 2) * Ai / (pow(csound, 2) + pow(sml, 2) * Ai);}
\DoxyCodeLine{00254                 //fprintf(stdout, "{}p[\%d].cs: \%e\(\backslash\)n"{}, i, p[i].cs);}
\DoxyCodeLine{00255                 //fprintf(stdout, "{}p[\%d].sml: \%e\(\backslash\)n"{}, i, p[i].sml);}
\DoxyCodeLine{00256                 //fprintf(stdout, "{}Ai: \%e\(\backslash\)n"{}, Ai);}
\DoxyCodeLine{00257                 //fprintf(stdout, "{}beta\_max: \%e\(\backslash\)n"{}, beta\_max);}
\DoxyCodeLine{00258                 //fprintf(stdout, "{}beta\_loc: \%e\(\backslash\)n"{}, beta\_loc);}
\DoxyCodeLine{00259 }
\DoxyCodeLine{00260                 if (beta\_loc > p.beta\_old[i]) \{}
\DoxyCodeLine{00261                         p.beta[i] = beta\_loc;}
\DoxyCodeLine{00262                         p.dbetadt[i] = 0;}
\DoxyCodeLine{00263                 \} else}
\DoxyCodeLine{00264                 \{}
\DoxyCodeLine{00265                         p.beta[i] = p.beta\_old[i];}
\DoxyCodeLine{00266                         p.dbetadt[i] = (p.beta\_old[i] -\/ beta\_loc) / tau;}
\DoxyCodeLine{00267                 \}}
\DoxyCodeLine{00268 }
\DoxyCodeLine{00269                 /* getting ready for the next timestep by giving the "{}new"{} old values the current ones */}
\DoxyCodeLine{00270                 p.beta\_old[i] = p.beta[i];}
\DoxyCodeLine{00271                 p.divv\_old[i] = divV;}
\DoxyCodeLine{00272         \} // Ending Particle Loop}
\DoxyCodeLine{00273 \}}
\DoxyCodeLine{00274 \#endif}
\DoxyCodeLine{00275 }
\DoxyCodeLine{00276 \_\_device\_\_ int sign(double x)}
\DoxyCodeLine{00277 \{}
\DoxyCodeLine{00278         if (x < 0) \{}
\DoxyCodeLine{00279                 return -\/1;}
\DoxyCodeLine{00280         \} else if (x > 0) \{}
\DoxyCodeLine{00281                 return  1;}
\DoxyCodeLine{00282         \} else \{}
\DoxyCodeLine{00283                 return 0;}
\DoxyCodeLine{00284         \}}
\DoxyCodeLine{00285 \}}
\DoxyCodeLine{00286 }
\DoxyCodeLine{00287 /* function for multiplying two matrices */}
\DoxyCodeLine{00288 \_\_device\_\_ void multiply(double mat1[][DIM], double mat2[][DIM], double res[][DIM])}
\DoxyCodeLine{00289 \{}
\DoxyCodeLine{00290     int i, j, k;}
\DoxyCodeLine{00291     for (i = 0; i < DIM; i++) \{}
\DoxyCodeLine{00292         for (j = 0; j < DIM; j++) \{}
\DoxyCodeLine{00293             for (k = 0; k < DIM; k++) \{}
\DoxyCodeLine{00294                 res[i][j] += mat1[i][k]*mat2[k][j];}
\DoxyCodeLine{00295             \}}
\DoxyCodeLine{00296         \}}
\DoxyCodeLine{00297      \}}
\DoxyCodeLine{00298 \}}

\end{DoxyCode}
